const tm=function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function e(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerpolicy&&(s.referrerPolicy=i.referrerpolicy),i.crossorigin==="use-credentials"?s.credentials="include":i.crossorigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(i){if(i.ep)return;i.ep=!0;const s=e(i);fetch(i.href,s)}};tm();const em=["beamWithHinges","dispBeamColumn","elasticBeamColumn","nonlinearBeamColumn"],nm=["ShellMITC4"];function cr(o,t=5){return(" ".repeat(t)+o.toString()).slice(-t)}function ue(o,t=5,e=8){var n=" ".repeat(e)+o.toFixed(t);return n.slice(-e)}function im(o,t){let e=o.split(/\s+/).slice(1);var n=e[0];let i={};if(em.includes(n)){var s=parseInt(e[1]),a=parseInt(e[2]),h=parseInt(e[3]);i.type=n,i.intElementNumber=s,i.listNodeNumber=[a,h]}else if(nm.includes(n)){var s=parseInt(e[1]),a=parseInt(e[2]),h=parseInt(e[3]),u=parseInt(e[4]),d=parseInt(e[5]);i.type=n,i.intElementNumber=s,i.listNodeNumber=[a,h,u,d]}else console.log("ERROR, element type not supported"),console.log(o);return i}function rm(o){for(var t={},e={},n={},i=0;i<o.length;i++){let f=o[i];if(f.startsWith("set"))var s=f.match(/-expr\s\d*.*-/);if(f.startsWith("model")){var s=f.match(/-ndm\s\d*.*-/)[0];parseInt(s.slice(4,-1)),s=f.match(/-ndf\s\d*/)[0],parseInt(s.slice(4))}if(f.startsWith("node")){var a=f.split(/\s+/).slice(1),h=parseInt(a[0]),u=a.slice(1).map(function(g){return parseFloat(g)});t[h]={coordinate:u}}if(f.startsWith("mass")){var a=f.split(/\s+/).slice(1),h=parseInt(a[0]),d=a.slice(1).map(function(v){return parseFloat(v)});t[h].directional_mass=d,t[h].mass=(d[0]+d[1]+d[2])/3}if(f.startsWith("element")){let g=im(f),m=g.intElementNumber;g.listNodeNumber.length==2?e[m]=g:g.listNodeNumber.length==4&&(n[m]=g)}}return[t,e,n]}/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const iu="132",Ri={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Di={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},sm=0,wc=1,om=2,ru=1,am=2,jr=3,Qr=0,me=1,hr=2,su=1,jn=0,Zr=1,Mc=2,Sc=3,Ec=4,lm=5,Qi=100,cm=101,hm=102,Tc=103,Cc=104,um=200,dm=201,pm=202,fm=203,ou=204,au=205,mm=206,gm=207,vm=208,_m=209,xm=210,bm=0,ym=1,wm=2,Ja=3,Mm=4,Sm=5,Em=6,Tm=7,mo=0,Cm=1,Am=2,gi=0,Pm=1,Lm=2,Rm=3,Dm=4,Im=5,lu=300,go=301,vo=302,$a=303,Qa=304,_o=306,dl=307,tl=1e3,Xe=1001,el=1002,_e=1003,Ac=1004,Pc=1005,en=1006,Nm=1007,xo=1008,ur=1009,Fm=1010,km=1011,oo=1012,Bm=1013,ro=1014,fi=1015,sr=1016,Vm=1017,Om=1018,zm=1019,Kr=1020,Um=1021,Xn=1022,Ye=1023,Hm=1024,Gm=1025,Wm=Ye,or=1026,ts=1027,qm=1028,jm=1029,Xm=1030,Ym=1031,Zm=1032,Km=1033,Lc=33776,Rc=33777,Dc=33778,Ic=33779,Nc=35840,Fc=35841,kc=35842,Bc=35843,Jm=36196,Vc=37492,Oc=37496,$m=37808,Qm=37809,tg=37810,eg=37811,ng=37812,ig=37813,rg=37814,sg=37815,og=37816,ag=37817,lg=37818,cg=37819,hg=37820,ug=37821,dg=36492,pg=37840,fg=37841,mg=37842,gg=37843,vg=37844,_g=37845,xg=37846,bg=37847,yg=37848,wg=37849,Mg=37850,Sg=37851,Eg=37852,Tg=37853,Cg=2200,Ag=2201,Pg=2202,ao=2300,lo=2301,ra=2302,tr=2400,er=2401,co=2402,pl=2500,cu=2501,Lg=0,He=3e3,bo=3001,fl=3007,ml=3002,Rg=3003,hu=3004,uu=3005,du=3006,Dg=3200,Ig=3201,fr=0,Ng=1,sa=7680,Fg=519,es=35044,ho=35048,zc="300 es";class ti{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const i=this._listeners[t];if(i!==void 0){const s=i.indexOf(e);s!==-1&&i.splice(s,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const n=this._listeners[t.type];if(n!==void 0){t.target=this;const i=n.slice(0);for(let s=0,a=i.length;s<a;s++)i[s].call(this,t);t.target=null}}}const be=[];for(let o=0;o<256;o++)be[o]=(o<16?"0":"")+o.toString(16);const oa=Math.PI/180,nl=180/Math.PI;function bn(){const o=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(be[o&255]+be[o>>8&255]+be[o>>16&255]+be[o>>24&255]+"-"+be[t&255]+be[t>>8&255]+"-"+be[t>>16&15|64]+be[t>>24&255]+"-"+be[e&63|128]+be[e>>8&255]+"-"+be[e>>16&255]+be[e>>24&255]+be[n&255]+be[n>>8&255]+be[n>>16&255]+be[n>>24&255]).toUpperCase()}function De(o,t,e){return Math.max(t,Math.min(e,o))}function kg(o,t){return(o%t+t)%t}function aa(o,t,e){return(1-e)*o+e*t}function Uc(o){return(o&o-1)===0&&o!==0}function Bg(o){return Math.pow(2,Math.floor(Math.log(o)/Math.LN2))}class it{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),s=this.x-t.x,a=this.y-t.y;return this.x=s*n-a*i+t.x,this.y=s*i+a*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}it.prototype.isVector2=!0;class ye{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,s,a,h,u,d){const f=this.elements;return f[0]=t,f[1]=i,f[2]=h,f[3]=e,f[4]=s,f[5]=u,f[6]=n,f[7]=a,f[8]=d,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,s=this.elements,a=n[0],h=n[3],u=n[6],d=n[1],f=n[4],g=n[7],m=n[2],v=n[5],b=n[8],y=i[0],M=i[3],x=i[6],_=i[1],R=i[4],L=i[7],A=i[2],N=i[5],C=i[8];return s[0]=a*y+h*_+u*A,s[3]=a*M+h*R+u*N,s[6]=a*x+h*L+u*C,s[1]=d*y+f*_+g*A,s[4]=d*M+f*R+g*N,s[7]=d*x+f*L+g*C,s[2]=m*y+v*_+b*A,s[5]=m*M+v*R+b*N,s[8]=m*x+v*L+b*C,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],a=t[4],h=t[5],u=t[6],d=t[7],f=t[8];return e*a*f-e*h*d-n*s*f+n*h*u+i*s*d-i*a*u}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],a=t[4],h=t[5],u=t[6],d=t[7],f=t[8],g=f*a-h*d,m=h*u-f*s,v=d*s-a*u,b=e*g+n*m+i*v;if(b===0)return this.set(0,0,0,0,0,0,0,0,0);const y=1/b;return t[0]=g*y,t[1]=(i*d-f*n)*y,t[2]=(h*n-i*a)*y,t[3]=m*y,t[4]=(f*e-i*u)*y,t[5]=(i*s-h*e)*y,t[6]=v*y,t[7]=(n*u-d*e)*y,t[8]=(a*e-n*s)*y,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,s,a,h){const u=Math.cos(s),d=Math.sin(s);return this.set(n*u,n*d,-n*(u*a+d*h)+a+t,-i*d,i*u,-i*(-d*a+u*h)+h+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),i=this.elements,s=i[0],a=i[3],h=i[6],u=i[1],d=i[4],f=i[7];return i[0]=e*s+n*u,i[3]=e*a+n*d,i[6]=e*h+n*f,i[1]=-n*s+e*u,i[4]=-n*a+e*d,i[7]=-n*h+e*f,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<9;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}ye.prototype.isMatrix3=!0;let Ii;class mr{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement=="undefined")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{Ii===void 0&&(Ii=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),Ii.width=t.width,Ii.height=t.height;const n=Ii.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=Ii}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}}let Vg=0;class Me extends ti{constructor(t=Me.DEFAULT_IMAGE,e=Me.DEFAULT_MAPPING,n=Xe,i=Xe,s=en,a=xo,h=Ye,u=ur,d=1,f=He){super(),Object.defineProperty(this,"id",{value:Vg++}),this.uuid=bn(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=i,this.magFilter=s,this.minFilter=a,this.anisotropy=d,this.format=h,this.internalFormat=null,this.type=u,this.offset=new it(0,0),this.repeat=new it(1,1),this.center=new it(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new ye,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=f,this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const i=this.image;if(i.uuid===void 0&&(i.uuid=bn()),!e&&t.images[i.uuid]===void 0){let s;if(Array.isArray(i)){s=[];for(let a=0,h=i.length;a<h;a++)i[a].isDataTexture?s.push(la(i[a].image)):s.push(la(i[a]))}else s=la(i);t.images[i.uuid]={uuid:i.uuid,url:s}}n.image=i.uuid}return e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==lu)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case tl:t.x=t.x-Math.floor(t.x);break;case Xe:t.x=t.x<0?0:1;break;case el:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case tl:t.y=t.y-Math.floor(t.y);break;case Xe:t.y=t.y<0?0:1;break;case el:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&this.version++}}Me.DEFAULT_IMAGE=void 0;Me.DEFAULT_MAPPING=lu;Me.prototype.isTexture=!0;function la(o){return typeof HTMLImageElement!="undefined"&&o instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&o instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&o instanceof ImageBitmap?mr.getDataURL(o):o.data?{data:Array.prototype.slice.call(o.data),width:o.width,height:o.height,type:o.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class te{constructor(t=0,e=0,n=0,i=1){this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,s=this.w,a=t.elements;return this.x=a[0]*e+a[4]*n+a[8]*i+a[12]*s,this.y=a[1]*e+a[5]*n+a[9]*i+a[13]*s,this.z=a[2]*e+a[6]*n+a[10]*i+a[14]*s,this.w=a[3]*e+a[7]*n+a[11]*i+a[15]*s,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,s;const u=t.elements,d=u[0],f=u[4],g=u[8],m=u[1],v=u[5],b=u[9],y=u[2],M=u[6],x=u[10];if(Math.abs(f-m)<.01&&Math.abs(g-y)<.01&&Math.abs(b-M)<.01){if(Math.abs(f+m)<.1&&Math.abs(g+y)<.1&&Math.abs(b+M)<.1&&Math.abs(d+v+x-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const R=(d+1)/2,L=(v+1)/2,A=(x+1)/2,N=(f+m)/4,C=(g+y)/4,z=(b+M)/4;return R>L&&R>A?R<.01?(n=0,i=.707106781,s=.707106781):(n=Math.sqrt(R),i=N/n,s=C/n):L>A?L<.01?(n=.707106781,i=0,s=.707106781):(i=Math.sqrt(L),n=N/i,s=z/i):A<.01?(n=.707106781,i=.707106781,s=0):(s=Math.sqrt(A),n=C/s,i=z/s),this.set(n,i,s,e),this}let _=Math.sqrt((M-b)*(M-b)+(g-y)*(g-y)+(m-f)*(m-f));return Math.abs(_)<.001&&(_=1),this.x=(M-b)/_,this.y=(g-y)/_,this.z=(m-f)/_,this.w=Math.acos((d+v+x-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}te.prototype.isVector4=!0;class yn extends ti{constructor(t,e,n={}){super(),this.width=t,this.height=e,this.depth=1,this.scissor=new te(0,0,t,e),this.scissorTest=!1,this.viewport=new te(0,0,t,e),this.texture=new Me(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:t,height:e,depth:1},this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:en,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,n=1){(this.width!==t||this.height!==e||this.depth!==n)&&(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.image={...this.texture.image},this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}yn.prototype.isWebGLRenderTarget=!0;class Og extends yn{constructor(t,e,n){super(t,e);const i=this.texture;this.texture=[];for(let s=0;s<n;s++)this.texture[s]=i.clone()}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let i=0,s=this.texture.length;i<s;i++)this.texture[i].image.width=t,this.texture[i].image.height=e,this.texture[i].image.depth=n;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this.texture.length=0;for(let e=0,n=t.texture.length;e<n;e++)this.texture[e]=t.texture[e].clone();return this}}Og.prototype.isWebGLMultipleRenderTargets=!0;class pu extends yn{constructor(t,e,n){super(t,e,n),this.samples=4}copy(t){return super.copy.call(this,t),this.samples=t.samples,this}}pu.prototype.isWebGLMultisampleRenderTarget=!0;class we{constructor(t=0,e=0,n=0,i=1){this._x=t,this._y=e,this._z=n,this._w=i}static slerp(t,e,n,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,i)}static slerpFlat(t,e,n,i,s,a,h){let u=n[i+0],d=n[i+1],f=n[i+2],g=n[i+3];const m=s[a+0],v=s[a+1],b=s[a+2],y=s[a+3];if(h===0){t[e+0]=u,t[e+1]=d,t[e+2]=f,t[e+3]=g;return}if(h===1){t[e+0]=m,t[e+1]=v,t[e+2]=b,t[e+3]=y;return}if(g!==y||u!==m||d!==v||f!==b){let M=1-h;const x=u*m+d*v+f*b+g*y,_=x>=0?1:-1,R=1-x*x;if(R>Number.EPSILON){const A=Math.sqrt(R),N=Math.atan2(A,x*_);M=Math.sin(M*N)/A,h=Math.sin(h*N)/A}const L=h*_;if(u=u*M+m*L,d=d*M+v*L,f=f*M+b*L,g=g*M+y*L,M===1-h){const A=1/Math.sqrt(u*u+d*d+f*f+g*g);u*=A,d*=A,f*=A,g*=A}}t[e]=u,t[e+1]=d,t[e+2]=f,t[e+3]=g}static multiplyQuaternionsFlat(t,e,n,i,s,a){const h=n[i],u=n[i+1],d=n[i+2],f=n[i+3],g=s[a],m=s[a+1],v=s[a+2],b=s[a+3];return t[e]=h*b+f*g+u*v-d*m,t[e+1]=u*b+f*m+d*g-h*v,t[e+2]=d*b+f*v+h*m-u*g,t[e+3]=f*b-h*g-u*m-d*v,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,i=t._y,s=t._z,a=t._order,h=Math.cos,u=Math.sin,d=h(n/2),f=h(i/2),g=h(s/2),m=u(n/2),v=u(i/2),b=u(s/2);switch(a){case"XYZ":this._x=m*f*g+d*v*b,this._y=d*v*g-m*f*b,this._z=d*f*b+m*v*g,this._w=d*f*g-m*v*b;break;case"YXZ":this._x=m*f*g+d*v*b,this._y=d*v*g-m*f*b,this._z=d*f*b-m*v*g,this._w=d*f*g+m*v*b;break;case"ZXY":this._x=m*f*g-d*v*b,this._y=d*v*g+m*f*b,this._z=d*f*b+m*v*g,this._w=d*f*g-m*v*b;break;case"ZYX":this._x=m*f*g-d*v*b,this._y=d*v*g+m*f*b,this._z=d*f*b-m*v*g,this._w=d*f*g+m*v*b;break;case"YZX":this._x=m*f*g+d*v*b,this._y=d*v*g+m*f*b,this._z=d*f*b-m*v*g,this._w=d*f*g-m*v*b;break;case"XZY":this._x=m*f*g-d*v*b,this._y=d*v*g-m*f*b,this._z=d*f*b+m*v*g,this._w=d*f*g+m*v*b;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],s=e[8],a=e[1],h=e[5],u=e[9],d=e[2],f=e[6],g=e[10],m=n+h+g;if(m>0){const v=.5/Math.sqrt(m+1);this._w=.25/v,this._x=(f-u)*v,this._y=(s-d)*v,this._z=(a-i)*v}else if(n>h&&n>g){const v=2*Math.sqrt(1+n-h-g);this._w=(f-u)/v,this._x=.25*v,this._y=(i+a)/v,this._z=(s+d)/v}else if(h>g){const v=2*Math.sqrt(1+h-n-g);this._w=(s-d)/v,this._x=(i+a)/v,this._y=.25*v,this._z=(u+f)/v}else{const v=2*Math.sqrt(1+g-n-h);this._w=(a-i)/v,this._x=(s+d)/v,this._y=(u+f)/v,this._z=.25*v}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(De(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,s=t._z,a=t._w,h=e._x,u=e._y,d=e._z,f=e._w;return this._x=n*f+a*h+i*d-s*u,this._y=i*f+a*u+s*h-n*d,this._z=s*f+a*d+n*u-i*h,this._w=a*f-n*h-i*u-s*d,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,i=this._y,s=this._z,a=this._w;let h=a*t._w+n*t._x+i*t._y+s*t._z;if(h<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,h=-h):this.copy(t),h>=1)return this._w=a,this._x=n,this._y=i,this._z=s,this;const u=1-h*h;if(u<=Number.EPSILON){const v=1-e;return this._w=v*a+e*this._w,this._x=v*n+e*this._x,this._y=v*i+e*this._y,this._z=v*s+e*this._z,this.normalize(),this._onChangeCallback(),this}const d=Math.sqrt(u),f=Math.atan2(d,h),g=Math.sin((1-e)*f)/d,m=Math.sin(e*f)/d;return this._w=a*g+this._w*m,this._x=n*g+this._x*m,this._y=i*g+this._y*m,this._z=s*g+this._z*m,this._onChangeCallback(),this}slerpQuaternions(t,e,n){this.copy(t).slerp(e,n)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}we.prototype.isQuaternion=!0;class T{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Hc.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Hc.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,s=t.elements;return this.x=s[0]*e+s[3]*n+s[6]*i,this.y=s[1]*e+s[4]*n+s[7]*i,this.z=s[2]*e+s[5]*n+s[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,s=t.elements,a=1/(s[3]*e+s[7]*n+s[11]*i+s[15]);return this.x=(s[0]*e+s[4]*n+s[8]*i+s[12])*a,this.y=(s[1]*e+s[5]*n+s[9]*i+s[13])*a,this.z=(s[2]*e+s[6]*n+s[10]*i+s[14])*a,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,s=t.x,a=t.y,h=t.z,u=t.w,d=u*e+a*i-h*n,f=u*n+h*e-s*i,g=u*i+s*n-a*e,m=-s*e-a*n-h*i;return this.x=d*u+m*-s+f*-h-g*-a,this.y=f*u+m*-a+g*-s-d*-h,this.z=g*u+m*-h+d*-a-f*-s,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i,this.y=s[1]*e+s[5]*n+s[9]*i,this.z=s[2]*e+s[6]*n+s[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,s=t.z,a=e.x,h=e.y,u=e.z;return this.x=i*u-s*h,this.y=s*a-n*u,this.z=n*h-i*a,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return ca.copy(this).projectOnVector(t),this.sub(ca)}reflect(t){return this.sub(ca.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(De(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}T.prototype.isVector3=!0;const ca=new T,Hc=new we;class un{constructor(t=new T(1/0,1/0,1/0),e=new T(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,i=1/0,s=-1/0,a=-1/0,h=-1/0;for(let u=0,d=t.length;u<d;u+=3){const f=t[u],g=t[u+1],m=t[u+2];f<e&&(e=f),g<n&&(n=g),m<i&&(i=m),f>s&&(s=f),g>a&&(a=g),m>h&&(h=m)}return this.min.set(e,n,i),this.max.set(s,a,h),this}setFromBufferAttribute(t){let e=1/0,n=1/0,i=1/0,s=-1/0,a=-1/0,h=-1/0;for(let u=0,d=t.count;u<d;u++){const f=t.getX(u),g=t.getY(u),m=t.getZ(u);f<e&&(e=f),g<n&&(n=g),m<i&&(i=m),f>s&&(s=f),g>a&&(a=g),m>h&&(h=m)}return this.min.set(e,n,i),this.max.set(s,a,h),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=Fr.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;e!==void 0&&(e.boundingBox===null&&e.computeBoundingBox(),ha.copy(e.boundingBox),ha.applyMatrix4(t.matrixWorld),this.union(ha));const n=t.children;for(let i=0,s=n.length;i<s;i++)this.expandByObject(n[i]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,Fr),Fr.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(kr),Ms.subVectors(this.max,kr),Ni.subVectors(t.a,kr),Fi.subVectors(t.b,kr),ki.subVectors(t.c,kr),Vn.subVectors(Fi,Ni),On.subVectors(ki,Fi),ui.subVectors(Ni,ki);let e=[0,-Vn.z,Vn.y,0,-On.z,On.y,0,-ui.z,ui.y,Vn.z,0,-Vn.x,On.z,0,-On.x,ui.z,0,-ui.x,-Vn.y,Vn.x,0,-On.y,On.x,0,-ui.y,ui.x,0];return!ua(e,Ni,Fi,ki,Ms)||(e=[1,0,0,0,1,0,0,0,1],!ua(e,Ni,Fi,ki,Ms))?!1:(Ss.crossVectors(Vn,On),e=[Ss.x,Ss.y,Ss.z],ua(e,Ni,Fi,ki,Ms))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return Fr.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=this.getSize(Fr).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(Cn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Cn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Cn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Cn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Cn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Cn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Cn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Cn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Cn),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}un.prototype.isBox3=!0;const Cn=[new T,new T,new T,new T,new T,new T,new T,new T],Fr=new T,ha=new un,Ni=new T,Fi=new T,ki=new T,Vn=new T,On=new T,ui=new T,kr=new T,Ms=new T,Ss=new T,di=new T;function ua(o,t,e,n,i){for(let s=0,a=o.length-3;s<=a;s+=3){di.fromArray(o,s);const h=i.x*Math.abs(di.x)+i.y*Math.abs(di.y)+i.z*Math.abs(di.z),u=t.dot(di),d=e.dot(di),f=n.dot(di);if(Math.max(-Math.max(u,d,f),Math.min(u,d,f))>h)return!1}return!0}const zg=new un,Gc=new T,da=new T,pa=new T;class gr{constructor(t=new T,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):zg.setFromPoints(t).getCenter(n);let i=0;for(let s=0,a=t.length;s<a;s++)i=Math.max(i,n.distanceToSquared(t[s]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){pa.subVectors(t,this.center);const e=pa.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),i=(n-this.radius)*.5;this.center.add(pa.multiplyScalar(i/n)),this.radius+=i}return this}union(t){return da.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(Gc.copy(t.center).add(da)),this.expandByPoint(Gc.copy(t.center).sub(da)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const An=new T,fa=new T,Es=new T,zn=new T,ma=new T,Ts=new T,ga=new T;class _i{constructor(t=new T,e=new T(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,An)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=An.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(An.copy(this.direction).multiplyScalar(e).add(this.origin),An.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){fa.copy(t).add(e).multiplyScalar(.5),Es.copy(e).sub(t).normalize(),zn.copy(this.origin).sub(fa);const s=t.distanceTo(e)*.5,a=-this.direction.dot(Es),h=zn.dot(this.direction),u=-zn.dot(Es),d=zn.lengthSq(),f=Math.abs(1-a*a);let g,m,v,b;if(f>0)if(g=a*u-h,m=a*h-u,b=s*f,g>=0)if(m>=-b)if(m<=b){const y=1/f;g*=y,m*=y,v=g*(g+a*m+2*h)+m*(a*g+m+2*u)+d}else m=s,g=Math.max(0,-(a*m+h)),v=-g*g+m*(m+2*u)+d;else m=-s,g=Math.max(0,-(a*m+h)),v=-g*g+m*(m+2*u)+d;else m<=-b?(g=Math.max(0,-(-a*s+h)),m=g>0?-s:Math.min(Math.max(-s,-u),s),v=-g*g+m*(m+2*u)+d):m<=b?(g=0,m=Math.min(Math.max(-s,-u),s),v=m*(m+2*u)+d):(g=Math.max(0,-(a*s+h)),m=g>0?s:Math.min(Math.max(-s,-u),s),v=-g*g+m*(m+2*u)+d);else m=a>0?-s:s,g=Math.max(0,-(a*m+h)),v=-g*g+m*(m+2*u)+d;return n&&n.copy(this.direction).multiplyScalar(g).add(this.origin),i&&i.copy(Es).multiplyScalar(m).add(fa),v}intersectSphere(t,e){An.subVectors(t.center,this.origin);const n=An.dot(this.direction),i=An.dot(An)-n*n,s=t.radius*t.radius;if(i>s)return null;const a=Math.sqrt(s-i),h=n-a,u=n+a;return h<0&&u<0?null:h<0?this.at(u,e):this.at(h,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,s,a,h,u;const d=1/this.direction.x,f=1/this.direction.y,g=1/this.direction.z,m=this.origin;return d>=0?(n=(t.min.x-m.x)*d,i=(t.max.x-m.x)*d):(n=(t.max.x-m.x)*d,i=(t.min.x-m.x)*d),f>=0?(s=(t.min.y-m.y)*f,a=(t.max.y-m.y)*f):(s=(t.max.y-m.y)*f,a=(t.min.y-m.y)*f),n>a||s>i||((s>n||n!==n)&&(n=s),(a<i||i!==i)&&(i=a),g>=0?(h=(t.min.z-m.z)*g,u=(t.max.z-m.z)*g):(h=(t.max.z-m.z)*g,u=(t.min.z-m.z)*g),n>u||h>i)||((h>n||n!==n)&&(n=h),(u<i||i!==i)&&(i=u),i<0)?null:this.at(n>=0?n:i,e)}intersectsBox(t){return this.intersectBox(t,An)!==null}intersectTriangle(t,e,n,i,s){ma.subVectors(e,t),Ts.subVectors(n,t),ga.crossVectors(ma,Ts);let a=this.direction.dot(ga),h;if(a>0){if(i)return null;h=1}else if(a<0)h=-1,a=-a;else return null;zn.subVectors(this.origin,t);const u=h*this.direction.dot(Ts.crossVectors(zn,Ts));if(u<0)return null;const d=h*this.direction.dot(ma.cross(zn));if(d<0||u+d>a)return null;const f=-h*zn.dot(ga);return f<0?null:this.at(f/a,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class It{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,s,a,h,u,d,f,g,m,v,b,y,M){const x=this.elements;return x[0]=t,x[4]=e,x[8]=n,x[12]=i,x[1]=s,x[5]=a,x[9]=h,x[13]=u,x[2]=d,x[6]=f,x[10]=g,x[14]=m,x[3]=v,x[7]=b,x[11]=y,x[15]=M,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new It().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/Bi.setFromMatrixColumn(t,0).length(),s=1/Bi.setFromMatrixColumn(t,1).length(),a=1/Bi.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*s,e[5]=n[5]*s,e[6]=n[6]*s,e[7]=0,e[8]=n[8]*a,e[9]=n[9]*a,e[10]=n[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,i=t.y,s=t.z,a=Math.cos(n),h=Math.sin(n),u=Math.cos(i),d=Math.sin(i),f=Math.cos(s),g=Math.sin(s);if(t.order==="XYZ"){const m=a*f,v=a*g,b=h*f,y=h*g;e[0]=u*f,e[4]=-u*g,e[8]=d,e[1]=v+b*d,e[5]=m-y*d,e[9]=-h*u,e[2]=y-m*d,e[6]=b+v*d,e[10]=a*u}else if(t.order==="YXZ"){const m=u*f,v=u*g,b=d*f,y=d*g;e[0]=m+y*h,e[4]=b*h-v,e[8]=a*d,e[1]=a*g,e[5]=a*f,e[9]=-h,e[2]=v*h-b,e[6]=y+m*h,e[10]=a*u}else if(t.order==="ZXY"){const m=u*f,v=u*g,b=d*f,y=d*g;e[0]=m-y*h,e[4]=-a*g,e[8]=b+v*h,e[1]=v+b*h,e[5]=a*f,e[9]=y-m*h,e[2]=-a*d,e[6]=h,e[10]=a*u}else if(t.order==="ZYX"){const m=a*f,v=a*g,b=h*f,y=h*g;e[0]=u*f,e[4]=b*d-v,e[8]=m*d+y,e[1]=u*g,e[5]=y*d+m,e[9]=v*d-b,e[2]=-d,e[6]=h*u,e[10]=a*u}else if(t.order==="YZX"){const m=a*u,v=a*d,b=h*u,y=h*d;e[0]=u*f,e[4]=y-m*g,e[8]=b*g+v,e[1]=g,e[5]=a*f,e[9]=-h*f,e[2]=-d*f,e[6]=v*g+b,e[10]=m-y*g}else if(t.order==="XZY"){const m=a*u,v=a*d,b=h*u,y=h*d;e[0]=u*f,e[4]=-g,e[8]=d*f,e[1]=m*g+y,e[5]=a*f,e[9]=v*g-b,e[2]=b*g-v,e[6]=h*f,e[10]=y*g+m}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Ug,t,Hg)}lookAt(t,e,n){const i=this.elements;return qe.subVectors(t,e),qe.lengthSq()===0&&(qe.z=1),qe.normalize(),Un.crossVectors(n,qe),Un.lengthSq()===0&&(Math.abs(n.z)===1?qe.x+=1e-4:qe.z+=1e-4,qe.normalize(),Un.crossVectors(n,qe)),Un.normalize(),Cs.crossVectors(qe,Un),i[0]=Un.x,i[4]=Cs.x,i[8]=qe.x,i[1]=Un.y,i[5]=Cs.y,i[9]=qe.y,i[2]=Un.z,i[6]=Cs.z,i[10]=qe.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,s=this.elements,a=n[0],h=n[4],u=n[8],d=n[12],f=n[1],g=n[5],m=n[9],v=n[13],b=n[2],y=n[6],M=n[10],x=n[14],_=n[3],R=n[7],L=n[11],A=n[15],N=i[0],C=i[4],z=i[8],tt=i[12],W=i[1],F=i[5],rt=i[9],H=i[13],G=i[2],j=i[6],B=i[10],K=i[14],at=i[3],yt=i[7],bt=i[11],mt=i[15];return s[0]=a*N+h*W+u*G+d*at,s[4]=a*C+h*F+u*j+d*yt,s[8]=a*z+h*rt+u*B+d*bt,s[12]=a*tt+h*H+u*K+d*mt,s[1]=f*N+g*W+m*G+v*at,s[5]=f*C+g*F+m*j+v*yt,s[9]=f*z+g*rt+m*B+v*bt,s[13]=f*tt+g*H+m*K+v*mt,s[2]=b*N+y*W+M*G+x*at,s[6]=b*C+y*F+M*j+x*yt,s[10]=b*z+y*rt+M*B+x*bt,s[14]=b*tt+y*H+M*K+x*mt,s[3]=_*N+R*W+L*G+A*at,s[7]=_*C+R*F+L*j+A*yt,s[11]=_*z+R*rt+L*B+A*bt,s[15]=_*tt+R*H+L*K+A*mt,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],s=t[12],a=t[1],h=t[5],u=t[9],d=t[13],f=t[2],g=t[6],m=t[10],v=t[14],b=t[3],y=t[7],M=t[11],x=t[15];return b*(+s*u*g-i*d*g-s*h*m+n*d*m+i*h*v-n*u*v)+y*(+e*u*v-e*d*m+s*a*m-i*a*v+i*d*f-s*u*f)+M*(+e*d*g-e*h*v-s*a*g+n*a*v+s*h*f-n*d*f)+x*(-i*h*f-e*u*g+e*h*m+i*a*g-n*a*m+n*u*f)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],a=t[4],h=t[5],u=t[6],d=t[7],f=t[8],g=t[9],m=t[10],v=t[11],b=t[12],y=t[13],M=t[14],x=t[15],_=g*M*d-y*m*d+y*u*v-h*M*v-g*u*x+h*m*x,R=b*m*d-f*M*d-b*u*v+a*M*v+f*u*x-a*m*x,L=f*y*d-b*g*d+b*h*v-a*y*v-f*h*x+a*g*x,A=b*g*u-f*y*u-b*h*m+a*y*m+f*h*M-a*g*M,N=e*_+n*R+i*L+s*A;if(N===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const C=1/N;return t[0]=_*C,t[1]=(y*m*s-g*M*s-y*i*v+n*M*v+g*i*x-n*m*x)*C,t[2]=(h*M*s-y*u*s+y*i*d-n*M*d-h*i*x+n*u*x)*C,t[3]=(g*u*s-h*m*s-g*i*d+n*m*d+h*i*v-n*u*v)*C,t[4]=R*C,t[5]=(f*M*s-b*m*s+b*i*v-e*M*v-f*i*x+e*m*x)*C,t[6]=(b*u*s-a*M*s-b*i*d+e*M*d+a*i*x-e*u*x)*C,t[7]=(a*m*s-f*u*s+f*i*d-e*m*d-a*i*v+e*u*v)*C,t[8]=L*C,t[9]=(b*g*s-f*y*s-b*n*v+e*y*v+f*n*x-e*g*x)*C,t[10]=(a*y*s-b*h*s+b*n*d-e*y*d-a*n*x+e*h*x)*C,t[11]=(f*h*s-a*g*s-f*n*d+e*g*d+a*n*v-e*h*v)*C,t[12]=A*C,t[13]=(f*y*i-b*g*i+b*n*m-e*y*m-f*n*M+e*g*M)*C,t[14]=(b*h*i-a*y*i-b*n*u+e*y*u+a*n*M-e*h*M)*C,t[15]=(a*g*i-f*h*i+f*n*u-e*g*u-a*n*m+e*h*m)*C,this}scale(t){const e=this.elements,n=t.x,i=t.y,s=t.z;return e[0]*=n,e[4]*=i,e[8]*=s,e[1]*=n,e[5]*=i,e[9]*=s,e[2]*=n,e[6]*=i,e[10]*=s,e[3]*=n,e[7]*=i,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),s=1-n,a=t.x,h=t.y,u=t.z,d=s*a,f=s*h;return this.set(d*a+n,d*h-i*u,d*u+i*h,0,d*h+i*u,f*h+n,f*u-i*a,0,d*u-i*h,f*u+i*a,s*u*u+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,s,a){return this.set(1,n,s,0,t,1,a,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,s=e._x,a=e._y,h=e._z,u=e._w,d=s+s,f=a+a,g=h+h,m=s*d,v=s*f,b=s*g,y=a*f,M=a*g,x=h*g,_=u*d,R=u*f,L=u*g,A=n.x,N=n.y,C=n.z;return i[0]=(1-(y+x))*A,i[1]=(v+L)*A,i[2]=(b-R)*A,i[3]=0,i[4]=(v-L)*N,i[5]=(1-(m+x))*N,i[6]=(M+_)*N,i[7]=0,i[8]=(b+R)*C,i[9]=(M-_)*C,i[10]=(1-(m+y))*C,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let s=Bi.set(i[0],i[1],i[2]).length();const a=Bi.set(i[4],i[5],i[6]).length(),h=Bi.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),t.x=i[12],t.y=i[13],t.z=i[14],on.copy(this);const d=1/s,f=1/a,g=1/h;return on.elements[0]*=d,on.elements[1]*=d,on.elements[2]*=d,on.elements[4]*=f,on.elements[5]*=f,on.elements[6]*=f,on.elements[8]*=g,on.elements[9]*=g,on.elements[10]*=g,e.setFromRotationMatrix(on),n.x=s,n.y=a,n.z=h,this}makePerspective(t,e,n,i,s,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const h=this.elements,u=2*s/(e-t),d=2*s/(n-i),f=(e+t)/(e-t),g=(n+i)/(n-i),m=-(a+s)/(a-s),v=-2*a*s/(a-s);return h[0]=u,h[4]=0,h[8]=f,h[12]=0,h[1]=0,h[5]=d,h[9]=g,h[13]=0,h[2]=0,h[6]=0,h[10]=m,h[14]=v,h[3]=0,h[7]=0,h[11]=-1,h[15]=0,this}makeOrthographic(t,e,n,i,s,a){const h=this.elements,u=1/(e-t),d=1/(n-i),f=1/(a-s),g=(e+t)*u,m=(n+i)*d,v=(a+s)*f;return h[0]=2*u,h[4]=0,h[8]=0,h[12]=-g,h[1]=0,h[5]=2*d,h[9]=0,h[13]=-m,h[2]=0,h[6]=0,h[10]=-2*f,h[14]=-v,h[3]=0,h[7]=0,h[11]=0,h[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<16;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}It.prototype.isMatrix4=!0;const Bi=new T,on=new It,Ug=new T(0,0,0),Hg=new T(1,1,1),Un=new T,Cs=new T,qe=new T,Wc=new It,qc=new we;class vr{constructor(t=0,e=0,n=0,i=vr.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const i=t.elements,s=i[0],a=i[4],h=i[8],u=i[1],d=i[5],f=i[9],g=i[2],m=i[6],v=i[10];switch(e){case"XYZ":this._y=Math.asin(De(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(-f,v),this._z=Math.atan2(-a,s)):(this._x=Math.atan2(m,d),this._z=0);break;case"YXZ":this._x=Math.asin(-De(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(h,v),this._z=Math.atan2(u,d)):(this._y=Math.atan2(-g,s),this._z=0);break;case"ZXY":this._x=Math.asin(De(m,-1,1)),Math.abs(m)<.9999999?(this._y=Math.atan2(-g,v),this._z=Math.atan2(-a,d)):(this._y=0,this._z=Math.atan2(u,s));break;case"ZYX":this._y=Math.asin(-De(g,-1,1)),Math.abs(g)<.9999999?(this._x=Math.atan2(m,v),this._z=Math.atan2(u,s)):(this._x=0,this._z=Math.atan2(-a,d));break;case"YZX":this._z=Math.asin(De(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(-f,d),this._y=Math.atan2(-g,s)):(this._x=0,this._y=Math.atan2(h,v));break;case"XZY":this._z=Math.asin(-De(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(m,d),this._y=Math.atan2(h,s)):(this._x=Math.atan2(-f,v),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return Wc.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Wc,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return qc.setFromEuler(this),this.setFromQuaternion(qc,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new T(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}vr.prototype.isEuler=!0;vr.DefaultOrder="XYZ";vr.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class fu{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}}let Gg=0;const jc=new T,Vi=new we,Pn=new It,As=new T,Br=new T,Wg=new T,qg=new we,Xc=new T(1,0,0),Yc=new T(0,1,0),Zc=new T(0,0,1),jg={type:"added"},Kc={type:"removed"};class Zt extends ti{constructor(){super(),Object.defineProperty(this,"id",{value:Gg++}),this.uuid=bn(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Zt.DefaultUp.clone();const t=new T,e=new vr,n=new we,i=new T(1,1,1);function s(){n.setFromEuler(e,!1)}function a(){e.setFromQuaternion(n,void 0,!1)}e._onChange(s),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new It},normalMatrix:{value:new ye}}),this.matrix=new It,this.matrixWorld=new It,this.matrixAutoUpdate=Zt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new fu,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return Vi.setFromAxisAngle(t,e),this.quaternion.multiply(Vi),this}rotateOnWorldAxis(t,e){return Vi.setFromAxisAngle(t,e),this.quaternion.premultiply(Vi),this}rotateX(t){return this.rotateOnAxis(Xc,t)}rotateY(t){return this.rotateOnAxis(Yc,t)}rotateZ(t){return this.rotateOnAxis(Zc,t)}translateOnAxis(t,e){return jc.copy(t).applyQuaternion(this.quaternion),this.position.add(jc.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(Xc,t)}translateY(t){return this.translateOnAxis(Yc,t)}translateZ(t){return this.translateOnAxis(Zc,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(Pn.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?As.copy(t):As.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),Br.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Pn.lookAt(Br,As,this.up):Pn.lookAt(As,Br,this.up),this.quaternion.setFromRotationMatrix(Pn),i&&(Pn.extractRotation(i.matrixWorld),Vi.setFromRotationMatrix(Pn),this.quaternion.premultiply(Vi.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(jg)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Kc)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(Kc)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),Pn.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),Pn.multiply(t.parent.matrixWorld)),t.applyMatrix4(Pn),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const a=this.children[n].getObjectByProperty(t,e);if(a!==void 0)return a}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Br,t,Wg),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Br,qg,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(t===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const i=this.children;for(let s=0,a=i.length;s<a;s++)i[s].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON()));function s(h,u){return h[u.uuid]===void 0&&(h[u.uuid]=u.toJSON(t)),u.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=s(t.geometries,this.geometry);const h=this.geometry.parameters;if(h!==void 0&&h.shapes!==void 0){const u=h.shapes;if(Array.isArray(u))for(let d=0,f=u.length;d<f;d++){const g=u[d];s(t.shapes,g)}else s(t.shapes,u)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const h=[];for(let u=0,d=this.material.length;u<d;u++)h.push(s(t.materials,this.material[u]));i.material=h}else i.material=s(t.materials,this.material);if(this.children.length>0){i.children=[];for(let h=0;h<this.children.length;h++)i.children.push(this.children[h].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let h=0;h<this.animations.length;h++){const u=this.animations[h];i.animations.push(s(t.animations,u))}}if(e){const h=a(t.geometries),u=a(t.materials),d=a(t.textures),f=a(t.images),g=a(t.shapes),m=a(t.skeletons),v=a(t.animations);h.length>0&&(n.geometries=h),u.length>0&&(n.materials=u),d.length>0&&(n.textures=d),f.length>0&&(n.images=f),g.length>0&&(n.shapes=g),m.length>0&&(n.skeletons=m),v.length>0&&(n.animations=v)}return n.object=i,n;function a(h){const u=[];for(const d in h){const f=h[d];delete f.metadata,u.push(f)}return u}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let n=0;n<t.children.length;n++){const i=t.children[n];this.add(i.clone())}return this}}Zt.DefaultUp=new T(0,1,0);Zt.DefaultMatrixAutoUpdate=!0;Zt.prototype.isObject3D=!0;const an=new T,Ln=new T,va=new T,Rn=new T,Oi=new T,zi=new T,Jc=new T,_a=new T,xa=new T,ba=new T;class de{constructor(t=new T,e=new T,n=new T){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i.subVectors(n,e),an.subVectors(t,e),i.cross(an);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(t,e,n,i,s){an.subVectors(i,e),Ln.subVectors(n,e),va.subVectors(t,e);const a=an.dot(an),h=an.dot(Ln),u=an.dot(va),d=Ln.dot(Ln),f=Ln.dot(va),g=a*d-h*h;if(g===0)return s.set(-2,-1,-1);const m=1/g,v=(d*u-h*f)*m,b=(a*f-h*u)*m;return s.set(1-v-b,b,v)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,Rn),Rn.x>=0&&Rn.y>=0&&Rn.x+Rn.y<=1}static getUV(t,e,n,i,s,a,h,u){return this.getBarycoord(t,e,n,i,Rn),u.set(0,0),u.addScaledVector(s,Rn.x),u.addScaledVector(a,Rn.y),u.addScaledVector(h,Rn.z),u}static isFrontFacing(t,e,n,i){return an.subVectors(n,e),Ln.subVectors(t,e),an.cross(Ln).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return an.subVectors(this.c,this.b),Ln.subVectors(this.a,this.b),an.cross(Ln).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return de.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return de.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,i,s){return de.getUV(t,this.a,this.b,this.c,e,n,i,s)}containsPoint(t){return de.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return de.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,i=this.b,s=this.c;let a,h;Oi.subVectors(i,n),zi.subVectors(s,n),_a.subVectors(t,n);const u=Oi.dot(_a),d=zi.dot(_a);if(u<=0&&d<=0)return e.copy(n);xa.subVectors(t,i);const f=Oi.dot(xa),g=zi.dot(xa);if(f>=0&&g<=f)return e.copy(i);const m=u*g-f*d;if(m<=0&&u>=0&&f<=0)return a=u/(u-f),e.copy(n).addScaledVector(Oi,a);ba.subVectors(t,s);const v=Oi.dot(ba),b=zi.dot(ba);if(b>=0&&v<=b)return e.copy(s);const y=v*d-u*b;if(y<=0&&d>=0&&b<=0)return h=d/(d-b),e.copy(n).addScaledVector(zi,h);const M=f*b-v*g;if(M<=0&&g-f>=0&&v-b>=0)return Jc.subVectors(s,i),h=(g-f)/(g-f+(v-b)),e.copy(i).addScaledVector(Jc,h);const x=1/(M+y+m);return a=y*x,h=m*x,e.copy(n).addScaledVector(Oi,a).addScaledVector(zi,h)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let Xg=0;class Pe extends ti{constructor(){super(),Object.defineProperty(this,"id",{value:Xg++}),this.uuid=bn(),this.name="",this.type="Material",this.fog=!0,this.blending=Zr,this.side=Qr,this.vertexColors=!1,this.opacity=1,this.format=Ye,this.transparent=!1,this.blendSrc=ou,this.blendDst=au,this.blendEquation=Qi,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Ja,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Fg,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=sa,this.stencilZFail=sa,this.stencilZPass=sa,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const n=t[e];if(n===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===su;continue}const i=this[e];if(i===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheenTint&&this.sheenTint.isColor&&(n.sheenTint=this.sheenTint.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularTint&&this.specularTint.isColor&&(n.specularTint=this.specularTint.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularTintMap&&this.specularTintMap.isTexture&&(n.specularTintMap=this.specularTintMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationTint!==void 0&&(n.attenuationTint=this.attenuationTint.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Zr&&(n.blending=this.blending),this.side!==Qr&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.format!==Ye&&(n.format=this.format),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function i(s){const a=[];for(const h in s){const u=s[h];delete u.metadata,a.push(u)}return a}if(e){const s=i(t.textures),a=i(t.images);s.length>0&&(n.textures=s),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.format=t.format,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(e!==null){const i=e.length;n=new Array(i);for(let s=0;s!==i;++s)n[s]=e[s].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}Pe.prototype.isMaterial=!0;const mu={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},ln={h:0,s:0,l:0},Ps={h:0,s:0,l:0};function ya(o,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?o+(t-o)*6*e:e<1/2?t:e<2/3?o+(t-o)*6*(2/3-e):o}function wa(o){return o<.04045?o*.0773993808:Math.pow(o*.9478672986+.0521327014,2.4)}function Ma(o){return o<.0031308?o*12.92:1.055*Math.pow(o,.41666)-.055}class wt{constructor(t,e,n){return e===void 0&&n===void 0?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){if(t=kg(t,1),e=De(e,0,1),n=De(n,0,1),e===0)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,s=2*n-i;this.r=ya(s,i,t+1/3),this.g=ya(s,i,t),this.b=ya(s,i,t-1/3)}return this}setStyle(t){function e(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let i;const s=n[1],a=n[2];switch(s){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(i[1],10))/255,this.g=Math.min(255,parseInt(i[2],10))/255,this.b=Math.min(255,parseInt(i[3],10))/255,e(i[4]),this;if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(i[1],10))/100,this.g=Math.min(100,parseInt(i[2],10))/100,this.b=Math.min(100,parseInt(i[3],10))/100,e(i[4]),this;break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const h=parseFloat(i[1])/360,u=parseInt(i[2],10)/100,d=parseInt(i[3],10)/100;return e(i[4]),this.setHSL(h,u,d)}break}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const i=n[1],s=i.length;if(s===3)return this.r=parseInt(i.charAt(0)+i.charAt(0),16)/255,this.g=parseInt(i.charAt(1)+i.charAt(1),16)/255,this.b=parseInt(i.charAt(2)+i.charAt(2),16)/255,this;if(s===6)return this.r=parseInt(i.charAt(0)+i.charAt(1),16)/255,this.g=parseInt(i.charAt(2)+i.charAt(3),16)/255,this.b=parseInt(i.charAt(4)+i.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=mu[t.toLowerCase()];return e!==void 0?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const n=e>0?1/e:1;return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=wa(t.r),this.g=wa(t.g),this.b=wa(t.b),this}copyLinearToSRGB(t){return this.r=Ma(t.r),this.g=Ma(t.g),this.b=Ma(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){const e=this.r,n=this.g,i=this.b,s=Math.max(e,n,i),a=Math.min(e,n,i);let h,u;const d=(a+s)/2;if(a===s)h=0,u=0;else{const f=s-a;switch(u=d<=.5?f/(s+a):f/(2-s-a),s){case e:h=(n-i)/f+(n<i?6:0);break;case n:h=(i-e)/f+2;break;case i:h=(e-n)/f+4;break}h/=6}return t.h=h,t.s=u,t.l=d,t}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(t,e,n){return this.getHSL(ln),ln.h+=t,ln.s+=e,ln.l+=n,this.setHSL(ln.h,ln.s,ln.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(ln),t.getHSL(Ps);const n=aa(ln.h,Ps.h,e),i=aa(ln.s,Ps.s,e),s=aa(ln.l,Ps.l,e);return this.setHSL(n,i,s),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}wt.NAMES=mu;wt.prototype.isColor=!0;wt.prototype.r=1;wt.prototype.g=1;wt.prototype.b=1;class xi extends Pe{constructor(t){super(),this.type="MeshBasicMaterial",this.color=new wt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=mo,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}xi.prototype.isMeshBasicMaterial=!0;const ne=new T,Ls=new it;class ge{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n===!0,this.usage=es,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let i=0,s=t.length;i<s;i++){let a=t[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),a=new wt),e[n++]=a.r,e[n++]=a.g,e[n++]=a.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let i=0,s=t.length;i<s;i++){let a=t[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),a=new it),e[n++]=a.x,e[n++]=a.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let i=0,s=t.length;i<s;i++){let a=t[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),a=new T),e[n++]=a.x,e[n++]=a.y,e[n++]=a.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let i=0,s=t.length;i<s;i++){let a=t[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),a=new te),e[n++]=a.x,e[n++]=a.y,e[n++]=a.z,e[n++]=a.w}return this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)Ls.fromBufferAttribute(this,e),Ls.applyMatrix3(t),this.setXY(e,Ls.x,Ls.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)ne.fromBufferAttribute(this,e),ne.applyMatrix3(t),this.setXYZ(e,ne.x,ne.y,ne.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)ne.x=this.getX(e),ne.y=this.getY(e),ne.z=this.getZ(e),ne.applyMatrix4(t),this.setXYZ(e,ne.x,ne.y,ne.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)ne.x=this.getX(e),ne.y=this.getY(e),ne.z=this.getZ(e),ne.applyNormalMatrix(t),this.setXYZ(e,ne.x,ne.y,ne.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)ne.x=this.getX(e),ne.y=this.getY(e),ne.z=this.getZ(e),ne.transformDirection(t),this.setXYZ(e,ne.x,ne.y,ne.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,s){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==es&&(t.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(t.updateRange=this.updateRange),t}}ge.prototype.isBufferAttribute=!0;class gu extends ge{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class vu extends ge{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Yg extends ge{constructor(t,e,n){super(new Uint16Array(t),e,n)}}Yg.prototype.isFloat16BufferAttribute=!0;class ee extends ge{constructor(t,e,n){super(new Float32Array(t),e,n)}}function _u(o){if(o.length===0)return-1/0;let t=o[0];for(let e=1,n=o.length;e<n;++e)o[e]>t&&(t=o[e]);return t}let Zg=0;const tn=new It,Sa=new Zt,Ui=new T,je=new un,Vr=new un,ve=new T;class $t extends ti{constructor(){super(),Object.defineProperty(this,"id",{value:Zg++}),this.uuid=bn(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(_u(t)>65535?vu:gu)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new ye().getNormalMatrix(t);n.applyNormalMatrix(s),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(t),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return tn.makeRotationFromQuaternion(t),this.applyMatrix4(tn),this}rotateX(t){return tn.makeRotationX(t),this.applyMatrix4(tn),this}rotateY(t){return tn.makeRotationY(t),this.applyMatrix4(tn),this}rotateZ(t){return tn.makeRotationZ(t),this.applyMatrix4(tn),this}translate(t,e,n){return tn.makeTranslation(t,e,n),this.applyMatrix4(tn),this}scale(t,e,n){return tn.makeScale(t,e,n),this.applyMatrix4(tn),this}lookAt(t){return Sa.lookAt(t),Sa.updateMatrix(),this.applyMatrix4(Sa.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ui).negate(),this.translate(Ui.x,Ui.y,Ui.z),this}setFromPoints(t){const e=[];for(let n=0,i=t.length;n<i;n++){const s=t[n];e.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new ee(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new un);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new T(-1/0,-1/0,-1/0),new T(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,i=e.length;n<i;n++){const s=e[n];je.setFromBufferAttribute(s),this.morphTargetsRelative?(ve.addVectors(this.boundingBox.min,je.min),this.boundingBox.expandByPoint(ve),ve.addVectors(this.boundingBox.max,je.max),this.boundingBox.expandByPoint(ve)):(this.boundingBox.expandByPoint(je.min),this.boundingBox.expandByPoint(je.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new gr);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new T,1/0);return}if(t){const n=this.boundingSphere.center;if(je.setFromBufferAttribute(t),e)for(let s=0,a=e.length;s<a;s++){const h=e[s];Vr.setFromBufferAttribute(h),this.morphTargetsRelative?(ve.addVectors(je.min,Vr.min),je.expandByPoint(ve),ve.addVectors(je.max,Vr.max),je.expandByPoint(ve)):(je.expandByPoint(Vr.min),je.expandByPoint(Vr.max))}je.getCenter(n);let i=0;for(let s=0,a=t.count;s<a;s++)ve.fromBufferAttribute(t,s),i=Math.max(i,n.distanceToSquared(ve));if(e)for(let s=0,a=e.length;s<a;s++){const h=e[s],u=this.morphTargetsRelative;for(let d=0,f=h.count;d<f;d++)ve.fromBufferAttribute(h,d),u&&(Ui.fromBufferAttribute(t,d),ve.add(Ui)),i=Math.max(i,n.distanceToSquared(ve))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=t.array,i=e.position.array,s=e.normal.array,a=e.uv.array,h=i.length/3;e.tangent===void 0&&this.setAttribute("tangent",new ge(new Float32Array(4*h),4));const u=e.tangent.array,d=[],f=[];for(let W=0;W<h;W++)d[W]=new T,f[W]=new T;const g=new T,m=new T,v=new T,b=new it,y=new it,M=new it,x=new T,_=new T;function R(W,F,rt){g.fromArray(i,W*3),m.fromArray(i,F*3),v.fromArray(i,rt*3),b.fromArray(a,W*2),y.fromArray(a,F*2),M.fromArray(a,rt*2),m.sub(g),v.sub(g),y.sub(b),M.sub(b);const H=1/(y.x*M.y-M.x*y.y);!isFinite(H)||(x.copy(m).multiplyScalar(M.y).addScaledVector(v,-y.y).multiplyScalar(H),_.copy(v).multiplyScalar(y.x).addScaledVector(m,-M.x).multiplyScalar(H),d[W].add(x),d[F].add(x),d[rt].add(x),f[W].add(_),f[F].add(_),f[rt].add(_))}let L=this.groups;L.length===0&&(L=[{start:0,count:n.length}]);for(let W=0,F=L.length;W<F;++W){const rt=L[W],H=rt.start,G=rt.count;for(let j=H,B=H+G;j<B;j+=3)R(n[j+0],n[j+1],n[j+2])}const A=new T,N=new T,C=new T,z=new T;function tt(W){C.fromArray(s,W*3),z.copy(C);const F=d[W];A.copy(F),A.sub(C.multiplyScalar(C.dot(F))).normalize(),N.crossVectors(z,F);const H=N.dot(f[W])<0?-1:1;u[W*4]=A.x,u[W*4+1]=A.y,u[W*4+2]=A.z,u[W*4+3]=H}for(let W=0,F=L.length;W<F;++W){const rt=L[W],H=rt.start,G=rt.count;for(let j=H,B=H+G;j<B;j+=3)tt(n[j+0]),tt(n[j+1]),tt(n[j+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new ge(new Float32Array(e.count*3),3),this.setAttribute("normal",n);else for(let m=0,v=n.count;m<v;m++)n.setXYZ(m,0,0,0);const i=new T,s=new T,a=new T,h=new T,u=new T,d=new T,f=new T,g=new T;if(t)for(let m=0,v=t.count;m<v;m+=3){const b=t.getX(m+0),y=t.getX(m+1),M=t.getX(m+2);i.fromBufferAttribute(e,b),s.fromBufferAttribute(e,y),a.fromBufferAttribute(e,M),f.subVectors(a,s),g.subVectors(i,s),f.cross(g),h.fromBufferAttribute(n,b),u.fromBufferAttribute(n,y),d.fromBufferAttribute(n,M),h.add(f),u.add(f),d.add(f),n.setXYZ(b,h.x,h.y,h.z),n.setXYZ(y,u.x,u.y,u.z),n.setXYZ(M,d.x,d.y,d.z)}else for(let m=0,v=e.count;m<v;m+=3)i.fromBufferAttribute(e,m+0),s.fromBufferAttribute(e,m+1),a.fromBufferAttribute(e,m+2),f.subVectors(a,s),g.subVectors(i,s),f.cross(g),n.setXYZ(m+0,f.x,f.y,f.z),n.setXYZ(m+1,f.x,f.y,f.z),n.setXYZ(m+2,f.x,f.y,f.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!(t&&t.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(t.attributes[i]===void 0)continue;const a=n[i].array,h=t.attributes[i],u=h.array,d=h.itemSize*e,f=Math.min(u.length,a.length-d);for(let g=0,m=d;g<f;g++,m++)a[m]=u[g]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)ve.fromBufferAttribute(t,e),ve.normalize(),t.setXYZ(e,ve.x,ve.y,ve.z)}toNonIndexed(){function t(h,u){const d=h.array,f=h.itemSize,g=h.normalized,m=new d.constructor(u.length*f);let v=0,b=0;for(let y=0,M=u.length;y<M;y++){h.isInterleavedBufferAttribute?v=u[y]*h.data.stride+h.offset:v=u[y]*f;for(let x=0;x<f;x++)m[b++]=d[v++]}return new ge(m,f,g)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new $t,n=this.index.array,i=this.attributes;for(const h in i){const u=i[h],d=t(u,n);e.setAttribute(h,d)}const s=this.morphAttributes;for(const h in s){const u=[],d=s[h];for(let f=0,g=d.length;f<g;f++){const m=d[f],v=t(m,n);u.push(v)}e.morphAttributes[h]=u}e.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let h=0,u=a.length;h<u;h++){const d=a[h];e.addGroup(d.start,d.count,d.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const u=this.parameters;for(const d in u)u[d]!==void 0&&(t[d]=u[d]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const u in n){const d=n[u];t.data.attributes[u]=d.toJSON(t.data)}const i={};let s=!1;for(const u in this.morphAttributes){const d=this.morphAttributes[u],f=[];for(let g=0,m=d.length;g<m;g++){const v=d[g];f.push(v.toJSON(t.data))}f.length>0&&(i[u]=f,s=!0)}s&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(t.data.groups=JSON.parse(JSON.stringify(a)));const h=this.boundingSphere;return h!==null&&(t.data.boundingSphere={center:h.center.toArray(),radius:h.radius}),t}clone(){return new $t().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;n!==null&&this.setIndex(n.clone(e));const i=t.attributes;for(const d in i){const f=i[d];this.setAttribute(d,f.clone(e))}const s=t.morphAttributes;for(const d in s){const f=[],g=s[d];for(let m=0,v=g.length;m<v;m++)f.push(g[m].clone(e));this.morphAttributes[d]=f}this.morphTargetsRelative=t.morphTargetsRelative;const a=t.groups;for(let d=0,f=a.length;d<f;d++){const g=a[d];this.addGroup(g.start,g.count,g.materialIndex)}const h=t.boundingBox;h!==null&&(this.boundingBox=h.clone());const u=t.boundingSphere;return u!==null&&(this.boundingSphere=u.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}$t.prototype.isBufferGeometry=!0;const $c=new It,Hi=new _i,Ea=new gr,Hn=new T,Gn=new T,Wn=new T,Ta=new T,Ca=new T,Aa=new T,Rs=new T,Ds=new T,Is=new T,Ns=new it,Fs=new it,ks=new it,Pa=new T,Bs=new T;class xe extends Zt{constructor(t=new $t,e=new xi){super(),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const h=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[h]=s}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const n=this.geometry,i=this.material,s=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),Ea.copy(n.boundingSphere),Ea.applyMatrix4(s),t.ray.intersectsSphere(Ea)===!1)||($c.copy(s).invert(),Hi.copy(t.ray).applyMatrix4($c),n.boundingBox!==null&&Hi.intersectsBox(n.boundingBox)===!1))return;let a;if(n.isBufferGeometry){const h=n.index,u=n.attributes.position,d=n.morphAttributes.position,f=n.morphTargetsRelative,g=n.attributes.uv,m=n.attributes.uv2,v=n.groups,b=n.drawRange;if(h!==null)if(Array.isArray(i))for(let y=0,M=v.length;y<M;y++){const x=v[y],_=i[x.materialIndex],R=Math.max(x.start,b.start),L=Math.min(x.start+x.count,b.start+b.count);for(let A=R,N=L;A<N;A+=3){const C=h.getX(A),z=h.getX(A+1),tt=h.getX(A+2);a=Vs(this,_,t,Hi,u,d,f,g,m,C,z,tt),a&&(a.faceIndex=Math.floor(A/3),a.face.materialIndex=x.materialIndex,e.push(a))}}else{const y=Math.max(0,b.start),M=Math.min(h.count,b.start+b.count);for(let x=y,_=M;x<_;x+=3){const R=h.getX(x),L=h.getX(x+1),A=h.getX(x+2);a=Vs(this,i,t,Hi,u,d,f,g,m,R,L,A),a&&(a.faceIndex=Math.floor(x/3),e.push(a))}}else if(u!==void 0)if(Array.isArray(i))for(let y=0,M=v.length;y<M;y++){const x=v[y],_=i[x.materialIndex],R=Math.max(x.start,b.start),L=Math.min(x.start+x.count,b.start+b.count);for(let A=R,N=L;A<N;A+=3){const C=A,z=A+1,tt=A+2;a=Vs(this,_,t,Hi,u,d,f,g,m,C,z,tt),a&&(a.faceIndex=Math.floor(A/3),a.face.materialIndex=x.materialIndex,e.push(a))}}else{const y=Math.max(0,b.start),M=Math.min(u.count,b.start+b.count);for(let x=y,_=M;x<_;x+=3){const R=x,L=x+1,A=x+2;a=Vs(this,i,t,Hi,u,d,f,g,m,R,L,A),a&&(a.faceIndex=Math.floor(x/3),e.push(a))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}xe.prototype.isMesh=!0;function Kg(o,t,e,n,i,s,a,h){let u;if(t.side===me?u=n.intersectTriangle(a,s,i,!0,h):u=n.intersectTriangle(i,s,a,t.side!==hr,h),u===null)return null;Bs.copy(h),Bs.applyMatrix4(o.matrixWorld);const d=e.ray.origin.distanceTo(Bs);return d<e.near||d>e.far?null:{distance:d,point:Bs.clone(),object:o}}function Vs(o,t,e,n,i,s,a,h,u,d,f,g){Hn.fromBufferAttribute(i,d),Gn.fromBufferAttribute(i,f),Wn.fromBufferAttribute(i,g);const m=o.morphTargetInfluences;if(s&&m){Rs.set(0,0,0),Ds.set(0,0,0),Is.set(0,0,0);for(let b=0,y=s.length;b<y;b++){const M=m[b],x=s[b];M!==0&&(Ta.fromBufferAttribute(x,d),Ca.fromBufferAttribute(x,f),Aa.fromBufferAttribute(x,g),a?(Rs.addScaledVector(Ta,M),Ds.addScaledVector(Ca,M),Is.addScaledVector(Aa,M)):(Rs.addScaledVector(Ta.sub(Hn),M),Ds.addScaledVector(Ca.sub(Gn),M),Is.addScaledVector(Aa.sub(Wn),M)))}Hn.add(Rs),Gn.add(Ds),Wn.add(Is)}o.isSkinnedMesh&&(o.boneTransform(d,Hn),o.boneTransform(f,Gn),o.boneTransform(g,Wn));const v=Kg(o,t,e,n,Hn,Gn,Wn,Pa);if(v){h&&(Ns.fromBufferAttribute(h,d),Fs.fromBufferAttribute(h,f),ks.fromBufferAttribute(h,g),v.uv=de.getUV(Pa,Hn,Gn,Wn,Ns,Fs,ks,new it)),u&&(Ns.fromBufferAttribute(u,d),Fs.fromBufferAttribute(u,f),ks.fromBufferAttribute(u,g),v.uv2=de.getUV(Pa,Hn,Gn,Wn,Ns,Fs,ks,new it));const b={a:d,b:f,c:g,normal:new T,materialIndex:0};de.getNormal(Hn,Gn,Wn,b.normal),v.face=b}return v}class os extends $t{constructor(t=1,e=1,n=1,i=1,s=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:s,depthSegments:a};const h=this;i=Math.floor(i),s=Math.floor(s),a=Math.floor(a);const u=[],d=[],f=[],g=[];let m=0,v=0;b("z","y","x",-1,-1,n,e,t,a,s,0),b("z","y","x",1,-1,n,e,-t,a,s,1),b("x","z","y",1,1,t,n,e,i,a,2),b("x","z","y",1,-1,t,n,-e,i,a,3),b("x","y","z",1,-1,t,e,n,i,s,4),b("x","y","z",-1,-1,t,e,-n,i,s,5),this.setIndex(u),this.setAttribute("position",new ee(d,3)),this.setAttribute("normal",new ee(f,3)),this.setAttribute("uv",new ee(g,2));function b(y,M,x,_,R,L,A,N,C,z,tt){const W=L/C,F=A/z,rt=L/2,H=A/2,G=N/2,j=C+1,B=z+1;let K=0,at=0;const yt=new T;for(let bt=0;bt<B;bt++){const mt=bt*F-H;for(let vt=0;vt<j;vt++){const J=vt*W-rt;yt[y]=J*_,yt[M]=mt*R,yt[x]=G,d.push(yt.x,yt.y,yt.z),yt[y]=0,yt[M]=0,yt[x]=N>0?1:-1,f.push(yt.x,yt.y,yt.z),g.push(vt/C),g.push(1-bt/z),K+=1}}for(let bt=0;bt<z;bt++)for(let mt=0;mt<C;mt++){const vt=m+mt+j*bt,J=m+mt+j*(bt+1),st=m+(mt+1)+j*(bt+1),Mt=m+(mt+1)+j*bt;u.push(vt,J,Mt),u.push(J,st,Mt),at+=6}h.addGroup(v,at,tt),v+=at,m+=K}}static fromJSON(t){return new os(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function dr(o){const t={};for(const e in o){t[e]={};for(const n in o[e]){const i=o[e][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?t[e][n]=i.clone():Array.isArray(i)?t[e][n]=i.slice():t[e][n]=i}}return t}function Te(o){const t={};for(let e=0;e<o.length;e++){const n=dr(o[e]);for(const i in n)t[i]=n[i]}return t}const Jg={clone:dr,merge:Te};var $g=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,Qg=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class vi extends Pe{constructor(t){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=$g,this.fragmentShader=Qg,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&(t.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=dr(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?e.uniforms[i]={type:"t",value:a.toJSON(t).uuid}:a&&a.isColor?e.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?e.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?e.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?e.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?e.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?e.uniforms[i]={type:"m4",value:a.toArray()}:e.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}vi.prototype.isShaderMaterial=!0;class gl extends Zt{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new It,this.projectionMatrix=new It,this.projectionMatrixInverse=new It}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}gl.prototype.isCamera=!0;class Ie extends gl{constructor(t=50,e=1,n=.1,i=2e3){super(),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=nl*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(oa*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return nl*2*Math.atan(Math.tan(oa*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,i,s,a){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(oa*.5*this.fov)/this.zoom,n=2*e,i=this.aspect*n,s=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const u=a.fullWidth,d=a.fullHeight;s+=a.offsetX*i/u,e-=a.offsetY*n/d,i*=a.width/u,n*=a.height/d}const h=this.filmOffset;h!==0&&(s+=t*h/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+i,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}Ie.prototype.isPerspectiveCamera=!0;const Gi=90,Wi=1;class vl extends Zt{constructor(t,e,n){if(super(),this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const i=new Ie(Gi,Wi,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new T(1,0,0)),this.add(i);const s=new Ie(Gi,Wi,t,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new T(-1,0,0)),this.add(s);const a=new Ie(Gi,Wi,t,e);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new T(0,1,0)),this.add(a);const h=new Ie(Gi,Wi,t,e);h.layers=this.layers,h.up.set(0,0,-1),h.lookAt(new T(0,-1,0)),this.add(h);const u=new Ie(Gi,Wi,t,e);u.layers=this.layers,u.up.set(0,-1,0),u.lookAt(new T(0,0,1)),this.add(u);const d=new Ie(Gi,Wi,t,e);d.layers=this.layers,d.up.set(0,-1,0),d.lookAt(new T(0,0,-1)),this.add(d)}update(t,e){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[i,s,a,h,u,d]=this.children,f=t.xr.enabled,g=t.getRenderTarget();t.xr.enabled=!1;const m=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,i),t.setRenderTarget(n,1),t.render(e,s),t.setRenderTarget(n,2),t.render(e,a),t.setRenderTarget(n,3),t.render(e,h),t.setRenderTarget(n,4),t.render(e,u),n.texture.generateMipmaps=m,t.setRenderTarget(n,5),t.render(e,d),t.setRenderTarget(g),t.xr.enabled=f}}class yo extends Me{constructor(t,e,n,i,s,a,h,u,d,f){t=t!==void 0?t:[],e=e!==void 0?e:go,h=h!==void 0?h:Xn,super(t,e,n,i,s,a,h,u,d,f),this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}yo.prototype.isCubeTexture=!0;class xu extends yn{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n),super(t,t,e),e=e||{},this.texture=new yo(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:en,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=Ye,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new os(5,5,5),s=new vi({name:"CubemapFromEquirect",uniforms:dr(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:me,blending:jn});s.uniforms.tEquirect.value=e;const a=new xe(i,s),h=e.minFilter;return e.minFilter===xo&&(e.minFilter=en),new vl(1,10,this).update(t,a),e.minFilter=h,a.geometry.dispose(),a.material.dispose(),this}clear(t,e,n,i){const s=t.getRenderTarget();for(let a=0;a<6;a++)t.setRenderTarget(this,a),t.clear(e,n,i);t.setRenderTarget(s)}}xu.prototype.isWebGLCubeRenderTarget=!0;const La=new T,tv=new T,ev=new ye;class vn{constructor(t=new T(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=La.subVectors(n,e).cross(tv.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const n=t.delta(La),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const s=-(t.start.dot(this.normal)+this.constant)/i;return s<0||s>1?null:e.copy(n).multiplyScalar(s).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||ev.getNormalMatrix(t),i=this.coplanarPoint(La).applyMatrix4(t),s=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}vn.prototype.isPlane=!0;const qi=new gr,Os=new T;class wo{constructor(t=new vn,e=new vn,n=new vn,i=new vn,s=new vn,a=new vn){this.planes=[t,e,n,i,s,a]}set(t,e,n,i,s,a){const h=this.planes;return h[0].copy(t),h[1].copy(e),h[2].copy(n),h[3].copy(i),h[4].copy(s),h[5].copy(a),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,i=n[0],s=n[1],a=n[2],h=n[3],u=n[4],d=n[5],f=n[6],g=n[7],m=n[8],v=n[9],b=n[10],y=n[11],M=n[12],x=n[13],_=n[14],R=n[15];return e[0].setComponents(h-i,g-u,y-m,R-M).normalize(),e[1].setComponents(h+i,g+u,y+m,R+M).normalize(),e[2].setComponents(h+s,g+d,y+v,R+x).normalize(),e[3].setComponents(h-s,g-d,y-v,R-x).normalize(),e[4].setComponents(h-a,g-f,y-b,R-_).normalize(),e[5].setComponents(h+a,g+f,y+b,R+_).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),qi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(qi)}intersectsSprite(t){return qi.center.set(0,0,0),qi.radius=.7071067811865476,qi.applyMatrix4(t.matrixWorld),this.intersectsSphere(qi)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let s=0;s<6;s++)if(e[s].distanceToPoint(n)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(Os.x=i.normal.x>0?t.max.x:t.min.x,Os.y=i.normal.y>0?t.max.y:t.min.y,Os.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(Os)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function bu(){let o=null,t=!1,e=null,n=null;function i(s,a){e(s,a),n=o.requestAnimationFrame(i)}return{start:function(){t!==!0&&e!==null&&(n=o.requestAnimationFrame(i),t=!0)},stop:function(){o.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(s){e=s},setContext:function(s){o=s}}}function nv(o,t){const e=t.isWebGL2,n=new WeakMap;function i(d,f){const g=d.array,m=d.usage,v=o.createBuffer();o.bindBuffer(f,v),o.bufferData(f,g,m),d.onUploadCallback();let b=5126;return g instanceof Float32Array?b=5126:g instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):g instanceof Uint16Array?d.isFloat16BufferAttribute?e?b=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):b=5123:g instanceof Int16Array?b=5122:g instanceof Uint32Array?b=5125:g instanceof Int32Array?b=5124:g instanceof Int8Array?b=5120:(g instanceof Uint8Array||g instanceof Uint8ClampedArray)&&(b=5121),{buffer:v,type:b,bytesPerElement:g.BYTES_PER_ELEMENT,version:d.version}}function s(d,f,g){const m=f.array,v=f.updateRange;o.bindBuffer(g,d),v.count===-1?o.bufferSubData(g,0,m):(e?o.bufferSubData(g,v.offset*m.BYTES_PER_ELEMENT,m,v.offset,v.count):o.bufferSubData(g,v.offset*m.BYTES_PER_ELEMENT,m.subarray(v.offset,v.offset+v.count)),v.count=-1)}function a(d){return d.isInterleavedBufferAttribute&&(d=d.data),n.get(d)}function h(d){d.isInterleavedBufferAttribute&&(d=d.data);const f=n.get(d);f&&(o.deleteBuffer(f.buffer),n.delete(d))}function u(d,f){if(d.isGLBufferAttribute){const m=n.get(d);(!m||m.version<d.version)&&n.set(d,{buffer:d.buffer,type:d.type,bytesPerElement:d.elementSize,version:d.version});return}d.isInterleavedBufferAttribute&&(d=d.data);const g=n.get(d);g===void 0?n.set(d,i(d,f)):g.version<d.version&&(s(g.buffer,d,f),g.version=d.version)}return{get:a,remove:h,update:u}}class _l extends $t{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const s=t/2,a=e/2,h=Math.floor(n),u=Math.floor(i),d=h+1,f=u+1,g=t/h,m=e/u,v=[],b=[],y=[],M=[];for(let x=0;x<f;x++){const _=x*m-a;for(let R=0;R<d;R++){const L=R*g-s;b.push(L,-_,0),y.push(0,0,1),M.push(R/h),M.push(1-x/u)}}for(let x=0;x<u;x++)for(let _=0;_<h;_++){const R=_+d*x,L=_+d*(x+1),A=_+1+d*(x+1),N=_+1+d*x;v.push(R,L,N),v.push(L,A,N)}this.setIndex(v),this.setAttribute("position",new ee(b,3)),this.setAttribute("normal",new ee(y,3)),this.setAttribute("uv",new ee(M,2))}static fromJSON(t){return new _l(t.width,t.height,t.widthSegments,t.heightSegments)}}var iv=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,rv=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,sv=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,ov=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,av=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,lv=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,cv="vec3 transformed = vec3( position );",hv=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,uv=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotVH = saturate( dot( geometry.viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float NoH ) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float NoV, float NoL ) {
	return saturate( 1.0 / ( 4.0 * ( NoL + NoV - NoL * NoV ) ) );
}
vec3 BRDF_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,dv=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,pv=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,fv=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,mv=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,gv=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,vv=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,_v=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,xv=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,bv=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,yv=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,wv=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Mv=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Sv=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Ev=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,Tv=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Cv=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Av="gl_FragColor = linearToOutputTexel( gl_FragColor );",Pv=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,Lv=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Rv=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Dv=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Iv=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Nv=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Fv=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,kv=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Bv=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Vv=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Ov=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,zv=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,Uv=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Hv=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,Gv=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,Wv=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in GeometricContext geometry ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,qv=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,jv=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,Xv=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,Yv=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,Zv=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularTintFactor = specularTint;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARTINTMAP
			specularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularTintFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenTint = sheenTint;
#endif`,Kv=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenTint;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += irradiance * BRDF_Sheen( material.roughness, directLight.direction, geometry, material.sheenTint );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,Jv=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,$v=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,Qv=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,t_=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,e_=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,n_=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,i_=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,r_=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,s_=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,o_=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,a_=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,l_=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,c_=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,h_=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,u_=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,d_=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,p_=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,f_=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,m_=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,g_=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,v_=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,__=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,x_=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,b_=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,y_=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,w_=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,M_=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,S_=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,E_=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,T_=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,C_=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,A_=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,P_=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,L_=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,R_=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,D_=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,I_=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,N_=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,F_=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,k_=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,B_=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,V_=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,O_=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,z_=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,U_=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,H_=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationTint, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = transmission.a;
#endif`,G_=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationTint;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,W_=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,q_=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,j_=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,X_=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,Y_=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,Z_=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,K_=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,J_=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,$_=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,Q_=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,tx=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,ex=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,nx=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,ix=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,rx=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,sx=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,ox=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,ax=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,lx=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,cx=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,hx=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,ux=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,dx=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,px=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,fx=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,mx=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,gx=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,vx=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,_x=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,xx=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularTint;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARTINTMAP
		uniform sampler2D specularTintMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenTint;
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,bx=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,yx=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,wx=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Mx=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Sx=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Ex=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Tx=`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Cx=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Ax=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;const Gt={alphamap_fragment:iv,alphamap_pars_fragment:rv,alphatest_fragment:sv,alphatest_pars_fragment:ov,aomap_fragment:av,aomap_pars_fragment:lv,begin_vertex:cv,beginnormal_vertex:hv,bsdfs:uv,bumpmap_pars_fragment:dv,clipping_planes_fragment:pv,clipping_planes_pars_fragment:fv,clipping_planes_pars_vertex:mv,clipping_planes_vertex:gv,color_fragment:vv,color_pars_fragment:_v,color_pars_vertex:xv,color_vertex:bv,common:yv,cube_uv_reflection_fragment:wv,defaultnormal_vertex:Mv,displacementmap_pars_vertex:Sv,displacementmap_vertex:Ev,emissivemap_fragment:Tv,emissivemap_pars_fragment:Cv,encodings_fragment:Av,encodings_pars_fragment:Pv,envmap_fragment:Lv,envmap_common_pars_fragment:Rv,envmap_pars_fragment:Dv,envmap_pars_vertex:Iv,envmap_physical_pars_fragment:Wv,envmap_vertex:Nv,fog_vertex:Fv,fog_pars_vertex:kv,fog_fragment:Bv,fog_pars_fragment:Vv,gradientmap_pars_fragment:Ov,lightmap_fragment:zv,lightmap_pars_fragment:Uv,lights_lambert_vertex:Hv,lights_pars_begin:Gv,lights_toon_fragment:qv,lights_toon_pars_fragment:jv,lights_phong_fragment:Xv,lights_phong_pars_fragment:Yv,lights_physical_fragment:Zv,lights_physical_pars_fragment:Kv,lights_fragment_begin:Jv,lights_fragment_maps:$v,lights_fragment_end:Qv,logdepthbuf_fragment:t_,logdepthbuf_pars_fragment:e_,logdepthbuf_pars_vertex:n_,logdepthbuf_vertex:i_,map_fragment:r_,map_pars_fragment:s_,map_particle_fragment:o_,map_particle_pars_fragment:a_,metalnessmap_fragment:l_,metalnessmap_pars_fragment:c_,morphnormal_vertex:h_,morphtarget_pars_vertex:u_,morphtarget_vertex:d_,normal_fragment_begin:p_,normal_fragment_maps:f_,normal_pars_fragment:m_,normal_pars_vertex:g_,normal_vertex:v_,normalmap_pars_fragment:__,clearcoat_normal_fragment_begin:x_,clearcoat_normal_fragment_maps:b_,clearcoat_pars_fragment:y_,output_fragment:w_,packing:M_,premultiplied_alpha_fragment:S_,project_vertex:E_,dithering_fragment:T_,dithering_pars_fragment:C_,roughnessmap_fragment:A_,roughnessmap_pars_fragment:P_,shadowmap_pars_fragment:L_,shadowmap_pars_vertex:R_,shadowmap_vertex:D_,shadowmask_pars_fragment:I_,skinbase_vertex:N_,skinning_pars_vertex:F_,skinning_vertex:k_,skinnormal_vertex:B_,specularmap_fragment:V_,specularmap_pars_fragment:O_,tonemapping_fragment:z_,tonemapping_pars_fragment:U_,transmission_fragment:H_,transmission_pars_fragment:G_,uv_pars_fragment:W_,uv_pars_vertex:q_,uv_vertex:j_,uv2_pars_fragment:X_,uv2_pars_vertex:Y_,uv2_vertex:Z_,worldpos_vertex:K_,background_frag:J_,background_vert:$_,cube_frag:Q_,cube_vert:tx,depth_frag:ex,depth_vert:nx,distanceRGBA_frag:ix,distanceRGBA_vert:rx,equirect_frag:sx,equirect_vert:ox,linedashed_frag:ax,linedashed_vert:lx,meshbasic_frag:cx,meshbasic_vert:hx,meshlambert_frag:ux,meshlambert_vert:dx,meshmatcap_frag:px,meshmatcap_vert:fx,meshnormal_frag:mx,meshnormal_vert:gx,meshphong_frag:vx,meshphong_vert:_x,meshphysical_frag:xx,meshphysical_vert:bx,meshtoon_frag:yx,meshtoon_vert:wx,points_frag:Mx,points_vert:Sx,shadow_frag:Ex,shadow_vert:Tx,sprite_frag:Cx,sprite_vert:Ax},ft={common:{diffuse:{value:new wt(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new ye},uv2Transform:{value:new ye},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new it(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new wt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new wt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new ye}},sprite:{diffuse:{value:new wt(16777215)},opacity:{value:1},center:{value:new it(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new ye}}},_n={basic:{uniforms:Te([ft.common,ft.specularmap,ft.envmap,ft.aomap,ft.lightmap,ft.fog]),vertexShader:Gt.meshbasic_vert,fragmentShader:Gt.meshbasic_frag},lambert:{uniforms:Te([ft.common,ft.specularmap,ft.envmap,ft.aomap,ft.lightmap,ft.emissivemap,ft.fog,ft.lights,{emissive:{value:new wt(0)}}]),vertexShader:Gt.meshlambert_vert,fragmentShader:Gt.meshlambert_frag},phong:{uniforms:Te([ft.common,ft.specularmap,ft.envmap,ft.aomap,ft.lightmap,ft.emissivemap,ft.bumpmap,ft.normalmap,ft.displacementmap,ft.fog,ft.lights,{emissive:{value:new wt(0)},specular:{value:new wt(1118481)},shininess:{value:30}}]),vertexShader:Gt.meshphong_vert,fragmentShader:Gt.meshphong_frag},standard:{uniforms:Te([ft.common,ft.envmap,ft.aomap,ft.lightmap,ft.emissivemap,ft.bumpmap,ft.normalmap,ft.displacementmap,ft.roughnessmap,ft.metalnessmap,ft.fog,ft.lights,{emissive:{value:new wt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Gt.meshphysical_vert,fragmentShader:Gt.meshphysical_frag},toon:{uniforms:Te([ft.common,ft.aomap,ft.lightmap,ft.emissivemap,ft.bumpmap,ft.normalmap,ft.displacementmap,ft.gradientmap,ft.fog,ft.lights,{emissive:{value:new wt(0)}}]),vertexShader:Gt.meshtoon_vert,fragmentShader:Gt.meshtoon_frag},matcap:{uniforms:Te([ft.common,ft.bumpmap,ft.normalmap,ft.displacementmap,ft.fog,{matcap:{value:null}}]),vertexShader:Gt.meshmatcap_vert,fragmentShader:Gt.meshmatcap_frag},points:{uniforms:Te([ft.points,ft.fog]),vertexShader:Gt.points_vert,fragmentShader:Gt.points_frag},dashed:{uniforms:Te([ft.common,ft.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Gt.linedashed_vert,fragmentShader:Gt.linedashed_frag},depth:{uniforms:Te([ft.common,ft.displacementmap]),vertexShader:Gt.depth_vert,fragmentShader:Gt.depth_frag},normal:{uniforms:Te([ft.common,ft.bumpmap,ft.normalmap,ft.displacementmap,{opacity:{value:1}}]),vertexShader:Gt.meshnormal_vert,fragmentShader:Gt.meshnormal_frag},sprite:{uniforms:Te([ft.sprite,ft.fog]),vertexShader:Gt.sprite_vert,fragmentShader:Gt.sprite_frag},background:{uniforms:{uvTransform:{value:new ye},t2D:{value:null}},vertexShader:Gt.background_vert,fragmentShader:Gt.background_frag},cube:{uniforms:Te([ft.envmap,{opacity:{value:1}}]),vertexShader:Gt.cube_vert,fragmentShader:Gt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Gt.equirect_vert,fragmentShader:Gt.equirect_frag},distanceRGBA:{uniforms:Te([ft.common,ft.displacementmap,{referencePosition:{value:new T},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Gt.distanceRGBA_vert,fragmentShader:Gt.distanceRGBA_frag},shadow:{uniforms:Te([ft.lights,ft.fog,{color:{value:new wt(0)},opacity:{value:1}}]),vertexShader:Gt.shadow_vert,fragmentShader:Gt.shadow_frag}};_n.physical={uniforms:Te([_n.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new it(1,1)},clearcoatNormalMap:{value:null},sheenTint:{value:new wt(0)},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new it},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationTint:{value:new wt(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularTint:{value:new wt(1,1,1)},specularTintMap:{value:null}}]),vertexShader:Gt.meshphysical_vert,fragmentShader:Gt.meshphysical_frag};function Px(o,t,e,n,i){const s=new wt(0);let a=0,h,u,d=null,f=0,g=null;function m(b,y){let M=!1,x=y.isScene===!0?y.background:null;x&&x.isTexture&&(x=t.get(x));const _=o.xr,R=_.getSession&&_.getSession();R&&R.environmentBlendMode==="additive"&&(x=null),x===null?v(s,a):x&&x.isColor&&(v(x,1),M=!0),(o.autoClear||M)&&o.clear(o.autoClearColor,o.autoClearDepth,o.autoClearStencil),x&&(x.isCubeTexture||x.mapping===_o)?(u===void 0&&(u=new xe(new os(1,1,1),new vi({name:"BackgroundCubeMaterial",uniforms:dr(_n.cube.uniforms),vertexShader:_n.cube.vertexShader,fragmentShader:_n.cube.fragmentShader,side:me,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(L,A,N){this.matrixWorld.copyPosition(N.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(u)),u.material.uniforms.envMap.value=x,u.material.uniforms.flipEnvMap.value=x.isCubeTexture&&x.isRenderTargetTexture===!1?-1:1,(d!==x||f!==x.version||g!==o.toneMapping)&&(u.material.needsUpdate=!0,d=x,f=x.version,g=o.toneMapping),b.unshift(u,u.geometry,u.material,0,0,null)):x&&x.isTexture&&(h===void 0&&(h=new xe(new _l(2,2),new vi({name:"BackgroundMaterial",uniforms:dr(_n.background.uniforms),vertexShader:_n.background.vertexShader,fragmentShader:_n.background.fragmentShader,side:Qr,depthTest:!1,depthWrite:!1,fog:!1})),h.geometry.deleteAttribute("normal"),Object.defineProperty(h.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(h)),h.material.uniforms.t2D.value=x,x.matrixAutoUpdate===!0&&x.updateMatrix(),h.material.uniforms.uvTransform.value.copy(x.matrix),(d!==x||f!==x.version||g!==o.toneMapping)&&(h.material.needsUpdate=!0,d=x,f=x.version,g=o.toneMapping),b.unshift(h,h.geometry,h.material,0,0,null))}function v(b,y){e.buffers.color.setClear(b.r,b.g,b.b,y,i)}return{getClearColor:function(){return s},setClearColor:function(b,y=1){s.set(b),a=y,v(s,a)},getClearAlpha:function(){return a},setClearAlpha:function(b){a=b,v(s,a)},render:m}}function Lx(o,t,e,n){const i=o.getParameter(34921),s=n.isWebGL2?null:t.get("OES_vertex_array_object"),a=n.isWebGL2||s!==null,h={},u=y(null);let d=u;function f(H,G,j,B,K){let at=!1;if(a){const yt=b(B,j,G);d!==yt&&(d=yt,m(d.object)),at=M(B,K),at&&x(B,K)}else{const yt=G.wireframe===!0;(d.geometry!==B.id||d.program!==j.id||d.wireframe!==yt)&&(d.geometry=B.id,d.program=j.id,d.wireframe=yt,at=!0)}H.isInstancedMesh===!0&&(at=!0),K!==null&&e.update(K,34963),at&&(C(H,G,j,B),K!==null&&o.bindBuffer(34963,e.get(K).buffer))}function g(){return n.isWebGL2?o.createVertexArray():s.createVertexArrayOES()}function m(H){return n.isWebGL2?o.bindVertexArray(H):s.bindVertexArrayOES(H)}function v(H){return n.isWebGL2?o.deleteVertexArray(H):s.deleteVertexArrayOES(H)}function b(H,G,j){const B=j.wireframe===!0;let K=h[H.id];K===void 0&&(K={},h[H.id]=K);let at=K[G.id];at===void 0&&(at={},K[G.id]=at);let yt=at[B];return yt===void 0&&(yt=y(g()),at[B]=yt),yt}function y(H){const G=[],j=[],B=[];for(let K=0;K<i;K++)G[K]=0,j[K]=0,B[K]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:G,enabledAttributes:j,attributeDivisors:B,object:H,attributes:{},index:null}}function M(H,G){const j=d.attributes,B=H.attributes;let K=0;for(const at in B){const yt=j[at],bt=B[at];if(yt===void 0||yt.attribute!==bt||yt.data!==bt.data)return!0;K++}return d.attributesNum!==K||d.index!==G}function x(H,G){const j={},B=H.attributes;let K=0;for(const at in B){const yt=B[at],bt={};bt.attribute=yt,yt.data&&(bt.data=yt.data),j[at]=bt,K++}d.attributes=j,d.attributesNum=K,d.index=G}function _(){const H=d.newAttributes;for(let G=0,j=H.length;G<j;G++)H[G]=0}function R(H){L(H,0)}function L(H,G){const j=d.newAttributes,B=d.enabledAttributes,K=d.attributeDivisors;j[H]=1,B[H]===0&&(o.enableVertexAttribArray(H),B[H]=1),K[H]!==G&&((n.isWebGL2?o:t.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](H,G),K[H]=G)}function A(){const H=d.newAttributes,G=d.enabledAttributes;for(let j=0,B=G.length;j<B;j++)G[j]!==H[j]&&(o.disableVertexAttribArray(j),G[j]=0)}function N(H,G,j,B,K,at){n.isWebGL2===!0&&(j===5124||j===5125)?o.vertexAttribIPointer(H,G,j,K,at):o.vertexAttribPointer(H,G,j,B,K,at)}function C(H,G,j,B){if(n.isWebGL2===!1&&(H.isInstancedMesh||B.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;_();const K=B.attributes,at=j.getAttributes(),yt=G.defaultAttributeValues;for(const bt in at){const mt=at[bt];if(mt.location>=0){let vt=K[bt];if(vt===void 0&&(bt==="instanceMatrix"&&H.instanceMatrix&&(vt=H.instanceMatrix),bt==="instanceColor"&&H.instanceColor&&(vt=H.instanceColor)),vt!==void 0){const J=vt.normalized,st=vt.itemSize,Mt=e.get(vt);if(Mt===void 0)continue;const q=Mt.buffer,Ct=Mt.type,At=Mt.bytesPerElement;if(vt.isInterleavedBufferAttribute){const dt=vt.data,xt=dt.stride,kt=vt.offset;if(dt&&dt.isInstancedInterleavedBuffer){for(let Z=0;Z<mt.locationSize;Z++)L(mt.location+Z,dt.meshPerAttribute);H.isInstancedMesh!==!0&&B._maxInstanceCount===void 0&&(B._maxInstanceCount=dt.meshPerAttribute*dt.count)}else for(let Z=0;Z<mt.locationSize;Z++)R(mt.location+Z);o.bindBuffer(34962,q);for(let Z=0;Z<mt.locationSize;Z++)N(mt.location+Z,st/mt.locationSize,Ct,J,xt*At,(kt+st/mt.locationSize*Z)*At)}else{if(vt.isInstancedBufferAttribute){for(let dt=0;dt<mt.locationSize;dt++)L(mt.location+dt,vt.meshPerAttribute);H.isInstancedMesh!==!0&&B._maxInstanceCount===void 0&&(B._maxInstanceCount=vt.meshPerAttribute*vt.count)}else for(let dt=0;dt<mt.locationSize;dt++)R(mt.location+dt);o.bindBuffer(34962,q);for(let dt=0;dt<mt.locationSize;dt++)N(mt.location+dt,st/mt.locationSize,Ct,J,st*At,st/mt.locationSize*dt*At)}}else if(yt!==void 0){const J=yt[bt];if(J!==void 0)switch(J.length){case 2:o.vertexAttrib2fv(mt.location,J);break;case 3:o.vertexAttrib3fv(mt.location,J);break;case 4:o.vertexAttrib4fv(mt.location,J);break;default:o.vertexAttrib1fv(mt.location,J)}}}}A()}function z(){F();for(const H in h){const G=h[H];for(const j in G){const B=G[j];for(const K in B)v(B[K].object),delete B[K];delete G[j]}delete h[H]}}function tt(H){if(h[H.id]===void 0)return;const G=h[H.id];for(const j in G){const B=G[j];for(const K in B)v(B[K].object),delete B[K];delete G[j]}delete h[H.id]}function W(H){for(const G in h){const j=h[G];if(j[H.id]===void 0)continue;const B=j[H.id];for(const K in B)v(B[K].object),delete B[K];delete j[H.id]}}function F(){rt(),d!==u&&(d=u,m(d.object))}function rt(){u.geometry=null,u.program=null,u.wireframe=!1}return{setup:f,reset:F,resetDefaultState:rt,dispose:z,releaseStatesOfGeometry:tt,releaseStatesOfProgram:W,initAttributes:_,enableAttribute:R,disableUnusedAttributes:A}}function Rx(o,t,e,n){const i=n.isWebGL2;let s;function a(d){s=d}function h(d,f){o.drawArrays(s,d,f),e.update(f,s,1)}function u(d,f,g){if(g===0)return;let m,v;if(i)m=o,v="drawArraysInstanced";else if(m=t.get("ANGLE_instanced_arrays"),v="drawArraysInstancedANGLE",m===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[v](s,d,f,g),e.update(f,s,g)}this.setMode=a,this.render=h,this.renderInstances=u}function Dx(o,t,e){let n;function i(){if(n!==void 0)return n;if(t.has("EXT_texture_filter_anisotropic")===!0){const C=t.get("EXT_texture_filter_anisotropic");n=o.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function s(C){if(C==="highp"){if(o.getShaderPrecisionFormat(35633,36338).precision>0&&o.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";C="mediump"}return C==="mediump"&&o.getShaderPrecisionFormat(35633,36337).precision>0&&o.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const a=typeof WebGL2RenderingContext!="undefined"&&o instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&o instanceof WebGL2ComputeRenderingContext;let h=e.precision!==void 0?e.precision:"highp";const u=s(h);u!==h&&(console.warn("THREE.WebGLRenderer:",h,"not supported, using",u,"instead."),h=u);const d=a||t.has("WEBGL_draw_buffers"),f=e.logarithmicDepthBuffer===!0,g=o.getParameter(34930),m=o.getParameter(35660),v=o.getParameter(3379),b=o.getParameter(34076),y=o.getParameter(34921),M=o.getParameter(36347),x=o.getParameter(36348),_=o.getParameter(36349),R=m>0,L=a||t.has("OES_texture_float"),A=R&&L,N=a?o.getParameter(36183):0;return{isWebGL2:a,drawBuffers:d,getMaxAnisotropy:i,getMaxPrecision:s,precision:h,logarithmicDepthBuffer:f,maxTextures:g,maxVertexTextures:m,maxTextureSize:v,maxCubemapSize:b,maxAttributes:y,maxVertexUniforms:M,maxVaryings:x,maxFragmentUniforms:_,vertexTextures:R,floatFragmentTextures:L,floatVertexTextures:A,maxSamples:N}}function Ix(o){const t=this;let e=null,n=0,i=!1,s=!1;const a=new vn,h=new ye,u={value:null,needsUpdate:!1};this.uniform=u,this.numPlanes=0,this.numIntersection=0,this.init=function(g,m,v){const b=g.length!==0||m||n!==0||i;return i=m,e=f(g,v,0),n=g.length,b},this.beginShadows=function(){s=!0,f(null)},this.endShadows=function(){s=!1,d()},this.setState=function(g,m,v){const b=g.clippingPlanes,y=g.clipIntersection,M=g.clipShadows,x=o.get(g);if(!i||b===null||b.length===0||s&&!M)s?f(null):d();else{const _=s?0:n,R=_*4;let L=x.clippingState||null;u.value=L,L=f(b,m,R,v);for(let A=0;A!==R;++A)L[A]=e[A];x.clippingState=L,this.numIntersection=y?this.numPlanes:0,this.numPlanes+=_}};function d(){u.value!==e&&(u.value=e,u.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function f(g,m,v,b){const y=g!==null?g.length:0;let M=null;if(y!==0){if(M=u.value,b!==!0||M===null){const x=v+y*4,_=m.matrixWorldInverse;h.getNormalMatrix(_),(M===null||M.length<x)&&(M=new Float32Array(x));for(let R=0,L=v;R!==y;++R,L+=4)a.copy(g[R]).applyMatrix4(_,h),a.normal.toArray(M,L),M[L+3]=a.constant}u.value=M,u.needsUpdate=!0}return t.numPlanes=y,t.numIntersection=0,M}}function Nx(o){let t=new WeakMap;function e(a,h){return h===$a?a.mapping=go:h===Qa&&(a.mapping=vo),a}function n(a){if(a&&a.isTexture&&a.isRenderTargetTexture===!1){const h=a.mapping;if(h===$a||h===Qa)if(t.has(a)){const u=t.get(a).texture;return e(u,a.mapping)}else{const u=a.image;if(u&&u.height>0){const d=o.getRenderTarget(),f=new xu(u.height/2);return f.fromEquirectangularTexture(o,a),t.set(a,f),o.setRenderTarget(d),a.addEventListener("dispose",i),e(f.texture,a.mapping)}else return null}}return a}function i(a){const h=a.target;h.removeEventListener("dispose",i);const u=t.get(h);u!==void 0&&(t.delete(h),u.dispose())}function s(){t=new WeakMap}return{get:n,dispose:s}}class xl extends gl{constructor(t=-1,e=1,n=1,i=-1,s=.1,a=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=s,this.far=a,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,s,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let s=n-t,a=n+t,h=i+e,u=i-e;if(this.view!==null&&this.view.enabled){const d=(this.right-this.left)/this.view.fullWidth/this.zoom,f=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=d*this.view.offsetX,a=s+d*this.view.width,h-=f*this.view.offsetY,u=h-f*this.view.height}this.projectionMatrix.makeOrthographic(s,a,h,u,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}xl.prototype.isOrthographicCamera=!0;class Mo extends vi{constructor(t){super(t),this.type="RawShaderMaterial"}}Mo.prototype.isRawShaderMaterial=!0;const ar=4,Yn=8,gn=Math.pow(2,Yn),yu=[.125,.215,.35,.446,.526,.582],wu=Yn-ar+1+yu.length,ji=20,xn={[He]:0,[bo]:1,[ml]:2,[hu]:3,[uu]:4,[du]:5,[fl]:6},Ra=new xl,{_lodPlanes:Or,_sizeLods:Qc,_sigmas:zs}=Bx(),th=new wt;let Da=null;const pi=(1+Math.sqrt(5))/2,Xi=1/pi,eh=[new T(1,1,1),new T(-1,1,1),new T(1,1,-1),new T(-1,1,-1),new T(0,pi,Xi),new T(0,pi,-Xi),new T(Xi,0,pi),new T(-Xi,0,pi),new T(pi,Xi,0),new T(-pi,Xi,0)];class Fx{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=Vx(ji),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100){Da=this._renderer.getRenderTarget();const s=this._allocateTargets();return this._sceneToCubeUV(t,n,i,s),e>0&&this._blur(s,0,0,e),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(t){return this._fromTexture(t)}fromCubemap(t){return this._fromTexture(t)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=rh(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=ih(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let t=0;t<Or.length;t++)Or[t].dispose()}_cleanup(t){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Da),t.scissorTest=!1,Us(t,0,0,t.width,t.height)}_fromTexture(t){Da=this._renderer.getRenderTarget();const e=this._allocateTargets(t);return this._textureToCubeUV(t,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(t){const e={magFilter:_e,minFilter:_e,generateMipmaps:!1,type:ur,format:Wm,encoding:kx(t)?t.encoding:ml,depthBuffer:!1},n=nh(e);return n.depthBuffer=!t,this._pingPongRenderTarget=nh(e),n}_compileMaterial(t){const e=new xe(Or[0],t);this._renderer.compile(e,Ra)}_sceneToCubeUV(t,e,n,i){const h=new Ie(90,1,e,n),u=[1,-1,1,1,1,1],d=[1,1,1,-1,-1,-1],f=this._renderer,g=f.autoClear,m=f.outputEncoding,v=f.toneMapping;f.getClearColor(th),f.toneMapping=gi,f.outputEncoding=He,f.autoClear=!1;const b=new xi({name:"PMREM.Background",side:me,depthWrite:!1,depthTest:!1}),y=new xe(new os,b);let M=!1;const x=t.background;x?x.isColor&&(b.color.copy(x),t.background=null,M=!0):(b.color.copy(th),M=!0);for(let _=0;_<6;_++){const R=_%3;R==0?(h.up.set(0,u[_],0),h.lookAt(d[_],0,0)):R==1?(h.up.set(0,0,u[_]),h.lookAt(0,d[_],0)):(h.up.set(0,u[_],0),h.lookAt(0,0,d[_])),Us(i,R*gn,_>2?gn:0,gn,gn),f.setRenderTarget(i),M&&f.render(y,h),f.render(t,h)}y.geometry.dispose(),y.material.dispose(),f.toneMapping=v,f.outputEncoding=m,f.autoClear=g,t.background=x}_textureToCubeUV(t,e){const n=this._renderer;t.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=rh()):this._equirectShader==null&&(this._equirectShader=ih());const i=t.isCubeTexture?this._cubemapShader:this._equirectShader,s=new xe(Or[0],i),a=i.uniforms;a.envMap.value=t,t.isCubeTexture||a.texelSize.value.set(1/t.image.width,1/t.image.height),a.inputEncoding.value=xn[t.encoding],a.outputEncoding.value=xn[e.texture.encoding],Us(e,0,0,3*gn,2*gn),n.setRenderTarget(e),n.render(s,Ra)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let i=1;i<wu;i++){const s=Math.sqrt(zs[i]*zs[i]-zs[i-1]*zs[i-1]),a=eh[(i-1)%eh.length];this._blur(t,i-1,i,s,a)}e.autoClear=n}_blur(t,e,n,i,s){const a=this._pingPongRenderTarget;this._halfBlur(t,a,e,n,i,"latitudinal",s),this._halfBlur(a,t,n,n,i,"longitudinal",s)}_halfBlur(t,e,n,i,s,a,h){const u=this._renderer,d=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const f=3,g=new xe(Or[i],d),m=d.uniforms,v=Qc[n]-1,b=isFinite(s)?Math.PI/(2*v):2*Math.PI/(2*ji-1),y=s/b,M=isFinite(s)?1+Math.floor(f*y):ji;M>ji&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${M} samples when the maximum is set to ${ji}`);const x=[];let _=0;for(let N=0;N<ji;++N){const C=N/y,z=Math.exp(-C*C/2);x.push(z),N==0?_+=z:N<M&&(_+=2*z)}for(let N=0;N<x.length;N++)x[N]=x[N]/_;m.envMap.value=t.texture,m.samples.value=M,m.weights.value=x,m.latitudinal.value=a==="latitudinal",h&&(m.poleAxis.value=h),m.dTheta.value=b,m.mipInt.value=Yn-n,m.inputEncoding.value=xn[t.texture.encoding],m.outputEncoding.value=xn[t.texture.encoding];const R=Qc[i],L=3*Math.max(0,gn-2*R),A=(i===0?0:2*gn)+2*R*(i>Yn-ar?i-Yn+ar:0);Us(e,L,A,3*R,2*R),u.setRenderTarget(e),u.render(g,Ra)}}function kx(o){return o===void 0||o.type!==ur?!1:o.encoding===He||o.encoding===bo||o.encoding===fl}function Bx(){const o=[],t=[],e=[];let n=Yn;for(let i=0;i<wu;i++){const s=Math.pow(2,n);t.push(s);let a=1/s;i>Yn-ar?a=yu[i-Yn+ar-1]:i==0&&(a=0),e.push(a);const h=1/(s-1),u=-h/2,d=1+h/2,f=[u,u,d,u,d,d,u,u,d,d,u,d],g=6,m=6,v=3,b=2,y=1,M=new Float32Array(v*m*g),x=new Float32Array(b*m*g),_=new Float32Array(y*m*g);for(let L=0;L<g;L++){const A=L%3*2/3-1,N=L>2?0:-1,C=[A,N,0,A+2/3,N,0,A+2/3,N+1,0,A,N,0,A+2/3,N+1,0,A,N+1,0];M.set(C,v*m*L),x.set(f,b*m*L);const z=[L,L,L,L,L,L];_.set(z,y*m*L)}const R=new $t;R.setAttribute("position",new ge(M,v)),R.setAttribute("uv",new ge(x,b)),R.setAttribute("faceIndex",new ge(_,y)),o.push(R),n>ar&&n--}return{_lodPlanes:o,_sizeLods:t,_sigmas:e}}function nh(o){const t=new yn(3*gn,3*gn,o);return t.texture.mapping=_o,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function Us(o,t,e,n,i){o.viewport.set(t,e,n,i),o.scissor.set(t,e,n,i)}function Vx(o){const t=new Float32Array(o),e=new T(0,1,0);return new Mo({name:"SphericalGaussianBlur",defines:{n:o},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:e},inputEncoding:{value:xn[He]},outputEncoding:{value:xn[He]}},vertexShader:bl(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${yl()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:jn,depthTest:!1,depthWrite:!1})}function ih(){const o=new it(1,1);return new Mo({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:o},inputEncoding:{value:xn[He]},outputEncoding:{value:xn[He]}},vertexShader:bl(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${yl()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:jn,depthTest:!1,depthWrite:!1})}function rh(){return new Mo({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:xn[He]},outputEncoding:{value:xn[He]}},vertexShader:bl(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${yl()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:jn,depthTest:!1,depthWrite:!1})}function bl(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function yl(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function Ox(o){let t=new WeakMap,e=null;function n(h){if(h&&h.isTexture&&h.isRenderTargetTexture===!1){const u=h.mapping,d=u===$a||u===Qa,f=u===go||u===vo;if(d||f){if(t.has(h))return t.get(h).texture;{const g=h.image;if(d&&g&&g.height>0||f&&g&&i(g)){const m=o.getRenderTarget();e===null&&(e=new Fx(o));const v=d?e.fromEquirectangular(h):e.fromCubemap(h);return t.set(h,v),o.setRenderTarget(m),h.addEventListener("dispose",s),v.texture}else return null}}}return h}function i(h){let u=0;const d=6;for(let f=0;f<d;f++)h[f]!==void 0&&u++;return u===d}function s(h){const u=h.target;u.removeEventListener("dispose",s);const d=t.get(u);d!==void 0&&(t.delete(u),d.dispose())}function a(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:n,dispose:a}}function zx(o){const t={};function e(n){if(t[n]!==void 0)return t[n];let i;switch(n){case"WEBGL_depth_texture":i=o.getExtension("WEBGL_depth_texture")||o.getExtension("MOZ_WEBGL_depth_texture")||o.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=o.getExtension("EXT_texture_filter_anisotropic")||o.getExtension("MOZ_EXT_texture_filter_anisotropic")||o.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=o.getExtension("WEBGL_compressed_texture_s3tc")||o.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||o.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=o.getExtension("WEBGL_compressed_texture_pvrtc")||o.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=o.getExtension(n)}return t[n]=i,i}return{has:function(n){return e(n)!==null},init:function(n){n.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float")},get:function(n){const i=e(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function Ux(o,t,e,n){const i={},s=new WeakMap;function a(g){const m=g.target;m.index!==null&&t.remove(m.index);for(const b in m.attributes)t.remove(m.attributes[b]);m.removeEventListener("dispose",a),delete i[m.id];const v=s.get(m);v&&(t.remove(v),s.delete(m)),n.releaseStatesOfGeometry(m),m.isInstancedBufferGeometry===!0&&delete m._maxInstanceCount,e.memory.geometries--}function h(g,m){return i[m.id]===!0||(m.addEventListener("dispose",a),i[m.id]=!0,e.memory.geometries++),m}function u(g){const m=g.attributes;for(const b in m)t.update(m[b],34962);const v=g.morphAttributes;for(const b in v){const y=v[b];for(let M=0,x=y.length;M<x;M++)t.update(y[M],34962)}}function d(g){const m=[],v=g.index,b=g.attributes.position;let y=0;if(v!==null){const _=v.array;y=v.version;for(let R=0,L=_.length;R<L;R+=3){const A=_[R+0],N=_[R+1],C=_[R+2];m.push(A,N,N,C,C,A)}}else{const _=b.array;y=b.version;for(let R=0,L=_.length/3-1;R<L;R+=3){const A=R+0,N=R+1,C=R+2;m.push(A,N,N,C,C,A)}}const M=new(_u(m)>65535?vu:gu)(m,1);M.version=y;const x=s.get(g);x&&t.remove(x),s.set(g,M)}function f(g){const m=s.get(g);if(m){const v=g.index;v!==null&&m.version<v.version&&d(g)}else d(g);return s.get(g)}return{get:h,update:u,getWireframeAttribute:f}}function Hx(o,t,e,n){const i=n.isWebGL2;let s;function a(m){s=m}let h,u;function d(m){h=m.type,u=m.bytesPerElement}function f(m,v){o.drawElements(s,v,h,m*u),e.update(v,s,1)}function g(m,v,b){if(b===0)return;let y,M;if(i)y=o,M="drawElementsInstanced";else if(y=t.get("ANGLE_instanced_arrays"),M="drawElementsInstancedANGLE",y===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}y[M](s,v,h,m*u,b),e.update(v,s,b)}this.setMode=a,this.setIndex=d,this.render=f,this.renderInstances=g}function Gx(o){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,a,h){switch(e.calls++,a){case 4:e.triangles+=h*(s/3);break;case 1:e.lines+=h*(s/2);break;case 3:e.lines+=h*(s-1);break;case 2:e.lines+=h*s;break;case 0:e.points+=h*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function i(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:i,update:n}}function Wx(o,t){return o[0]-t[0]}function qx(o,t){return Math.abs(t[1])-Math.abs(o[1])}function jx(o){const t={},e=new Float32Array(8),n=[];for(let s=0;s<8;s++)n[s]=[s,0];function i(s,a,h,u){const d=s.morphTargetInfluences,f=d===void 0?0:d.length;let g=t[a.id];if(g===void 0||g.length!==f){g=[];for(let M=0;M<f;M++)g[M]=[M,0];t[a.id]=g}for(let M=0;M<f;M++){const x=g[M];x[0]=M,x[1]=d[M]}g.sort(qx);for(let M=0;M<8;M++)M<f&&g[M][1]?(n[M][0]=g[M][0],n[M][1]=g[M][1]):(n[M][0]=Number.MAX_SAFE_INTEGER,n[M][1]=0);n.sort(Wx);const m=a.morphAttributes.position,v=a.morphAttributes.normal;let b=0;for(let M=0;M<8;M++){const x=n[M],_=x[0],R=x[1];_!==Number.MAX_SAFE_INTEGER&&R?(m&&a.getAttribute("morphTarget"+M)!==m[_]&&a.setAttribute("morphTarget"+M,m[_]),v&&a.getAttribute("morphNormal"+M)!==v[_]&&a.setAttribute("morphNormal"+M,v[_]),e[M]=R,b+=R):(m&&a.hasAttribute("morphTarget"+M)===!0&&a.deleteAttribute("morphTarget"+M),v&&a.hasAttribute("morphNormal"+M)===!0&&a.deleteAttribute("morphNormal"+M),e[M]=0)}const y=a.morphTargetsRelative?1:1-b;u.getUniforms().setValue(o,"morphTargetBaseInfluence",y),u.getUniforms().setValue(o,"morphTargetInfluences",e)}return{update:i}}function Xx(o,t,e,n){let i=new WeakMap;function s(u){const d=n.render.frame,f=u.geometry,g=t.get(u,f);return i.get(g)!==d&&(t.update(g),i.set(g,d)),u.isInstancedMesh&&(u.hasEventListener("dispose",h)===!1&&u.addEventListener("dispose",h),e.update(u.instanceMatrix,34962),u.instanceColor!==null&&e.update(u.instanceColor,34962)),g}function a(){i=new WeakMap}function h(u){const d=u.target;d.removeEventListener("dispose",h),e.remove(d.instanceMatrix),d.instanceColor!==null&&e.remove(d.instanceColor)}return{update:s,dispose:a}}class Mu extends Me{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=_e,this.minFilter=_e,this.wrapR=Xe,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Mu.prototype.isDataTexture2DArray=!0;class Su extends Me{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=_e,this.minFilter=_e,this.wrapR=Xe,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Su.prototype.isDataTexture3D=!0;const Eu=new Me,Yx=new Mu,Zx=new Su,Tu=new yo,sh=[],oh=[],ah=new Float32Array(16),lh=new Float32Array(9),ch=new Float32Array(4);function _r(o,t,e){const n=o[0];if(n<=0||n>0)return o;const i=t*e;let s=sh[i];if(s===void 0&&(s=new Float32Array(i),sh[i]=s),t!==0){n.toArray(s,0);for(let a=1,h=0;a!==t;++a)h+=e,o[a].toArray(s,h)}return s}function Fe(o,t){if(o.length!==t.length)return!1;for(let e=0,n=o.length;e<n;e++)if(o[e]!==t[e])return!1;return!0}function Ae(o,t){for(let e=0,n=t.length;e<n;e++)o[e]=t[e]}function Cu(o,t){let e=oh[t];e===void 0&&(e=new Int32Array(t),oh[t]=e);for(let n=0;n!==t;++n)e[n]=o.allocateTextureUnit();return e}function Kx(o,t){const e=this.cache;e[0]!==t&&(o.uniform1f(this.addr,t),e[0]=t)}function Jx(o,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(o.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(Fe(e,t))return;o.uniform2fv(this.addr,t),Ae(e,t)}}function $x(o,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(o.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(o.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(Fe(e,t))return;o.uniform3fv(this.addr,t),Ae(e,t)}}function Qx(o,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(o.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(Fe(e,t))return;o.uniform4fv(this.addr,t),Ae(e,t)}}function t0(o,t){const e=this.cache,n=t.elements;if(n===void 0){if(Fe(e,t))return;o.uniformMatrix2fv(this.addr,!1,t),Ae(e,t)}else{if(Fe(e,n))return;ch.set(n),o.uniformMatrix2fv(this.addr,!1,ch),Ae(e,n)}}function e0(o,t){const e=this.cache,n=t.elements;if(n===void 0){if(Fe(e,t))return;o.uniformMatrix3fv(this.addr,!1,t),Ae(e,t)}else{if(Fe(e,n))return;lh.set(n),o.uniformMatrix3fv(this.addr,!1,lh),Ae(e,n)}}function n0(o,t){const e=this.cache,n=t.elements;if(n===void 0){if(Fe(e,t))return;o.uniformMatrix4fv(this.addr,!1,t),Ae(e,t)}else{if(Fe(e,n))return;ah.set(n),o.uniformMatrix4fv(this.addr,!1,ah),Ae(e,n)}}function i0(o,t){const e=this.cache;e[0]!==t&&(o.uniform1i(this.addr,t),e[0]=t)}function r0(o,t){const e=this.cache;Fe(e,t)||(o.uniform2iv(this.addr,t),Ae(e,t))}function s0(o,t){const e=this.cache;Fe(e,t)||(o.uniform3iv(this.addr,t),Ae(e,t))}function o0(o,t){const e=this.cache;Fe(e,t)||(o.uniform4iv(this.addr,t),Ae(e,t))}function a0(o,t){const e=this.cache;e[0]!==t&&(o.uniform1ui(this.addr,t),e[0]=t)}function l0(o,t){const e=this.cache;Fe(e,t)||(o.uniform2uiv(this.addr,t),Ae(e,t))}function c0(o,t){const e=this.cache;Fe(e,t)||(o.uniform3uiv(this.addr,t),Ae(e,t))}function h0(o,t){const e=this.cache;Fe(e,t)||(o.uniform4uiv(this.addr,t),Ae(e,t))}function u0(o,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(o.uniform1i(this.addr,i),n[0]=i),e.safeSetTexture2D(t||Eu,i)}function d0(o,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(o.uniform1i(this.addr,i),n[0]=i),e.setTexture3D(t||Zx,i)}function p0(o,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(o.uniform1i(this.addr,i),n[0]=i),e.safeSetTextureCube(t||Tu,i)}function f0(o,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(o.uniform1i(this.addr,i),n[0]=i),e.setTexture2DArray(t||Yx,i)}function m0(o){switch(o){case 5126:return Kx;case 35664:return Jx;case 35665:return $x;case 35666:return Qx;case 35674:return t0;case 35675:return e0;case 35676:return n0;case 5124:case 35670:return i0;case 35667:case 35671:return r0;case 35668:case 35672:return s0;case 35669:case 35673:return o0;case 5125:return a0;case 36294:return l0;case 36295:return c0;case 36296:return h0;case 35678:case 36198:case 36298:case 36306:case 35682:return u0;case 35679:case 36299:case 36307:return d0;case 35680:case 36300:case 36308:case 36293:return p0;case 36289:case 36303:case 36311:case 36292:return f0}}function g0(o,t){o.uniform1fv(this.addr,t)}function v0(o,t){const e=_r(t,this.size,2);o.uniform2fv(this.addr,e)}function _0(o,t){const e=_r(t,this.size,3);o.uniform3fv(this.addr,e)}function x0(o,t){const e=_r(t,this.size,4);o.uniform4fv(this.addr,e)}function b0(o,t){const e=_r(t,this.size,4);o.uniformMatrix2fv(this.addr,!1,e)}function y0(o,t){const e=_r(t,this.size,9);o.uniformMatrix3fv(this.addr,!1,e)}function w0(o,t){const e=_r(t,this.size,16);o.uniformMatrix4fv(this.addr,!1,e)}function M0(o,t){o.uniform1iv(this.addr,t)}function S0(o,t){o.uniform2iv(this.addr,t)}function E0(o,t){o.uniform3iv(this.addr,t)}function T0(o,t){o.uniform4iv(this.addr,t)}function C0(o,t){o.uniform1uiv(this.addr,t)}function A0(o,t){o.uniform2uiv(this.addr,t)}function P0(o,t){o.uniform3uiv(this.addr,t)}function L0(o,t){o.uniform4uiv(this.addr,t)}function R0(o,t,e){const n=t.length,i=Cu(e,n);o.uniform1iv(this.addr,i);for(let s=0;s!==n;++s)e.safeSetTexture2D(t[s]||Eu,i[s])}function D0(o,t,e){const n=t.length,i=Cu(e,n);o.uniform1iv(this.addr,i);for(let s=0;s!==n;++s)e.safeSetTextureCube(t[s]||Tu,i[s])}function I0(o){switch(o){case 5126:return g0;case 35664:return v0;case 35665:return _0;case 35666:return x0;case 35674:return b0;case 35675:return y0;case 35676:return w0;case 5124:case 35670:return M0;case 35667:case 35671:return S0;case 35668:case 35672:return E0;case 35669:case 35673:return T0;case 5125:return C0;case 36294:return A0;case 36295:return P0;case 36296:return L0;case 35678:case 36198:case 36298:case 36306:case 35682:return R0;case 35680:case 36300:case 36308:case 36293:return D0}}function N0(o,t,e){this.id=o,this.addr=e,this.cache=[],this.setValue=m0(t.type)}function Au(o,t,e){this.id=o,this.addr=e,this.cache=[],this.size=t.size,this.setValue=I0(t.type)}Au.prototype.updateCache=function(o){const t=this.cache;o instanceof Float32Array&&t.length!==o.length&&(this.cache=new Float32Array(o.length)),Ae(t,o)};function Pu(o){this.id=o,this.seq=[],this.map={}}Pu.prototype.setValue=function(o,t,e){const n=this.seq;for(let i=0,s=n.length;i!==s;++i){const a=n[i];a.setValue(o,t[a.id],e)}};const Ia=/(\w+)(\])?(\[|\.)?/g;function hh(o,t){o.seq.push(t),o.map[t.id]=t}function F0(o,t,e){const n=o.name,i=n.length;for(Ia.lastIndex=0;;){const s=Ia.exec(n),a=Ia.lastIndex;let h=s[1];const u=s[2]==="]",d=s[3];if(u&&(h=h|0),d===void 0||d==="["&&a+2===i){hh(e,d===void 0?new N0(h,o,t):new Au(h,o,t));break}else{let g=e.map[h];g===void 0&&(g=new Pu(h),hh(e,g)),e=g}}}function Zn(o,t){this.seq=[],this.map={};const e=o.getProgramParameter(t,35718);for(let n=0;n<e;++n){const i=o.getActiveUniform(t,n),s=o.getUniformLocation(t,i.name);F0(i,s,this)}}Zn.prototype.setValue=function(o,t,e,n){const i=this.map[t];i!==void 0&&i.setValue(o,e,n)};Zn.prototype.setOptional=function(o,t,e){const n=t[e];n!==void 0&&this.setValue(o,e,n)};Zn.upload=function(o,t,e,n){for(let i=0,s=t.length;i!==s;++i){const a=t[i],h=e[a.id];h.needsUpdate!==!1&&a.setValue(o,h.value,n)}};Zn.seqWithValue=function(o,t){const e=[];for(let n=0,i=o.length;n!==i;++n){const s=o[n];s.id in t&&e.push(s)}return e};function uh(o,t,e){const n=o.createShader(t);return o.shaderSource(n,e),o.compileShader(n),n}let k0=0;function B0(o){const t=o.split(`
`);for(let e=0;e<t.length;e++)t[e]=e+1+": "+t[e];return t.join(`
`)}function Lu(o){switch(o){case He:return["Linear","( value )"];case bo:return["sRGB","( value )"];case ml:return["RGBE","( value )"];case hu:return["RGBM","( value, 7.0 )"];case uu:return["RGBM","( value, 16.0 )"];case du:return["RGBD","( value, 256.0 )"];case fl:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case Rg:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",o),["Linear","( value )"]}}function dh(o,t,e){const n=o.getShaderParameter(t,35713),i=o.getShaderInfoLog(t).trim();return n&&i===""?"":e.toUpperCase()+`

`+i+`

`+B0(o.getShaderSource(t))}function Yi(o,t){const e=Lu(t);return"vec4 "+o+"( vec4 value ) { return "+e[0]+"ToLinear"+e[1]+"; }"}function V0(o,t){const e=Lu(t);return"vec4 "+o+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function O0(o,t){let e;switch(t){case Pm:e="Linear";break;case Lm:e="Reinhard";break;case Rm:e="OptimizedCineon";break;case Dm:e="ACESFilmic";break;case Im:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+o+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function z0(o){return[o.extensionDerivatives||o.envMapCubeUV||o.bumpMap||o.tangentSpaceNormalMap||o.clearcoatNormalMap||o.flatShading||o.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(o.extensionFragDepth||o.logarithmicDepthBuffer)&&o.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",o.extensionDrawBuffers&&o.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(o.extensionShaderTextureLOD||o.envMap||o.transmission)&&o.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Xr).join(`
`)}function U0(o){const t=[];for(const e in o){const n=o[e];n!==!1&&t.push("#define "+e+" "+n)}return t.join(`
`)}function H0(o,t){const e={},n=o.getProgramParameter(t,35721);for(let i=0;i<n;i++){const s=o.getActiveAttrib(t,i),a=s.name;let h=1;s.type===35674&&(h=2),s.type===35675&&(h=3),s.type===35676&&(h=4),e[a]={type:s.type,location:o.getAttribLocation(t,a),locationSize:h}}return e}function Xr(o){return o!==""}function ph(o,t){return o.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function fh(o,t){return o.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const G0=/^[ \t]*#include +<([\w\d./]+)>/gm;function il(o){return o.replace(G0,W0)}function W0(o,t){const e=Gt[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return il(e)}const q0=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,j0=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function mh(o){return o.replace(j0,Ru).replace(q0,X0)}function X0(o,t,e,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Ru(o,t,e,n)}function Ru(o,t,e,n){let i="";for(let s=parseInt(t);s<parseInt(e);s++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function gh(o){let t="precision "+o.precision+` float;
precision `+o.precision+" int;";return o.precision==="highp"?t+=`
#define HIGH_PRECISION`:o.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:o.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function Y0(o){let t="SHADOWMAP_TYPE_BASIC";return o.shadowMapType===ru?t="SHADOWMAP_TYPE_PCF":o.shadowMapType===am?t="SHADOWMAP_TYPE_PCF_SOFT":o.shadowMapType===jr&&(t="SHADOWMAP_TYPE_VSM"),t}function Z0(o){let t="ENVMAP_TYPE_CUBE";if(o.envMap)switch(o.envMapMode){case go:case vo:t="ENVMAP_TYPE_CUBE";break;case _o:case dl:t="ENVMAP_TYPE_CUBE_UV";break}return t}function K0(o){let t="ENVMAP_MODE_REFLECTION";if(o.envMap)switch(o.envMapMode){case vo:case dl:t="ENVMAP_MODE_REFRACTION";break}return t}function J0(o){let t="ENVMAP_BLENDING_NONE";if(o.envMap)switch(o.combine){case mo:t="ENVMAP_BLENDING_MULTIPLY";break;case Cm:t="ENVMAP_BLENDING_MIX";break;case Am:t="ENVMAP_BLENDING_ADD";break}return t}function $0(o,t,e,n){const i=o.getContext(),s=e.defines;let a=e.vertexShader,h=e.fragmentShader;const u=Y0(e),d=Z0(e),f=K0(e),g=J0(e),m=o.gammaFactor>0?o.gammaFactor:1,v=e.isWebGL2?"":z0(e),b=U0(s),y=i.createProgram();let M,x,_=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(M=[b].filter(Xr).join(`
`),M.length>0&&(M+=`
`),x=[v,b].filter(Xr).join(`
`),x.length>0&&(x+=`
`)):(M=[gh(e),"#define SHADER_NAME "+e.shaderName,b,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+m,"#define MAX_BONES "+e.maxBones,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+f:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularTintMap?"#define USE_SPECULARTINTMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.useVertexTexture?"#define BONE_TEXTURE":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+u:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Xr).join(`
`),x=[v,gh(e),"#define SHADER_NAME "+e.shaderName,b,"#define GAMMA_FACTOR "+m,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+d:"",e.envMap?"#define "+f:"",e.envMap?"#define "+g:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularTintMap?"#define USE_SPECULARTINTMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.sheenTint?"#define USE_SHEEN":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+u:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==gi?"#define TONE_MAPPING":"",e.toneMapping!==gi?Gt.tonemapping_pars_fragment:"",e.toneMapping!==gi?O0("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.format===Xn?"#define OPAQUE":"",Gt.encodings_pars_fragment,e.map?Yi("mapTexelToLinear",e.mapEncoding):"",e.matcap?Yi("matcapTexelToLinear",e.matcapEncoding):"",e.envMap?Yi("envMapTexelToLinear",e.envMapEncoding):"",e.emissiveMap?Yi("emissiveMapTexelToLinear",e.emissiveMapEncoding):"",e.specularTintMap?Yi("specularTintMapTexelToLinear",e.specularTintMapEncoding):"",e.lightMap?Yi("lightMapTexelToLinear",e.lightMapEncoding):"",V0("linearToOutputTexel",e.outputEncoding),e.depthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Xr).join(`
`)),a=il(a),a=ph(a,e),a=fh(a,e),h=il(h),h=ph(h,e),h=fh(h,e),a=mh(a),h=mh(h),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(_=`#version 300 es
`,M=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+M,x=["#define varying in",e.glslVersion===zc?"":"out highp vec4 pc_fragColor;",e.glslVersion===zc?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+x);const R=_+M+a,L=_+x+h,A=uh(i,35633,R),N=uh(i,35632,L);if(i.attachShader(y,A),i.attachShader(y,N),e.index0AttributeName!==void 0?i.bindAttribLocation(y,0,e.index0AttributeName):e.morphTargets===!0&&i.bindAttribLocation(y,0,"position"),i.linkProgram(y),o.debug.checkShaderErrors){const tt=i.getProgramInfoLog(y).trim(),W=i.getShaderInfoLog(A).trim(),F=i.getShaderInfoLog(N).trim();let rt=!0,H=!0;if(i.getProgramParameter(y,35714)===!1){rt=!1;const G=dh(i,A,"vertex"),j=dh(i,N,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(y,35715)+`

Program Info Log: `+tt+`
`+G+`
`+j)}else tt!==""?console.warn("THREE.WebGLProgram: Program Info Log:",tt):(W===""||F==="")&&(H=!1);H&&(this.diagnostics={runnable:rt,programLog:tt,vertexShader:{log:W,prefix:M},fragmentShader:{log:F,prefix:x}})}i.deleteShader(A),i.deleteShader(N);let C;this.getUniforms=function(){return C===void 0&&(C=new Zn(i,y)),C};let z;return this.getAttributes=function(){return z===void 0&&(z=H0(i,y)),z},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(y),this.program=void 0},this.name=e.shaderName,this.id=k0++,this.cacheKey=t,this.usedTimes=1,this.program=y,this.vertexShader=A,this.fragmentShader=N,this}function Q0(o,t,e,n,i,s,a){const h=[],u=i.isWebGL2,d=i.logarithmicDepthBuffer,f=i.floatVertexTextures,g=i.maxVertexUniforms,m=i.vertexTextures;let v=i.precision;const b={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},y=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","specularIntensityMap","specularTintMap","specularTintMapEncoding","roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","sheenTint","transmission","transmissionMap","thicknessMap"];function M(C){const tt=C.skeleton.bones;if(f)return 1024;{const F=Math.floor((g-20)/4),rt=Math.min(F,tt.length);return rt<tt.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+tt.length+" bones. This GPU supports "+rt+"."),0):rt}}function x(C){let z;return C&&C.isTexture?z=C.encoding:C&&C.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),z=C.texture.encoding):z=He,z}function _(C,z,tt,W,F){const rt=W.fog,H=C.isMeshStandardMaterial?W.environment:null,G=(C.isMeshStandardMaterial?e:t).get(C.envMap||H),j=b[C.type],B=F.isSkinnedMesh?M(F):0;C.precision!==null&&(v=i.getMaxPrecision(C.precision),v!==C.precision&&console.warn("THREE.WebGLProgram.getParameters:",C.precision,"not supported, using",v,"instead."));let K,at;if(j){const J=_n[j];K=J.vertexShader,at=J.fragmentShader}else K=C.vertexShader,at=C.fragmentShader;const yt=o.getRenderTarget(),bt=C.alphaTest>0,mt=C.clearcoat>0;return{isWebGL2:u,shaderID:j,shaderName:C.type,vertexShader:K,fragmentShader:at,defines:C.defines,isRawShaderMaterial:C.isRawShaderMaterial===!0,glslVersion:C.glslVersion,precision:v,instancing:F.isInstancedMesh===!0,instancingColor:F.isInstancedMesh===!0&&F.instanceColor!==null,supportsVertexTextures:m,outputEncoding:yt!==null?x(yt.texture):o.outputEncoding,map:!!C.map,mapEncoding:x(C.map),matcap:!!C.matcap,matcapEncoding:x(C.matcap),envMap:!!G,envMapMode:G&&G.mapping,envMapEncoding:x(G),envMapCubeUV:!!G&&(G.mapping===_o||G.mapping===dl),lightMap:!!C.lightMap,lightMapEncoding:x(C.lightMap),aoMap:!!C.aoMap,emissiveMap:!!C.emissiveMap,emissiveMapEncoding:x(C.emissiveMap),bumpMap:!!C.bumpMap,normalMap:!!C.normalMap,objectSpaceNormalMap:C.normalMapType===Ng,tangentSpaceNormalMap:C.normalMapType===fr,clearcoat:mt,clearcoatMap:mt&&!!C.clearcoatMap,clearcoatRoughnessMap:mt&&!!C.clearcoatRoughnessMap,clearcoatNormalMap:mt&&!!C.clearcoatNormalMap,displacementMap:!!C.displacementMap,roughnessMap:!!C.roughnessMap,metalnessMap:!!C.metalnessMap,specularMap:!!C.specularMap,specularIntensityMap:!!C.specularIntensityMap,specularTintMap:!!C.specularTintMap,specularTintMapEncoding:x(C.specularTintMap),alphaMap:!!C.alphaMap,alphaTest:bt,gradientMap:!!C.gradientMap,sheenTint:!!C.sheenTint&&(C.sheenTint.r>0||C.sheenTint.g>0||C.sheenTint.b>0),transmission:C.transmission>0,transmissionMap:!!C.transmissionMap,thicknessMap:!!C.thicknessMap,combine:C.combine,vertexTangents:!!C.normalMap&&!!F.geometry&&!!F.geometry.attributes.tangent,vertexColors:C.vertexColors,vertexAlphas:C.vertexColors===!0&&!!F.geometry&&!!F.geometry.attributes.color&&F.geometry.attributes.color.itemSize===4,vertexUvs:!!C.map||!!C.bumpMap||!!C.normalMap||!!C.specularMap||!!C.alphaMap||!!C.emissiveMap||!!C.roughnessMap||!!C.metalnessMap||!!C.clearcoatMap||!!C.clearcoatRoughnessMap||!!C.clearcoatNormalMap||!!C.displacementMap||!!C.transmissionMap||!!C.thicknessMap||!!C.specularIntensityMap||!!C.specularTintMap,uvsVertexOnly:!(!!C.map||!!C.bumpMap||!!C.normalMap||!!C.specularMap||!!C.alphaMap||!!C.emissiveMap||!!C.roughnessMap||!!C.metalnessMap||!!C.clearcoatNormalMap||C.transmission>0||!!C.transmissionMap||!!C.thicknessMap||!!C.specularIntensityMap||!!C.specularTintMap)&&!!C.displacementMap,fog:!!rt,useFog:C.fog,fogExp2:rt&&rt.isFogExp2,flatShading:!!C.flatShading,sizeAttenuation:C.sizeAttenuation,logarithmicDepthBuffer:d,skinning:F.isSkinnedMesh===!0&&B>0,maxBones:B,useVertexTexture:f,morphTargets:!!F.geometry&&!!F.geometry.morphAttributes.position,morphNormals:!!F.geometry&&!!F.geometry.morphAttributes.normal,numDirLights:z.directional.length,numPointLights:z.point.length,numSpotLights:z.spot.length,numRectAreaLights:z.rectArea.length,numHemiLights:z.hemi.length,numDirLightShadows:z.directionalShadowMap.length,numPointLightShadows:z.pointShadowMap.length,numSpotLightShadows:z.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,format:C.format,dithering:C.dithering,shadowMapEnabled:o.shadowMap.enabled&&tt.length>0,shadowMapType:o.shadowMap.type,toneMapping:C.toneMapped?o.toneMapping:gi,physicallyCorrectLights:o.physicallyCorrectLights,premultipliedAlpha:C.premultipliedAlpha,doubleSided:C.side===hr,flipSided:C.side===me,depthPacking:C.depthPacking!==void 0?C.depthPacking:!1,index0AttributeName:C.index0AttributeName,extensionDerivatives:C.extensions&&C.extensions.derivatives,extensionFragDepth:C.extensions&&C.extensions.fragDepth,extensionDrawBuffers:C.extensions&&C.extensions.drawBuffers,extensionShaderTextureLOD:C.extensions&&C.extensions.shaderTextureLOD,rendererExtensionFragDepth:u||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||n.has("EXT_shader_texture_lod"),customProgramCacheKey:C.customProgramCacheKey()}}function R(C){const z=[];if(C.shaderID?z.push(C.shaderID):(z.push(C.fragmentShader),z.push(C.vertexShader)),C.defines!==void 0)for(const tt in C.defines)z.push(tt),z.push(C.defines[tt]);if(C.isRawShaderMaterial===!1){for(let tt=0;tt<y.length;tt++)z.push(C[y[tt]]);z.push(o.outputEncoding),z.push(o.gammaFactor)}return z.push(C.customProgramCacheKey),z.join()}function L(C){const z=b[C.type];let tt;if(z){const W=_n[z];tt=Jg.clone(W.uniforms)}else tt=C.uniforms;return tt}function A(C,z){let tt;for(let W=0,F=h.length;W<F;W++){const rt=h[W];if(rt.cacheKey===z){tt=rt,++tt.usedTimes;break}}return tt===void 0&&(tt=new $0(o,z,C,s),h.push(tt)),tt}function N(C){if(--C.usedTimes===0){const z=h.indexOf(C);h[z]=h[h.length-1],h.pop(),C.destroy()}}return{getParameters:_,getProgramCacheKey:R,getUniforms:L,acquireProgram:A,releaseProgram:N,programs:h}}function tb(){let o=new WeakMap;function t(s){let a=o.get(s);return a===void 0&&(a={},o.set(s,a)),a}function e(s){o.delete(s)}function n(s,a,h){o.get(s)[a]=h}function i(){o=new WeakMap}return{get:t,remove:e,update:n,dispose:i}}function eb(o,t){return o.groupOrder!==t.groupOrder?o.groupOrder-t.groupOrder:o.renderOrder!==t.renderOrder?o.renderOrder-t.renderOrder:o.program!==t.program?o.program.id-t.program.id:o.material.id!==t.material.id?o.material.id-t.material.id:o.z!==t.z?o.z-t.z:o.id-t.id}function vh(o,t){return o.groupOrder!==t.groupOrder?o.groupOrder-t.groupOrder:o.renderOrder!==t.renderOrder?o.renderOrder-t.renderOrder:o.z!==t.z?t.z-o.z:o.id-t.id}function _h(o){const t=[];let e=0;const n=[],i=[],s=[],a={id:-1};function h(){e=0,n.length=0,i.length=0,s.length=0}function u(v,b,y,M,x,_){let R=t[e];const L=o.get(y);return R===void 0?(R={id:v.id,object:v,geometry:b,material:y,program:L.program||a,groupOrder:M,renderOrder:v.renderOrder,z:x,group:_},t[e]=R):(R.id=v.id,R.object=v,R.geometry=b,R.material=y,R.program=L.program||a,R.groupOrder=M,R.renderOrder=v.renderOrder,R.z=x,R.group=_),e++,R}function d(v,b,y,M,x,_){const R=u(v,b,y,M,x,_);y.transmission>0?i.push(R):y.transparent===!0?s.push(R):n.push(R)}function f(v,b,y,M,x,_){const R=u(v,b,y,M,x,_);y.transmission>0?i.unshift(R):y.transparent===!0?s.unshift(R):n.unshift(R)}function g(v,b){n.length>1&&n.sort(v||eb),i.length>1&&i.sort(b||vh),s.length>1&&s.sort(b||vh)}function m(){for(let v=e,b=t.length;v<b;v++){const y=t[v];if(y.id===null)break;y.id=null,y.object=null,y.geometry=null,y.material=null,y.program=null,y.group=null}}return{opaque:n,transmissive:i,transparent:s,init:h,push:d,unshift:f,finish:m,sort:g}}function nb(o){let t=new WeakMap;function e(i,s){let a;return t.has(i)===!1?(a=new _h(o),t.set(i,[a])):s>=t.get(i).length?(a=new _h(o),t.get(i).push(a)):a=t.get(i)[s],a}function n(){t=new WeakMap}return{get:e,dispose:n}}function ib(){const o={};return{get:function(t){if(o[t.id]!==void 0)return o[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new T,color:new wt};break;case"SpotLight":e={position:new T,direction:new T,color:new wt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new T,color:new wt,distance:0,decay:0};break;case"HemisphereLight":e={direction:new T,skyColor:new wt,groundColor:new wt};break;case"RectAreaLight":e={color:new wt,position:new T,halfWidth:new T,halfHeight:new T};break}return o[t.id]=e,e}}}function rb(){const o={};return{get:function(t){if(o[t.id]!==void 0)return o[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new it};break;case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new it};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new it,shadowCameraNear:1,shadowCameraFar:1e3};break}return o[t.id]=e,e}}}let sb=0;function ob(o,t){return(t.castShadow?1:0)-(o.castShadow?1:0)}function ab(o,t){const e=new ib,n=rb(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let f=0;f<9;f++)i.probe.push(new T);const s=new T,a=new It,h=new It;function u(f,g){let m=0,v=0,b=0;for(let tt=0;tt<9;tt++)i.probe[tt].set(0,0,0);let y=0,M=0,x=0,_=0,R=0,L=0,A=0,N=0;f.sort(ob);const C=g!==!0?Math.PI:1;for(let tt=0,W=f.length;tt<W;tt++){const F=f[tt],rt=F.color,H=F.intensity,G=F.distance,j=F.shadow&&F.shadow.map?F.shadow.map.texture:null;if(F.isAmbientLight)m+=rt.r*H*C,v+=rt.g*H*C,b+=rt.b*H*C;else if(F.isLightProbe)for(let B=0;B<9;B++)i.probe[B].addScaledVector(F.sh.coefficients[B],H);else if(F.isDirectionalLight){const B=e.get(F);if(B.color.copy(F.color).multiplyScalar(F.intensity*C),F.castShadow){const K=F.shadow,at=n.get(F);at.shadowBias=K.bias,at.shadowNormalBias=K.normalBias,at.shadowRadius=K.radius,at.shadowMapSize=K.mapSize,i.directionalShadow[y]=at,i.directionalShadowMap[y]=j,i.directionalShadowMatrix[y]=F.shadow.matrix,L++}i.directional[y]=B,y++}else if(F.isSpotLight){const B=e.get(F);if(B.position.setFromMatrixPosition(F.matrixWorld),B.color.copy(rt).multiplyScalar(H*C),B.distance=G,B.coneCos=Math.cos(F.angle),B.penumbraCos=Math.cos(F.angle*(1-F.penumbra)),B.decay=F.decay,F.castShadow){const K=F.shadow,at=n.get(F);at.shadowBias=K.bias,at.shadowNormalBias=K.normalBias,at.shadowRadius=K.radius,at.shadowMapSize=K.mapSize,i.spotShadow[x]=at,i.spotShadowMap[x]=j,i.spotShadowMatrix[x]=F.shadow.matrix,N++}i.spot[x]=B,x++}else if(F.isRectAreaLight){const B=e.get(F);B.color.copy(rt).multiplyScalar(H),B.halfWidth.set(F.width*.5,0,0),B.halfHeight.set(0,F.height*.5,0),i.rectArea[_]=B,_++}else if(F.isPointLight){const B=e.get(F);if(B.color.copy(F.color).multiplyScalar(F.intensity*C),B.distance=F.distance,B.decay=F.decay,F.castShadow){const K=F.shadow,at=n.get(F);at.shadowBias=K.bias,at.shadowNormalBias=K.normalBias,at.shadowRadius=K.radius,at.shadowMapSize=K.mapSize,at.shadowCameraNear=K.camera.near,at.shadowCameraFar=K.camera.far,i.pointShadow[M]=at,i.pointShadowMap[M]=j,i.pointShadowMatrix[M]=F.shadow.matrix,A++}i.point[M]=B,M++}else if(F.isHemisphereLight){const B=e.get(F);B.skyColor.copy(F.color).multiplyScalar(H*C),B.groundColor.copy(F.groundColor).multiplyScalar(H*C),i.hemi[R]=B,R++}}_>0&&(t.isWebGL2||o.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=ft.LTC_FLOAT_1,i.rectAreaLTC2=ft.LTC_FLOAT_2):o.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=ft.LTC_HALF_1,i.rectAreaLTC2=ft.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=m,i.ambient[1]=v,i.ambient[2]=b;const z=i.hash;(z.directionalLength!==y||z.pointLength!==M||z.spotLength!==x||z.rectAreaLength!==_||z.hemiLength!==R||z.numDirectionalShadows!==L||z.numPointShadows!==A||z.numSpotShadows!==N)&&(i.directional.length=y,i.spot.length=x,i.rectArea.length=_,i.point.length=M,i.hemi.length=R,i.directionalShadow.length=L,i.directionalShadowMap.length=L,i.pointShadow.length=A,i.pointShadowMap.length=A,i.spotShadow.length=N,i.spotShadowMap.length=N,i.directionalShadowMatrix.length=L,i.pointShadowMatrix.length=A,i.spotShadowMatrix.length=N,z.directionalLength=y,z.pointLength=M,z.spotLength=x,z.rectAreaLength=_,z.hemiLength=R,z.numDirectionalShadows=L,z.numPointShadows=A,z.numSpotShadows=N,i.version=sb++)}function d(f,g){let m=0,v=0,b=0,y=0,M=0;const x=g.matrixWorldInverse;for(let _=0,R=f.length;_<R;_++){const L=f[_];if(L.isDirectionalLight){const A=i.directional[m];A.direction.setFromMatrixPosition(L.matrixWorld),s.setFromMatrixPosition(L.target.matrixWorld),A.direction.sub(s),A.direction.transformDirection(x),m++}else if(L.isSpotLight){const A=i.spot[b];A.position.setFromMatrixPosition(L.matrixWorld),A.position.applyMatrix4(x),A.direction.setFromMatrixPosition(L.matrixWorld),s.setFromMatrixPosition(L.target.matrixWorld),A.direction.sub(s),A.direction.transformDirection(x),b++}else if(L.isRectAreaLight){const A=i.rectArea[y];A.position.setFromMatrixPosition(L.matrixWorld),A.position.applyMatrix4(x),h.identity(),a.copy(L.matrixWorld),a.premultiply(x),h.extractRotation(a),A.halfWidth.set(L.width*.5,0,0),A.halfHeight.set(0,L.height*.5,0),A.halfWidth.applyMatrix4(h),A.halfHeight.applyMatrix4(h),y++}else if(L.isPointLight){const A=i.point[v];A.position.setFromMatrixPosition(L.matrixWorld),A.position.applyMatrix4(x),v++}else if(L.isHemisphereLight){const A=i.hemi[M];A.direction.setFromMatrixPosition(L.matrixWorld),A.direction.transformDirection(x),A.direction.normalize(),M++}}}return{setup:u,setupView:d,state:i}}function xh(o,t){const e=new ab(o,t),n=[],i=[];function s(){n.length=0,i.length=0}function a(g){n.push(g)}function h(g){i.push(g)}function u(g){e.setup(n,g)}function d(g){e.setupView(n,g)}return{init:s,state:{lightsArray:n,shadowsArray:i,lights:e},setupLights:u,setupLightsView:d,pushLight:a,pushShadow:h}}function lb(o,t){let e=new WeakMap;function n(s,a=0){let h;return e.has(s)===!1?(h=new xh(o,t),e.set(s,[h])):a>=e.get(s).length?(h=new xh(o,t),e.get(s).push(h)):h=e.get(s)[a],h}function i(){e=new WeakMap}return{get:n,dispose:i}}class Du extends Pe{constructor(t){super(),this.type="MeshDepthMaterial",this.depthPacking=Dg,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}Du.prototype.isMeshDepthMaterial=!0;class Iu extends Pe{constructor(t){super(),this.type="MeshDistanceMaterial",this.referencePosition=new T,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}Iu.prototype.isMeshDistanceMaterial=!0;var cb=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
uniform float samples;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,hb=`void main() {
	gl_Position = vec4( position, 1.0 );
}`;function Nu(o,t,e){let n=new wo;const i=new it,s=new it,a=new te,h=new Du({depthPacking:Ig}),u=new Iu,d={},f=e.maxTextureSize,g={0:me,1:Qr,2:hr},m=new vi({uniforms:{shadow_pass:{value:null},resolution:{value:new it},radius:{value:4},samples:{value:8}},vertexShader:hb,fragmentShader:cb}),v=m.clone();v.defines.HORIZONTAL_PASS=1;const b=new $t;b.setAttribute("position",new ge(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const y=new xe(b,m),M=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=ru,this.render=function(L,A,N){if(M.enabled===!1||M.autoUpdate===!1&&M.needsUpdate===!1||L.length===0)return;const C=o.getRenderTarget(),z=o.getActiveCubeFace(),tt=o.getActiveMipmapLevel(),W=o.state;W.setBlending(jn),W.buffers.color.setClear(1,1,1,1),W.buffers.depth.setTest(!0),W.setScissorTest(!1);for(let F=0,rt=L.length;F<rt;F++){const H=L[F],G=H.shadow;if(G===void 0){console.warn("THREE.WebGLShadowMap:",H,"has no shadow.");continue}if(G.autoUpdate===!1&&G.needsUpdate===!1)continue;i.copy(G.mapSize);const j=G.getFrameExtents();if(i.multiply(j),s.copy(G.mapSize),(i.x>f||i.y>f)&&(i.x>f&&(s.x=Math.floor(f/j.x),i.x=s.x*j.x,G.mapSize.x=s.x),i.y>f&&(s.y=Math.floor(f/j.y),i.y=s.y*j.y,G.mapSize.y=s.y)),G.map===null&&!G.isPointLightShadow&&this.type===jr){const K={minFilter:en,magFilter:en,format:Ye};G.map=new yn(i.x,i.y,K),G.map.texture.name=H.name+".shadowMap",G.mapPass=new yn(i.x,i.y,K),G.camera.updateProjectionMatrix()}if(G.map===null){const K={minFilter:_e,magFilter:_e,format:Ye};G.map=new yn(i.x,i.y,K),G.map.texture.name=H.name+".shadowMap",G.camera.updateProjectionMatrix()}o.setRenderTarget(G.map),o.clear();const B=G.getViewportCount();for(let K=0;K<B;K++){const at=G.getViewport(K);a.set(s.x*at.x,s.y*at.y,s.x*at.z,s.y*at.w),W.viewport(a),G.updateMatrices(H,K),n=G.getFrustum(),R(A,N,G.camera,H,this.type)}!G.isPointLightShadow&&this.type===jr&&x(G,N),G.needsUpdate=!1}M.needsUpdate=!1,o.setRenderTarget(C,z,tt)};function x(L,A){const N=t.update(y);m.uniforms.shadow_pass.value=L.map.texture,m.uniforms.resolution.value=L.mapSize,m.uniforms.radius.value=L.radius,m.uniforms.samples.value=L.blurSamples,o.setRenderTarget(L.mapPass),o.clear(),o.renderBufferDirect(A,null,N,m,y,null),v.uniforms.shadow_pass.value=L.mapPass.texture,v.uniforms.resolution.value=L.mapSize,v.uniforms.radius.value=L.radius,v.uniforms.samples.value=L.blurSamples,o.setRenderTarget(L.map),o.clear(),o.renderBufferDirect(A,null,N,v,y,null)}function _(L,A,N,C,z,tt,W){let F=null;const rt=C.isPointLight===!0?L.customDistanceMaterial:L.customDepthMaterial;if(rt!==void 0?F=rt:F=C.isPointLight===!0?u:h,o.localClippingEnabled&&N.clipShadows===!0&&N.clippingPlanes.length!==0||N.displacementMap&&N.displacementScale!==0||N.alphaMap&&N.alphaTest>0){const H=F.uuid,G=N.uuid;let j=d[H];j===void 0&&(j={},d[H]=j);let B=j[G];B===void 0&&(B=F.clone(),j[G]=B),F=B}return F.visible=N.visible,F.wireframe=N.wireframe,W===jr?F.side=N.shadowSide!==null?N.shadowSide:N.side:F.side=N.shadowSide!==null?N.shadowSide:g[N.side],F.alphaMap=N.alphaMap,F.alphaTest=N.alphaTest,F.clipShadows=N.clipShadows,F.clippingPlanes=N.clippingPlanes,F.clipIntersection=N.clipIntersection,F.displacementMap=N.displacementMap,F.displacementScale=N.displacementScale,F.displacementBias=N.displacementBias,F.wireframeLinewidth=N.wireframeLinewidth,F.linewidth=N.linewidth,C.isPointLight===!0&&F.isMeshDistanceMaterial===!0&&(F.referencePosition.setFromMatrixPosition(C.matrixWorld),F.nearDistance=z,F.farDistance=tt),F}function R(L,A,N,C,z){if(L.visible===!1)return;if(L.layers.test(A.layers)&&(L.isMesh||L.isLine||L.isPoints)&&(L.castShadow||L.receiveShadow&&z===jr)&&(!L.frustumCulled||n.intersectsObject(L))){L.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse,L.matrixWorld);const F=t.update(L),rt=L.material;if(Array.isArray(rt)){const H=F.groups;for(let G=0,j=H.length;G<j;G++){const B=H[G],K=rt[B.materialIndex];if(K&&K.visible){const at=_(L,F,K,C,N.near,N.far,z);o.renderBufferDirect(N,null,F,at,L,B)}}}else if(rt.visible){const H=_(L,F,rt,C,N.near,N.far,z);o.renderBufferDirect(N,null,F,H,L,null)}}const W=L.children;for(let F=0,rt=W.length;F<rt;F++)R(W[F],A,N,C,z)}}function ub(o,t,e){const n=e.isWebGL2;function i(){let k=!1;const pt=new te;let $=null;const gt=new te(0,0,0,0);return{setMask:function(D){$!==D&&!k&&(o.colorMask(D,D,D,D),$=D)},setLocked:function(D){k=D},setClear:function(D,ot,zt,Ut,ie){ie===!0&&(D*=Ut,ot*=Ut,zt*=Ut),pt.set(D,ot,zt,Ut),gt.equals(pt)===!1&&(o.clearColor(D,ot,zt,Ut),gt.copy(pt))},reset:function(){k=!1,$=null,gt.set(-1,0,0,0)}}}function s(){let k=!1,pt=null,$=null,gt=null;return{setTest:function(D){D?st(2929):Mt(2929)},setMask:function(D){pt!==D&&!k&&(o.depthMask(D),pt=D)},setFunc:function(D){if($!==D){if(D)switch(D){case bm:o.depthFunc(512);break;case ym:o.depthFunc(519);break;case wm:o.depthFunc(513);break;case Ja:o.depthFunc(515);break;case Mm:o.depthFunc(514);break;case Sm:o.depthFunc(518);break;case Em:o.depthFunc(516);break;case Tm:o.depthFunc(517);break;default:o.depthFunc(515)}else o.depthFunc(515);$=D}},setLocked:function(D){k=D},setClear:function(D){gt!==D&&(o.clearDepth(D),gt=D)},reset:function(){k=!1,pt=null,$=null,gt=null}}}function a(){let k=!1,pt=null,$=null,gt=null,D=null,ot=null,zt=null,Ut=null,ie=null;return{setTest:function(Kt){k||(Kt?st(2960):Mt(2960))},setMask:function(Kt){pt!==Kt&&!k&&(o.stencilMask(Kt),pt=Kt)},setFunc:function(Kt,Se,ke){($!==Kt||gt!==Se||D!==ke)&&(o.stencilFunc(Kt,Se,ke),$=Kt,gt=Se,D=ke)},setOp:function(Kt,Se,ke){(ot!==Kt||zt!==Se||Ut!==ke)&&(o.stencilOp(Kt,Se,ke),ot=Kt,zt=Se,Ut=ke)},setLocked:function(Kt){k=Kt},setClear:function(Kt){ie!==Kt&&(o.clearStencil(Kt),ie=Kt)},reset:function(){k=!1,pt=null,$=null,gt=null,D=null,ot=null,zt=null,Ut=null,ie=null}}}const h=new i,u=new s,d=new a;let f={},g=null,m={},v=null,b=!1,y=null,M=null,x=null,_=null,R=null,L=null,A=null,N=!1,C=null,z=null,tt=null,W=null,F=null;const rt=o.getParameter(35661);let H=!1,G=0;const j=o.getParameter(7938);j.indexOf("WebGL")!==-1?(G=parseFloat(/^WebGL (\d)/.exec(j)[1]),H=G>=1):j.indexOf("OpenGL ES")!==-1&&(G=parseFloat(/^OpenGL ES (\d)/.exec(j)[1]),H=G>=2);let B=null,K={};const at=o.getParameter(3088),yt=o.getParameter(2978),bt=new te().fromArray(at),mt=new te().fromArray(yt);function vt(k,pt,$){const gt=new Uint8Array(4),D=o.createTexture();o.bindTexture(k,D),o.texParameteri(k,10241,9728),o.texParameteri(k,10240,9728);for(let ot=0;ot<$;ot++)o.texImage2D(pt+ot,0,6408,1,1,0,6408,5121,gt);return D}const J={};J[3553]=vt(3553,3553,1),J[34067]=vt(34067,34069,6),h.setClear(0,0,0,1),u.setClear(1),d.setClear(0),st(2929),u.setFunc(Ja),nt(!1),lt(wc),st(2884),kt(jn);function st(k){f[k]!==!0&&(o.enable(k),f[k]=!0)}function Mt(k){f[k]!==!1&&(o.disable(k),f[k]=!1)}function q(k){k!==g&&(o.bindFramebuffer(36160,k),g=k)}function Ct(k,pt){return pt===null&&g!==null&&(pt=g),m[k]!==pt?(o.bindFramebuffer(k,pt),m[k]=pt,n&&(k===36009&&(m[36160]=pt),k===36160&&(m[36009]=pt)),!0):!1}function At(k){return v!==k?(o.useProgram(k),v=k,!0):!1}const dt={[Qi]:32774,[cm]:32778,[hm]:32779};if(n)dt[Tc]=32775,dt[Cc]=32776;else{const k=t.get("EXT_blend_minmax");k!==null&&(dt[Tc]=k.MIN_EXT,dt[Cc]=k.MAX_EXT)}const xt={[um]:0,[dm]:1,[pm]:768,[ou]:770,[xm]:776,[vm]:774,[mm]:772,[fm]:769,[au]:771,[_m]:775,[gm]:773};function kt(k,pt,$,gt,D,ot,zt,Ut){if(k===jn){b===!0&&(Mt(3042),b=!1);return}if(b===!1&&(st(3042),b=!0),k!==lm){if(k!==y||Ut!==N){if((M!==Qi||R!==Qi)&&(o.blendEquation(32774),M=Qi,R=Qi),Ut)switch(k){case Zr:o.blendFuncSeparate(1,771,1,771);break;case Mc:o.blendFunc(1,1);break;case Sc:o.blendFuncSeparate(0,0,769,771);break;case Ec:o.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",k);break}else switch(k){case Zr:o.blendFuncSeparate(770,771,1,771);break;case Mc:o.blendFunc(770,1);break;case Sc:o.blendFunc(0,769);break;case Ec:o.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",k);break}x=null,_=null,L=null,A=null,y=k,N=Ut}return}D=D||pt,ot=ot||$,zt=zt||gt,(pt!==M||D!==R)&&(o.blendEquationSeparate(dt[pt],dt[D]),M=pt,R=D),($!==x||gt!==_||ot!==L||zt!==A)&&(o.blendFuncSeparate(xt[$],xt[gt],xt[ot],xt[zt]),x=$,_=gt,L=ot,A=zt),y=k,N=null}function Z(k,pt){k.side===hr?Mt(2884):st(2884);let $=k.side===me;pt&&($=!$),nt($),k.blending===Zr&&k.transparent===!1?kt(jn):kt(k.blending,k.blendEquation,k.blendSrc,k.blendDst,k.blendEquationAlpha,k.blendSrcAlpha,k.blendDstAlpha,k.premultipliedAlpha),u.setFunc(k.depthFunc),u.setTest(k.depthTest),u.setMask(k.depthWrite),h.setMask(k.colorWrite);const gt=k.stencilWrite;d.setTest(gt),gt&&(d.setMask(k.stencilWriteMask),d.setFunc(k.stencilFunc,k.stencilRef,k.stencilFuncMask),d.setOp(k.stencilFail,k.stencilZFail,k.stencilZPass)),ut(k.polygonOffset,k.polygonOffsetFactor,k.polygonOffsetUnits),k.alphaToCoverage===!0?st(32926):Mt(32926)}function nt(k){C!==k&&(k?o.frontFace(2304):o.frontFace(2305),C=k)}function lt(k){k!==sm?(st(2884),k!==z&&(k===wc?o.cullFace(1029):k===om?o.cullFace(1028):o.cullFace(1032))):Mt(2884),z=k}function St(k){k!==tt&&(H&&o.lineWidth(k),tt=k)}function ut(k,pt,$){k?(st(32823),(W!==pt||F!==$)&&(o.polygonOffset(pt,$),W=pt,F=$)):Mt(32823)}function P(k){k?st(3089):Mt(3089)}function E(k){k===void 0&&(k=33984+rt-1),B!==k&&(o.activeTexture(k),B=k)}function Y(k,pt){B===null&&E();let $=K[B];$===void 0&&($={type:void 0,texture:void 0},K[B]=$),($.type!==k||$.texture!==pt)&&(o.bindTexture(k,pt||J[k]),$.type=k,$.texture=pt)}function Q(){const k=K[B];k!==void 0&&k.type!==void 0&&(o.bindTexture(k.type,null),k.type=void 0,k.texture=void 0)}function ht(){try{o.compressedTexImage2D.apply(o,arguments)}catch(k){console.error("THREE.WebGLState:",k)}}function _t(){try{o.texImage2D.apply(o,arguments)}catch(k){console.error("THREE.WebGLState:",k)}}function Lt(){try{o.texImage3D.apply(o,arguments)}catch(k){console.error("THREE.WebGLState:",k)}}function Et(k){bt.equals(k)===!1&&(o.scissor(k.x,k.y,k.z,k.w),bt.copy(k))}function Nt(k){mt.equals(k)===!1&&(o.viewport(k.x,k.y,k.z,k.w),mt.copy(k))}function Tt(){o.disable(3042),o.disable(2884),o.disable(2929),o.disable(32823),o.disable(3089),o.disable(2960),o.disable(32926),o.blendEquation(32774),o.blendFunc(1,0),o.blendFuncSeparate(1,0,1,0),o.colorMask(!0,!0,!0,!0),o.clearColor(0,0,0,0),o.depthMask(!0),o.depthFunc(513),o.clearDepth(1),o.stencilMask(4294967295),o.stencilFunc(519,0,4294967295),o.stencilOp(7680,7680,7680),o.clearStencil(0),o.cullFace(1029),o.frontFace(2305),o.polygonOffset(0,0),o.activeTexture(33984),o.bindFramebuffer(36160,null),n===!0&&(o.bindFramebuffer(36009,null),o.bindFramebuffer(36008,null)),o.useProgram(null),o.lineWidth(1),o.scissor(0,0,o.canvas.width,o.canvas.height),o.viewport(0,0,o.canvas.width,o.canvas.height),f={},B=null,K={},g=null,m={},v=null,b=!1,y=null,M=null,x=null,_=null,R=null,L=null,A=null,N=!1,C=null,z=null,tt=null,W=null,F=null,bt.set(0,0,o.canvas.width,o.canvas.height),mt.set(0,0,o.canvas.width,o.canvas.height),h.reset(),u.reset(),d.reset()}return{buffers:{color:h,depth:u,stencil:d},enable:st,disable:Mt,bindFramebuffer:Ct,bindXRFramebuffer:q,useProgram:At,setBlending:kt,setMaterial:Z,setFlipSided:nt,setCullFace:lt,setLineWidth:St,setPolygonOffset:ut,setScissorTest:P,activeTexture:E,bindTexture:Y,unbindTexture:Q,compressedTexImage2D:ht,texImage2D:_t,texImage3D:Lt,scissor:Et,viewport:Nt,reset:Tt}}function db(o,t,e,n,i,s,a){const h=i.isWebGL2,u=i.maxTextures,d=i.maxCubemapSize,f=i.maxTextureSize,g=i.maxSamples,m=new WeakMap;let v,b=!1;try{b=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function y(P,E){return b?new OffscreenCanvas(P,E):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function M(P,E,Y,Q){let ht=1;if((P.width>Q||P.height>Q)&&(ht=Q/Math.max(P.width,P.height)),ht<1||E===!0)if(typeof HTMLImageElement!="undefined"&&P instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&P instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&P instanceof ImageBitmap){const _t=E?Bg:Math.floor,Lt=_t(ht*P.width),Et=_t(ht*P.height);v===void 0&&(v=y(Lt,Et));const Nt=Y?y(Lt,Et):v;return Nt.width=Lt,Nt.height=Et,Nt.getContext("2d").drawImage(P,0,0,Lt,Et),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+P.width+"x"+P.height+") to ("+Lt+"x"+Et+")."),Nt}else return"data"in P&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+P.width+"x"+P.height+")."),P;return P}function x(P){return Uc(P.width)&&Uc(P.height)}function _(P){return h?!1:P.wrapS!==Xe||P.wrapT!==Xe||P.minFilter!==_e&&P.minFilter!==en}function R(P,E){return P.generateMipmaps&&E&&P.minFilter!==_e&&P.minFilter!==en}function L(P,E,Y,Q,ht=1){o.generateMipmap(P);const _t=n.get(E);_t.__maxMipLevel=Math.log2(Math.max(Y,Q,ht))}function A(P,E,Y){if(h===!1)return E;if(P!==null){if(o[P]!==void 0)return o[P];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+P+"'")}let Q=E;return E===6403&&(Y===5126&&(Q=33326),Y===5131&&(Q=33325),Y===5121&&(Q=33321)),E===6407&&(Y===5126&&(Q=34837),Y===5131&&(Q=34843),Y===5121&&(Q=32849)),E===6408&&(Y===5126&&(Q=34836),Y===5131&&(Q=34842),Y===5121&&(Q=32856)),(Q===33325||Q===33326||Q===34842||Q===34836)&&t.get("EXT_color_buffer_float"),Q}function N(P){return P===_e||P===Ac||P===Pc?9728:9729}function C(P){const E=P.target;E.removeEventListener("dispose",C),tt(E),E.isVideoTexture&&m.delete(E),a.memory.textures--}function z(P){const E=P.target;E.removeEventListener("dispose",z),W(E)}function tt(P){const E=n.get(P);E.__webglInit!==void 0&&(o.deleteTexture(E.__webglTexture),n.remove(P))}function W(P){const E=P.texture,Y=n.get(P),Q=n.get(E);if(!!P){if(Q.__webglTexture!==void 0&&(o.deleteTexture(Q.__webglTexture),a.memory.textures--),P.depthTexture&&P.depthTexture.dispose(),P.isWebGLCubeRenderTarget)for(let ht=0;ht<6;ht++)o.deleteFramebuffer(Y.__webglFramebuffer[ht]),Y.__webglDepthbuffer&&o.deleteRenderbuffer(Y.__webglDepthbuffer[ht]);else o.deleteFramebuffer(Y.__webglFramebuffer),Y.__webglDepthbuffer&&o.deleteRenderbuffer(Y.__webglDepthbuffer),Y.__webglMultisampledFramebuffer&&o.deleteFramebuffer(Y.__webglMultisampledFramebuffer),Y.__webglColorRenderbuffer&&o.deleteRenderbuffer(Y.__webglColorRenderbuffer),Y.__webglDepthRenderbuffer&&o.deleteRenderbuffer(Y.__webglDepthRenderbuffer);if(P.isWebGLMultipleRenderTargets)for(let ht=0,_t=E.length;ht<_t;ht++){const Lt=n.get(E[ht]);Lt.__webglTexture&&(o.deleteTexture(Lt.__webglTexture),a.memory.textures--),n.remove(E[ht])}n.remove(E),n.remove(P)}}let F=0;function rt(){F=0}function H(){const P=F;return P>=u&&console.warn("THREE.WebGLTextures: Trying to use "+P+" texture units while this GPU supports only "+u),F+=1,P}function G(P,E){const Y=n.get(P);if(P.isVideoTexture&&Z(P),P.version>0&&Y.__version!==P.version){const Q=P.image;if(Q===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(Q.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{vt(Y,P,E);return}}e.activeTexture(33984+E),e.bindTexture(3553,Y.__webglTexture)}function j(P,E){const Y=n.get(P);if(P.version>0&&Y.__version!==P.version){vt(Y,P,E);return}e.activeTexture(33984+E),e.bindTexture(35866,Y.__webglTexture)}function B(P,E){const Y=n.get(P);if(P.version>0&&Y.__version!==P.version){vt(Y,P,E);return}e.activeTexture(33984+E),e.bindTexture(32879,Y.__webglTexture)}function K(P,E){const Y=n.get(P);if(P.version>0&&Y.__version!==P.version){J(Y,P,E);return}e.activeTexture(33984+E),e.bindTexture(34067,Y.__webglTexture)}const at={[tl]:10497,[Xe]:33071,[el]:33648},yt={[_e]:9728,[Ac]:9984,[Pc]:9986,[en]:9729,[Nm]:9985,[xo]:9987};function bt(P,E,Y){if(Y?(o.texParameteri(P,10242,at[E.wrapS]),o.texParameteri(P,10243,at[E.wrapT]),(P===32879||P===35866)&&o.texParameteri(P,32882,at[E.wrapR]),o.texParameteri(P,10240,yt[E.magFilter]),o.texParameteri(P,10241,yt[E.minFilter])):(o.texParameteri(P,10242,33071),o.texParameteri(P,10243,33071),(P===32879||P===35866)&&o.texParameteri(P,32882,33071),(E.wrapS!==Xe||E.wrapT!==Xe)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),o.texParameteri(P,10240,N(E.magFilter)),o.texParameteri(P,10241,N(E.minFilter)),E.minFilter!==_e&&E.minFilter!==en&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const Q=t.get("EXT_texture_filter_anisotropic");if(E.type===fi&&t.has("OES_texture_float_linear")===!1||h===!1&&E.type===sr&&t.has("OES_texture_half_float_linear")===!1)return;(E.anisotropy>1||n.get(E).__currentAnisotropy)&&(o.texParameterf(P,Q.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(E.anisotropy,i.getMaxAnisotropy())),n.get(E).__currentAnisotropy=E.anisotropy)}}function mt(P,E){P.__webglInit===void 0&&(P.__webglInit=!0,E.addEventListener("dispose",C),P.__webglTexture=o.createTexture(),a.memory.textures++)}function vt(P,E,Y){let Q=3553;E.isDataTexture2DArray&&(Q=35866),E.isDataTexture3D&&(Q=32879),mt(P,E),e.activeTexture(33984+Y),e.bindTexture(Q,P.__webglTexture),o.pixelStorei(37440,E.flipY),o.pixelStorei(37441,E.premultiplyAlpha),o.pixelStorei(3317,E.unpackAlignment),o.pixelStorei(37443,0);const ht=_(E)&&x(E.image)===!1,_t=M(E.image,ht,!1,f),Lt=x(_t)||h,Et=s.convert(E.format);let Nt=s.convert(E.type),Tt=A(E.internalFormat,Et,Nt);bt(Q,E,Lt);let k;const pt=E.mipmaps;if(E.isDepthTexture)Tt=6402,h?E.type===fi?Tt=36012:E.type===ro?Tt=33190:E.type===Kr?Tt=35056:Tt=33189:E.type===fi&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),E.format===or&&Tt===6402&&E.type!==oo&&E.type!==ro&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),E.type=oo,Nt=s.convert(E.type)),E.format===ts&&Tt===6402&&(Tt=34041,E.type!==Kr&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),E.type=Kr,Nt=s.convert(E.type))),e.texImage2D(3553,0,Tt,_t.width,_t.height,0,Et,Nt,null);else if(E.isDataTexture)if(pt.length>0&&Lt){for(let $=0,gt=pt.length;$<gt;$++)k=pt[$],e.texImage2D(3553,$,Tt,k.width,k.height,0,Et,Nt,k.data);E.generateMipmaps=!1,P.__maxMipLevel=pt.length-1}else e.texImage2D(3553,0,Tt,_t.width,_t.height,0,Et,Nt,_t.data),P.__maxMipLevel=0;else if(E.isCompressedTexture){for(let $=0,gt=pt.length;$<gt;$++)k=pt[$],E.format!==Ye&&E.format!==Xn?Et!==null?e.compressedTexImage2D(3553,$,Tt,k.width,k.height,0,k.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):e.texImage2D(3553,$,Tt,k.width,k.height,0,Et,Nt,k.data);P.__maxMipLevel=pt.length-1}else if(E.isDataTexture2DArray)e.texImage3D(35866,0,Tt,_t.width,_t.height,_t.depth,0,Et,Nt,_t.data),P.__maxMipLevel=0;else if(E.isDataTexture3D)e.texImage3D(32879,0,Tt,_t.width,_t.height,_t.depth,0,Et,Nt,_t.data),P.__maxMipLevel=0;else if(pt.length>0&&Lt){for(let $=0,gt=pt.length;$<gt;$++)k=pt[$],e.texImage2D(3553,$,Tt,Et,Nt,k);E.generateMipmaps=!1,P.__maxMipLevel=pt.length-1}else e.texImage2D(3553,0,Tt,Et,Nt,_t),P.__maxMipLevel=0;R(E,Lt)&&L(Q,E,_t.width,_t.height),P.__version=E.version,E.onUpdate&&E.onUpdate(E)}function J(P,E,Y){if(E.image.length!==6)return;mt(P,E),e.activeTexture(33984+Y),e.bindTexture(34067,P.__webglTexture),o.pixelStorei(37440,E.flipY),o.pixelStorei(37441,E.premultiplyAlpha),o.pixelStorei(3317,E.unpackAlignment),o.pixelStorei(37443,0);const Q=E&&(E.isCompressedTexture||E.image[0].isCompressedTexture),ht=E.image[0]&&E.image[0].isDataTexture,_t=[];for(let $=0;$<6;$++)!Q&&!ht?_t[$]=M(E.image[$],!1,!0,d):_t[$]=ht?E.image[$].image:E.image[$];const Lt=_t[0],Et=x(Lt)||h,Nt=s.convert(E.format),Tt=s.convert(E.type),k=A(E.internalFormat,Nt,Tt);bt(34067,E,Et);let pt;if(Q){for(let $=0;$<6;$++){pt=_t[$].mipmaps;for(let gt=0;gt<pt.length;gt++){const D=pt[gt];E.format!==Ye&&E.format!==Xn?Nt!==null?e.compressedTexImage2D(34069+$,gt,k,D.width,D.height,0,D.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):e.texImage2D(34069+$,gt,k,D.width,D.height,0,Nt,Tt,D.data)}}P.__maxMipLevel=pt.length-1}else{pt=E.mipmaps;for(let $=0;$<6;$++)if(ht){e.texImage2D(34069+$,0,k,_t[$].width,_t[$].height,0,Nt,Tt,_t[$].data);for(let gt=0;gt<pt.length;gt++){const ot=pt[gt].image[$].image;e.texImage2D(34069+$,gt+1,k,ot.width,ot.height,0,Nt,Tt,ot.data)}}else{e.texImage2D(34069+$,0,k,Nt,Tt,_t[$]);for(let gt=0;gt<pt.length;gt++){const D=pt[gt];e.texImage2D(34069+$,gt+1,k,Nt,Tt,D.image[$])}}P.__maxMipLevel=pt.length}R(E,Et)&&L(34067,E,Lt.width,Lt.height),P.__version=E.version,E.onUpdate&&E.onUpdate(E)}function st(P,E,Y,Q,ht){const _t=s.convert(Y.format),Lt=s.convert(Y.type),Et=A(Y.internalFormat,_t,Lt);ht===32879||ht===35866?e.texImage3D(ht,0,Et,E.width,E.height,E.depth,0,_t,Lt,null):e.texImage2D(ht,0,Et,E.width,E.height,0,_t,Lt,null),e.bindFramebuffer(36160,P),o.framebufferTexture2D(36160,Q,ht,n.get(Y).__webglTexture,0),e.bindFramebuffer(36160,null)}function Mt(P,E,Y){if(o.bindRenderbuffer(36161,P),E.depthBuffer&&!E.stencilBuffer){let Q=33189;if(Y){const ht=E.depthTexture;ht&&ht.isDepthTexture&&(ht.type===fi?Q=36012:ht.type===ro&&(Q=33190));const _t=kt(E);o.renderbufferStorageMultisample(36161,_t,Q,E.width,E.height)}else o.renderbufferStorage(36161,Q,E.width,E.height);o.framebufferRenderbuffer(36160,36096,36161,P)}else if(E.depthBuffer&&E.stencilBuffer){if(Y){const Q=kt(E);o.renderbufferStorageMultisample(36161,Q,35056,E.width,E.height)}else o.renderbufferStorage(36161,34041,E.width,E.height);o.framebufferRenderbuffer(36160,33306,36161,P)}else{const Q=E.isWebGLMultipleRenderTargets===!0?E.texture[0]:E.texture,ht=s.convert(Q.format),_t=s.convert(Q.type),Lt=A(Q.internalFormat,ht,_t);if(Y){const Et=kt(E);o.renderbufferStorageMultisample(36161,Et,Lt,E.width,E.height)}else o.renderbufferStorage(36161,Lt,E.width,E.height)}o.bindRenderbuffer(36161,null)}function q(P,E){if(E&&E.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,P),!(E.depthTexture&&E.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(E.depthTexture).__webglTexture||E.depthTexture.image.width!==E.width||E.depthTexture.image.height!==E.height)&&(E.depthTexture.image.width=E.width,E.depthTexture.image.height=E.height,E.depthTexture.needsUpdate=!0),G(E.depthTexture,0);const Q=n.get(E.depthTexture).__webglTexture;if(E.depthTexture.format===or)o.framebufferTexture2D(36160,36096,3553,Q,0);else if(E.depthTexture.format===ts)o.framebufferTexture2D(36160,33306,3553,Q,0);else throw new Error("Unknown depthTexture format")}function Ct(P){const E=n.get(P),Y=P.isWebGLCubeRenderTarget===!0;if(P.depthTexture){if(Y)throw new Error("target.depthTexture not supported in Cube render targets");q(E.__webglFramebuffer,P)}else if(Y){E.__webglDepthbuffer=[];for(let Q=0;Q<6;Q++)e.bindFramebuffer(36160,E.__webglFramebuffer[Q]),E.__webglDepthbuffer[Q]=o.createRenderbuffer(),Mt(E.__webglDepthbuffer[Q],P,!1)}else e.bindFramebuffer(36160,E.__webglFramebuffer),E.__webglDepthbuffer=o.createRenderbuffer(),Mt(E.__webglDepthbuffer,P,!1);e.bindFramebuffer(36160,null)}function At(P){const E=P.texture,Y=n.get(P),Q=n.get(E);P.addEventListener("dispose",z),P.isWebGLMultipleRenderTargets!==!0&&(Q.__webglTexture=o.createTexture(),Q.__version=E.version,a.memory.textures++);const ht=P.isWebGLCubeRenderTarget===!0,_t=P.isWebGLMultipleRenderTargets===!0,Lt=P.isWebGLMultisampleRenderTarget===!0,Et=E.isDataTexture3D||E.isDataTexture2DArray,Nt=x(P)||h;if(h&&E.format===Xn&&(E.type===fi||E.type===sr)&&(E.format=Ye,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),ht){Y.__webglFramebuffer=[];for(let Tt=0;Tt<6;Tt++)Y.__webglFramebuffer[Tt]=o.createFramebuffer()}else if(Y.__webglFramebuffer=o.createFramebuffer(),_t)if(i.drawBuffers){const Tt=P.texture;for(let k=0,pt=Tt.length;k<pt;k++){const $=n.get(Tt[k]);$.__webglTexture===void 0&&($.__webglTexture=o.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(Lt)if(h){Y.__webglMultisampledFramebuffer=o.createFramebuffer(),Y.__webglColorRenderbuffer=o.createRenderbuffer(),o.bindRenderbuffer(36161,Y.__webglColorRenderbuffer);const Tt=s.convert(E.format),k=s.convert(E.type),pt=A(E.internalFormat,Tt,k),$=kt(P);o.renderbufferStorageMultisample(36161,$,pt,P.width,P.height),e.bindFramebuffer(36160,Y.__webglMultisampledFramebuffer),o.framebufferRenderbuffer(36160,36064,36161,Y.__webglColorRenderbuffer),o.bindRenderbuffer(36161,null),P.depthBuffer&&(Y.__webglDepthRenderbuffer=o.createRenderbuffer(),Mt(Y.__webglDepthRenderbuffer,P,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(ht){e.bindTexture(34067,Q.__webglTexture),bt(34067,E,Nt);for(let Tt=0;Tt<6;Tt++)st(Y.__webglFramebuffer[Tt],P,E,36064,34069+Tt);R(E,Nt)&&L(34067,E,P.width,P.height),e.unbindTexture()}else if(_t){const Tt=P.texture;for(let k=0,pt=Tt.length;k<pt;k++){const $=Tt[k],gt=n.get($);e.bindTexture(3553,gt.__webglTexture),bt(3553,$,Nt),st(Y.__webglFramebuffer,P,$,36064+k,3553),R($,Nt)&&L(3553,$,P.width,P.height)}e.unbindTexture()}else{let Tt=3553;Et&&(h?Tt=E.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),e.bindTexture(Tt,Q.__webglTexture),bt(Tt,E,Nt),st(Y.__webglFramebuffer,P,E,36064,Tt),R(E,Nt)&&L(Tt,E,P.width,P.height,P.depth),e.unbindTexture()}P.depthBuffer&&Ct(P)}function dt(P){const E=x(P)||h,Y=P.isWebGLMultipleRenderTargets===!0?P.texture:[P.texture];for(let Q=0,ht=Y.length;Q<ht;Q++){const _t=Y[Q];if(R(_t,E)){const Lt=P.isWebGLCubeRenderTarget?34067:3553,Et=n.get(_t).__webglTexture;e.bindTexture(Lt,Et),L(Lt,_t,P.width,P.height),e.unbindTexture()}}}function xt(P){if(P.isWebGLMultisampleRenderTarget)if(h){const E=P.width,Y=P.height;let Q=16384;P.depthBuffer&&(Q|=256),P.stencilBuffer&&(Q|=1024);const ht=n.get(P);e.bindFramebuffer(36008,ht.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,ht.__webglFramebuffer),o.blitFramebuffer(0,0,E,Y,0,0,E,Y,Q,9728),e.bindFramebuffer(36008,null),e.bindFramebuffer(36009,ht.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function kt(P){return h&&P.isWebGLMultisampleRenderTarget?Math.min(g,P.samples):0}function Z(P){const E=a.render.frame;m.get(P)!==E&&(m.set(P,E),P.update())}let nt=!1,lt=!1;function St(P,E){P&&P.isWebGLRenderTarget&&(nt===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),nt=!0),P=P.texture),G(P,E)}function ut(P,E){P&&P.isWebGLCubeRenderTarget&&(lt===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),lt=!0),P=P.texture),K(P,E)}this.allocateTextureUnit=H,this.resetTextureUnits=rt,this.setTexture2D=G,this.setTexture2DArray=j,this.setTexture3D=B,this.setTextureCube=K,this.setupRenderTarget=At,this.updateRenderTargetMipmap=dt,this.updateMultisampleRenderTarget=xt,this.safeSetTexture2D=St,this.safeSetTextureCube=ut}function pb(o,t,e){const n=e.isWebGL2;function i(s){let a;if(s===ur)return 5121;if(s===Vm)return 32819;if(s===Om)return 32820;if(s===zm)return 33635;if(s===Fm)return 5120;if(s===km)return 5122;if(s===oo)return 5123;if(s===Bm)return 5124;if(s===ro)return 5125;if(s===fi)return 5126;if(s===sr)return n?5131:(a=t.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(s===Um)return 6406;if(s===Xn)return 6407;if(s===Ye)return 6408;if(s===Hm)return 6409;if(s===Gm)return 6410;if(s===or)return 6402;if(s===ts)return 34041;if(s===qm)return 6403;if(s===jm)return 36244;if(s===Xm)return 33319;if(s===Ym)return 33320;if(s===Zm)return 36248;if(s===Km)return 36249;if(s===Lc||s===Rc||s===Dc||s===Ic)if(a=t.get("WEBGL_compressed_texture_s3tc"),a!==null){if(s===Lc)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===Rc)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===Dc)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===Ic)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===Nc||s===Fc||s===kc||s===Bc)if(a=t.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(s===Nc)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===Fc)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===kc)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===Bc)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===Jm)return a=t.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if((s===Vc||s===Oc)&&(a=t.get("WEBGL_compressed_texture_etc"),a!==null)){if(s===Vc)return a.COMPRESSED_RGB8_ETC2;if(s===Oc)return a.COMPRESSED_RGBA8_ETC2_EAC}if(s===$m||s===Qm||s===tg||s===eg||s===ng||s===ig||s===rg||s===sg||s===og||s===ag||s===lg||s===cg||s===hg||s===ug||s===pg||s===fg||s===mg||s===gg||s===vg||s===_g||s===xg||s===bg||s===yg||s===wg||s===Mg||s===Sg||s===Eg||s===Tg)return a=t.get("WEBGL_compressed_texture_astc"),a!==null?s:null;if(s===dg)return a=t.get("EXT_texture_compression_bptc"),a!==null?s:null;if(s===Kr)return n?34042:(a=t.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:i}}class Fu extends Ie{constructor(t=[]){super(),this.cameras=t}}Fu.prototype.isArrayCamera=!0;class Yr extends Zt{constructor(){super(),this.type="Group"}}Yr.prototype.isGroup=!0;const fb={type:"move"};class Na{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Yr,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Yr,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new T,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new T),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Yr,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new T,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new T),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,n){let i=null,s=null,a=null;const h=this._targetRay,u=this._grip,d=this._hand;if(t&&e.session.visibilityState!=="visible-blurred")if(h!==null&&(i=e.getPose(t.targetRaySpace,n),i!==null&&(h.matrix.fromArray(i.transform.matrix),h.matrix.decompose(h.position,h.rotation,h.scale),i.linearVelocity?(h.hasLinearVelocity=!0,h.linearVelocity.copy(i.linearVelocity)):h.hasLinearVelocity=!1,i.angularVelocity?(h.hasAngularVelocity=!0,h.angularVelocity.copy(i.angularVelocity)):h.hasAngularVelocity=!1,this.dispatchEvent(fb))),d&&t.hand){a=!0;for(const y of t.hand.values()){const M=e.getJointPose(y,n);if(d.joints[y.jointName]===void 0){const _=new Yr;_.matrixAutoUpdate=!1,_.visible=!1,d.joints[y.jointName]=_,d.add(_)}const x=d.joints[y.jointName];M!==null&&(x.matrix.fromArray(M.transform.matrix),x.matrix.decompose(x.position,x.rotation,x.scale),x.jointRadius=M.radius),x.visible=M!==null}const f=d.joints["index-finger-tip"],g=d.joints["thumb-tip"],m=f.position.distanceTo(g.position),v=.02,b=.005;d.inputState.pinching&&m>v+b?(d.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!d.inputState.pinching&&m<=v-b&&(d.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else u!==null&&t.gripSpace&&(s=e.getPose(t.gripSpace,n),s!==null&&(u.matrix.fromArray(s.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),s.linearVelocity?(u.hasLinearVelocity=!0,u.linearVelocity.copy(s.linearVelocity)):u.hasLinearVelocity=!1,s.angularVelocity?(u.hasAngularVelocity=!0,u.angularVelocity.copy(s.angularVelocity)):u.hasAngularVelocity=!1));return h!==null&&(h.visible=i!==null),u!==null&&(u.visible=s!==null),d!==null&&(d.visible=a!==null),this}}class mb extends ti{constructor(t,e){super();const n=this,i=t.state;let s=null,a=1,h=null,u="local-floor",d=null,f=null,g=null,m=null,v=null,b=!1,y=null,M=null,x=null,_=null,R=null,L=null;const A=[],N=new Map,C=new Ie;C.layers.enable(1),C.viewport=new te;const z=new Ie;z.layers.enable(2),z.viewport=new te;const tt=[C,z],W=new Fu;W.layers.enable(1),W.layers.enable(2);let F=null,rt=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(J){let st=A[J];return st===void 0&&(st=new Na,A[J]=st),st.getTargetRaySpace()},this.getControllerGrip=function(J){let st=A[J];return st===void 0&&(st=new Na,A[J]=st),st.getGripSpace()},this.getHand=function(J){let st=A[J];return st===void 0&&(st=new Na,A[J]=st),st.getHandSpace()};function H(J){const st=N.get(J.inputSource);st&&st.dispatchEvent({type:J.type,data:J.inputSource})}function G(){N.forEach(function(J,st){J.disconnect(st)}),N.clear(),F=null,rt=null,i.bindXRFramebuffer(null),t.setRenderTarget(t.getRenderTarget()),g&&e.deleteFramebuffer(g),y&&e.deleteFramebuffer(y),M&&e.deleteRenderbuffer(M),x&&e.deleteRenderbuffer(x),g=null,y=null,M=null,x=null,v=null,m=null,f=null,s=null,vt.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(J){a=J,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(J){u=J,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return h},this.getBaseLayer=function(){return m!==null?m:v},this.getBinding=function(){return f},this.getFrame=function(){return _},this.getSession=function(){return s},this.setSession=async function(J){if(s=J,s!==null){s.addEventListener("select",H),s.addEventListener("selectstart",H),s.addEventListener("selectend",H),s.addEventListener("squeeze",H),s.addEventListener("squeezestart",H),s.addEventListener("squeezeend",H),s.addEventListener("end",G),s.addEventListener("inputsourceschange",j);const st=e.getContextAttributes();if(st.xrCompatible!==!0&&await e.makeXRCompatible(),s.renderState.layers===void 0){const Mt={antialias:st.antialias,alpha:st.alpha,depth:st.depth,stencil:st.stencil,framebufferScaleFactor:a};v=new XRWebGLLayer(s,e,Mt),s.updateRenderState({baseLayer:v})}else if(e instanceof WebGLRenderingContext){const Mt={antialias:!0,alpha:st.alpha,depth:st.depth,stencil:st.stencil,framebufferScaleFactor:a};v=new XRWebGLLayer(s,e,Mt),s.updateRenderState({layers:[v]})}else{b=st.antialias;let Mt=null;st.depth&&(L=256,st.stencil&&(L|=1024),R=st.stencil?33306:36096,Mt=st.stencil?35056:33190);const q={colorFormat:st.alpha?32856:32849,depthFormat:Mt,scaleFactor:a};f=new XRWebGLBinding(s,e),m=f.createProjectionLayer(q),g=e.createFramebuffer(),s.updateRenderState({layers:[m]}),b&&(y=e.createFramebuffer(),M=e.createRenderbuffer(),e.bindRenderbuffer(36161,M),e.renderbufferStorageMultisample(36161,4,32856,m.textureWidth,m.textureHeight),i.bindFramebuffer(36160,y),e.framebufferRenderbuffer(36160,36064,36161,M),e.bindRenderbuffer(36161,null),Mt!==null&&(x=e.createRenderbuffer(),e.bindRenderbuffer(36161,x),e.renderbufferStorageMultisample(36161,4,Mt,m.textureWidth,m.textureHeight),e.framebufferRenderbuffer(36160,R,36161,x),e.bindRenderbuffer(36161,null)),i.bindFramebuffer(36160,null))}h=await s.requestReferenceSpace(u),vt.setContext(s),vt.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function j(J){const st=s.inputSources;for(let Mt=0;Mt<A.length;Mt++)N.set(st[Mt],A[Mt]);for(let Mt=0;Mt<J.removed.length;Mt++){const q=J.removed[Mt],Ct=N.get(q);Ct&&(Ct.dispatchEvent({type:"disconnected",data:q}),N.delete(q))}for(let Mt=0;Mt<J.added.length;Mt++){const q=J.added[Mt],Ct=N.get(q);Ct&&Ct.dispatchEvent({type:"connected",data:q})}}const B=new T,K=new T;function at(J,st,Mt){B.setFromMatrixPosition(st.matrixWorld),K.setFromMatrixPosition(Mt.matrixWorld);const q=B.distanceTo(K),Ct=st.projectionMatrix.elements,At=Mt.projectionMatrix.elements,dt=Ct[14]/(Ct[10]-1),xt=Ct[14]/(Ct[10]+1),kt=(Ct[9]+1)/Ct[5],Z=(Ct[9]-1)/Ct[5],nt=(Ct[8]-1)/Ct[0],lt=(At[8]+1)/At[0],St=dt*nt,ut=dt*lt,P=q/(-nt+lt),E=P*-nt;st.matrixWorld.decompose(J.position,J.quaternion,J.scale),J.translateX(E),J.translateZ(P),J.matrixWorld.compose(J.position,J.quaternion,J.scale),J.matrixWorldInverse.copy(J.matrixWorld).invert();const Y=dt+P,Q=xt+P,ht=St-E,_t=ut+(q-E),Lt=kt*xt/Q*Y,Et=Z*xt/Q*Y;J.projectionMatrix.makePerspective(ht,_t,Lt,Et,Y,Q)}function yt(J,st){st===null?J.matrixWorld.copy(J.matrix):J.matrixWorld.multiplyMatrices(st.matrixWorld,J.matrix),J.matrixWorldInverse.copy(J.matrixWorld).invert()}this.updateCamera=function(J){if(s===null)return;W.near=z.near=C.near=J.near,W.far=z.far=C.far=J.far,(F!==W.near||rt!==W.far)&&(s.updateRenderState({depthNear:W.near,depthFar:W.far}),F=W.near,rt=W.far);const st=J.parent,Mt=W.cameras;yt(W,st);for(let Ct=0;Ct<Mt.length;Ct++)yt(Mt[Ct],st);W.matrixWorld.decompose(W.position,W.quaternion,W.scale),J.position.copy(W.position),J.quaternion.copy(W.quaternion),J.scale.copy(W.scale),J.matrix.copy(W.matrix),J.matrixWorld.copy(W.matrixWorld);const q=J.children;for(let Ct=0,At=q.length;Ct<At;Ct++)q[Ct].updateMatrixWorld(!0);Mt.length===2?at(W,C,z):W.projectionMatrix.copy(C.projectionMatrix)},this.getCamera=function(){return W},this.getFoveation=function(){if(m!==null)return m.fixedFoveation;if(v!==null)return v.fixedFoveation},this.setFoveation=function(J){m!==null&&(m.fixedFoveation=J),v!==null&&v.fixedFoveation!==void 0&&(v.fixedFoveation=J)};let bt=null;function mt(J,st){if(d=st.getViewerPose(h),_=st,d!==null){const q=d.views;v!==null&&i.bindXRFramebuffer(v.framebuffer);let Ct=!1;q.length!==W.cameras.length&&(W.cameras.length=0,Ct=!0);for(let At=0;At<q.length;At++){const dt=q[At];let xt=null;if(v!==null)xt=v.getViewport(dt);else{const Z=f.getViewSubImage(m,dt);i.bindXRFramebuffer(g),Z.depthStencilTexture!==void 0&&e.framebufferTexture2D(36160,R,3553,Z.depthStencilTexture,0),e.framebufferTexture2D(36160,36064,3553,Z.colorTexture,0),xt=Z.viewport}const kt=tt[At];kt.matrix.fromArray(dt.transform.matrix),kt.projectionMatrix.fromArray(dt.projectionMatrix),kt.viewport.set(xt.x,xt.y,xt.width,xt.height),At===0&&W.matrix.copy(kt.matrix),Ct===!0&&W.cameras.push(kt)}b&&(i.bindXRFramebuffer(y),L!==null&&e.clear(L))}const Mt=s.inputSources;for(let q=0;q<A.length;q++){const Ct=A[q],At=Mt[q];Ct.update(At,st,h)}if(bt&&bt(J,st),b){const q=m.textureWidth,Ct=m.textureHeight;i.bindFramebuffer(36008,y),i.bindFramebuffer(36009,g),e.invalidateFramebuffer(36008,[R]),e.invalidateFramebuffer(36009,[R]),e.blitFramebuffer(0,0,q,Ct,0,0,q,Ct,16384,9728),e.invalidateFramebuffer(36008,[36064]),i.bindFramebuffer(36008,null),i.bindFramebuffer(36009,null),i.bindFramebuffer(36160,y)}_=null}const vt=new bu;vt.setAnimationLoop(mt),this.setAnimationLoop=function(J){bt=J},this.dispose=function(){}}}function gb(o){function t(x,_){x.fogColor.value.copy(_.color),_.isFog?(x.fogNear.value=_.near,x.fogFar.value=_.far):_.isFogExp2&&(x.fogDensity.value=_.density)}function e(x,_,R,L,A){_.isMeshBasicMaterial?n(x,_):_.isMeshLambertMaterial?(n(x,_),u(x,_)):_.isMeshToonMaterial?(n(x,_),f(x,_)):_.isMeshPhongMaterial?(n(x,_),d(x,_)):_.isMeshStandardMaterial?(n(x,_),_.isMeshPhysicalMaterial?m(x,_,A):g(x,_)):_.isMeshMatcapMaterial?(n(x,_),v(x,_)):_.isMeshDepthMaterial?(n(x,_),b(x,_)):_.isMeshDistanceMaterial?(n(x,_),y(x,_)):_.isMeshNormalMaterial?(n(x,_),M(x,_)):_.isLineBasicMaterial?(i(x,_),_.isLineDashedMaterial&&s(x,_)):_.isPointsMaterial?a(x,_,R,L):_.isSpriteMaterial?h(x,_):_.isShadowMaterial?(x.color.value.copy(_.color),x.opacity.value=_.opacity):_.isShaderMaterial&&(_.uniformsNeedUpdate=!1)}function n(x,_){x.opacity.value=_.opacity,_.color&&x.diffuse.value.copy(_.color),_.emissive&&x.emissive.value.copy(_.emissive).multiplyScalar(_.emissiveIntensity),_.map&&(x.map.value=_.map),_.alphaMap&&(x.alphaMap.value=_.alphaMap),_.specularMap&&(x.specularMap.value=_.specularMap),_.alphaTest>0&&(x.alphaTest.value=_.alphaTest);const R=o.get(_).envMap;if(R){x.envMap.value=R,x.flipEnvMap.value=R.isCubeTexture&&R.isRenderTargetTexture===!1?-1:1,x.reflectivity.value=_.reflectivity,x.ior.value=_.ior,x.refractionRatio.value=_.refractionRatio;const N=o.get(R).__maxMipLevel;N!==void 0&&(x.maxMipLevel.value=N)}_.lightMap&&(x.lightMap.value=_.lightMap,x.lightMapIntensity.value=_.lightMapIntensity),_.aoMap&&(x.aoMap.value=_.aoMap,x.aoMapIntensity.value=_.aoMapIntensity);let L;_.map?L=_.map:_.specularMap?L=_.specularMap:_.displacementMap?L=_.displacementMap:_.normalMap?L=_.normalMap:_.bumpMap?L=_.bumpMap:_.roughnessMap?L=_.roughnessMap:_.metalnessMap?L=_.metalnessMap:_.alphaMap?L=_.alphaMap:_.emissiveMap?L=_.emissiveMap:_.clearcoatMap?L=_.clearcoatMap:_.clearcoatNormalMap?L=_.clearcoatNormalMap:_.clearcoatRoughnessMap?L=_.clearcoatRoughnessMap:_.specularIntensityMap?L=_.specularIntensityMap:_.specularTintMap?L=_.specularTintMap:_.transmissionMap?L=_.transmissionMap:_.thicknessMap&&(L=_.thicknessMap),L!==void 0&&(L.isWebGLRenderTarget&&(L=L.texture),L.matrixAutoUpdate===!0&&L.updateMatrix(),x.uvTransform.value.copy(L.matrix));let A;_.aoMap?A=_.aoMap:_.lightMap&&(A=_.lightMap),A!==void 0&&(A.isWebGLRenderTarget&&(A=A.texture),A.matrixAutoUpdate===!0&&A.updateMatrix(),x.uv2Transform.value.copy(A.matrix))}function i(x,_){x.diffuse.value.copy(_.color),x.opacity.value=_.opacity}function s(x,_){x.dashSize.value=_.dashSize,x.totalSize.value=_.dashSize+_.gapSize,x.scale.value=_.scale}function a(x,_,R,L){x.diffuse.value.copy(_.color),x.opacity.value=_.opacity,x.size.value=_.size*R,x.scale.value=L*.5,_.map&&(x.map.value=_.map),_.alphaMap&&(x.alphaMap.value=_.alphaMap),_.alphaTest>0&&(x.alphaTest.value=_.alphaTest);let A;_.map?A=_.map:_.alphaMap&&(A=_.alphaMap),A!==void 0&&(A.matrixAutoUpdate===!0&&A.updateMatrix(),x.uvTransform.value.copy(A.matrix))}function h(x,_){x.diffuse.value.copy(_.color),x.opacity.value=_.opacity,x.rotation.value=_.rotation,_.map&&(x.map.value=_.map),_.alphaMap&&(x.alphaMap.value=_.alphaMap),_.alphaTest>0&&(x.alphaTest.value=_.alphaTest);let R;_.map?R=_.map:_.alphaMap&&(R=_.alphaMap),R!==void 0&&(R.matrixAutoUpdate===!0&&R.updateMatrix(),x.uvTransform.value.copy(R.matrix))}function u(x,_){_.emissiveMap&&(x.emissiveMap.value=_.emissiveMap)}function d(x,_){x.specular.value.copy(_.specular),x.shininess.value=Math.max(_.shininess,1e-4),_.emissiveMap&&(x.emissiveMap.value=_.emissiveMap),_.bumpMap&&(x.bumpMap.value=_.bumpMap,x.bumpScale.value=_.bumpScale,_.side===me&&(x.bumpScale.value*=-1)),_.normalMap&&(x.normalMap.value=_.normalMap,x.normalScale.value.copy(_.normalScale),_.side===me&&x.normalScale.value.negate()),_.displacementMap&&(x.displacementMap.value=_.displacementMap,x.displacementScale.value=_.displacementScale,x.displacementBias.value=_.displacementBias)}function f(x,_){_.gradientMap&&(x.gradientMap.value=_.gradientMap),_.emissiveMap&&(x.emissiveMap.value=_.emissiveMap),_.bumpMap&&(x.bumpMap.value=_.bumpMap,x.bumpScale.value=_.bumpScale,_.side===me&&(x.bumpScale.value*=-1)),_.normalMap&&(x.normalMap.value=_.normalMap,x.normalScale.value.copy(_.normalScale),_.side===me&&x.normalScale.value.negate()),_.displacementMap&&(x.displacementMap.value=_.displacementMap,x.displacementScale.value=_.displacementScale,x.displacementBias.value=_.displacementBias)}function g(x,_){x.roughness.value=_.roughness,x.metalness.value=_.metalness,_.roughnessMap&&(x.roughnessMap.value=_.roughnessMap),_.metalnessMap&&(x.metalnessMap.value=_.metalnessMap),_.emissiveMap&&(x.emissiveMap.value=_.emissiveMap),_.bumpMap&&(x.bumpMap.value=_.bumpMap,x.bumpScale.value=_.bumpScale,_.side===me&&(x.bumpScale.value*=-1)),_.normalMap&&(x.normalMap.value=_.normalMap,x.normalScale.value.copy(_.normalScale),_.side===me&&x.normalScale.value.negate()),_.displacementMap&&(x.displacementMap.value=_.displacementMap,x.displacementScale.value=_.displacementScale,x.displacementBias.value=_.displacementBias),o.get(_).envMap&&(x.envMapIntensity.value=_.envMapIntensity)}function m(x,_,R){g(x,_),x.ior.value=_.ior,_.sheenTint&&x.sheenTint.value.copy(_.sheenTint),_.clearcoat>0&&(x.clearcoat.value=_.clearcoat,x.clearcoatRoughness.value=_.clearcoatRoughness,_.clearcoatMap&&(x.clearcoatMap.value=_.clearcoatMap),_.clearcoatRoughnessMap&&(x.clearcoatRoughnessMap.value=_.clearcoatRoughnessMap),_.clearcoatNormalMap&&(x.clearcoatNormalScale.value.copy(_.clearcoatNormalScale),x.clearcoatNormalMap.value=_.clearcoatNormalMap,_.side===me&&x.clearcoatNormalScale.value.negate())),_.transmission>0&&(x.transmission.value=_.transmission,x.transmissionSamplerMap.value=R.texture,x.transmissionSamplerSize.value.set(R.width,R.height),_.transmissionMap&&(x.transmissionMap.value=_.transmissionMap),x.thickness.value=_.thickness,_.thicknessMap&&(x.thicknessMap.value=_.thicknessMap),x.attenuationDistance.value=_.attenuationDistance,x.attenuationTint.value.copy(_.attenuationTint)),x.specularIntensity.value=_.specularIntensity,x.specularTint.value.copy(_.specularTint),_.specularIntensityMap&&(x.specularIntensityMap.value=_.specularIntensityMap),_.specularTintMap&&(x.specularTintMap.value=_.specularTintMap)}function v(x,_){_.matcap&&(x.matcap.value=_.matcap),_.bumpMap&&(x.bumpMap.value=_.bumpMap,x.bumpScale.value=_.bumpScale,_.side===me&&(x.bumpScale.value*=-1)),_.normalMap&&(x.normalMap.value=_.normalMap,x.normalScale.value.copy(_.normalScale),_.side===me&&x.normalScale.value.negate()),_.displacementMap&&(x.displacementMap.value=_.displacementMap,x.displacementScale.value=_.displacementScale,x.displacementBias.value=_.displacementBias)}function b(x,_){_.displacementMap&&(x.displacementMap.value=_.displacementMap,x.displacementScale.value=_.displacementScale,x.displacementBias.value=_.displacementBias)}function y(x,_){_.displacementMap&&(x.displacementMap.value=_.displacementMap,x.displacementScale.value=_.displacementScale,x.displacementBias.value=_.displacementBias),x.referencePosition.value.copy(_.referencePosition),x.nearDistance.value=_.nearDistance,x.farDistance.value=_.farDistance}function M(x,_){_.bumpMap&&(x.bumpMap.value=_.bumpMap,x.bumpScale.value=_.bumpScale,_.side===me&&(x.bumpScale.value*=-1)),_.normalMap&&(x.normalMap.value=_.normalMap,x.normalScale.value.copy(_.normalScale),_.side===me&&x.normalScale.value.negate()),_.displacementMap&&(x.displacementMap.value=_.displacementMap,x.displacementScale.value=_.displacementScale,x.displacementBias.value=_.displacementBias)}return{refreshFogUniforms:t,refreshMaterialUniforms:e}}function vb(){const o=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return o.style.display="block",o}function Qt(o={}){const t=o.canvas!==void 0?o.canvas:vb(),e=o.context!==void 0?o.context:null,n=o.alpha!==void 0?o.alpha:!1,i=o.depth!==void 0?o.depth:!0,s=o.stencil!==void 0?o.stencil:!0,a=o.antialias!==void 0?o.antialias:!1,h=o.premultipliedAlpha!==void 0?o.premultipliedAlpha:!0,u=o.preserveDrawingBuffer!==void 0?o.preserveDrawingBuffer:!1,d=o.powerPreference!==void 0?o.powerPreference:"default",f=o.failIfMajorPerformanceCaveat!==void 0?o.failIfMajorPerformanceCaveat:!1;let g=null,m=null;const v=[],b=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=He,this.physicallyCorrectLights=!1,this.toneMapping=gi,this.toneMappingExposure=1;const y=this;let M=!1,x=0,_=0,R=null,L=-1,A=null;const N=new te,C=new te;let z=null,tt=t.width,W=t.height,F=1,rt=null,H=null;const G=new te(0,0,tt,W),j=new te(0,0,tt,W);let B=!1;const K=[],at=new wo;let yt=!1,bt=!1,mt=null;const vt=new It,J=new T,st={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Mt(){return R===null?F:1}let q=e;function Ct(S,U){for(let V=0;V<S.length;V++){const X=S[V],et=t.getContext(X,U);if(et!==null)return et}return null}try{const S={alpha:n,depth:i,stencil:s,antialias:a,premultipliedAlpha:h,preserveDrawingBuffer:u,powerPreference:d,failIfMajorPerformanceCaveat:f};if(t.addEventListener("webglcontextlost",zt,!1),t.addEventListener("webglcontextrestored",Ut,!1),q===null){const U=["webgl2","webgl","experimental-webgl"];if(y.isWebGL1Renderer===!0&&U.shift(),q=Ct(U,S),q===null)throw Ct(U)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}q.getShaderPrecisionFormat===void 0&&(q.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(S){throw console.error("THREE.WebGLRenderer: "+S.message),S}let At,dt,xt,kt,Z,nt,lt,St,ut,P,E,Y,Q,ht,_t,Lt,Et,Nt,Tt,k,pt,$,gt;function D(){At=new zx(q),dt=new Dx(q,At,o),At.init(dt),$=new pb(q,At,dt),xt=new ub(q,At,dt),K[0]=1029,kt=new Gx,Z=new tb,nt=new db(q,At,xt,Z,dt,$,kt),lt=new Nx(y),St=new Ox(y),ut=new nv(q,dt),gt=new Lx(q,At,ut,dt),P=new Ux(q,ut,kt,gt),E=new Xx(q,P,ut,kt),Tt=new jx(q),Lt=new Ix(Z),Y=new Q0(y,lt,St,At,dt,gt,Lt),Q=new gb(Z),ht=new nb(Z),_t=new lb(At,dt),Nt=new Px(y,lt,xt,E,h),Et=new Nu(y,E,dt),k=new Rx(q,At,kt,dt),pt=new Hx(q,At,kt,dt),kt.programs=Y.programs,y.capabilities=dt,y.extensions=At,y.properties=Z,y.renderLists=ht,y.shadowMap=Et,y.state=xt,y.info=kt}D();const ot=new mb(y,q);this.xr=ot,this.getContext=function(){return q},this.getContextAttributes=function(){return q.getContextAttributes()},this.forceContextLoss=function(){const S=At.get("WEBGL_lose_context");S&&S.loseContext()},this.forceContextRestore=function(){const S=At.get("WEBGL_lose_context");S&&S.restoreContext()},this.getPixelRatio=function(){return F},this.setPixelRatio=function(S){S!==void 0&&(F=S,this.setSize(tt,W,!1))},this.getSize=function(S){return S.set(tt,W)},this.setSize=function(S,U,V){if(ot.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}tt=S,W=U,t.width=Math.floor(S*F),t.height=Math.floor(U*F),V!==!1&&(t.style.width=S+"px",t.style.height=U+"px"),this.setViewport(0,0,S,U)},this.getDrawingBufferSize=function(S){return S.set(tt*F,W*F).floor()},this.setDrawingBufferSize=function(S,U,V){tt=S,W=U,F=V,t.width=Math.floor(S*V),t.height=Math.floor(U*V),this.setViewport(0,0,S,U)},this.getCurrentViewport=function(S){return S.copy(N)},this.getViewport=function(S){return S.copy(G)},this.setViewport=function(S,U,V,X){S.isVector4?G.set(S.x,S.y,S.z,S.w):G.set(S,U,V,X),xt.viewport(N.copy(G).multiplyScalar(F).floor())},this.getScissor=function(S){return S.copy(j)},this.setScissor=function(S,U,V,X){S.isVector4?j.set(S.x,S.y,S.z,S.w):j.set(S,U,V,X),xt.scissor(C.copy(j).multiplyScalar(F).floor())},this.getScissorTest=function(){return B},this.setScissorTest=function(S){xt.setScissorTest(B=S)},this.setOpaqueSort=function(S){rt=S},this.setTransparentSort=function(S){H=S},this.getClearColor=function(S){return S.copy(Nt.getClearColor())},this.setClearColor=function(){Nt.setClearColor.apply(Nt,arguments)},this.getClearAlpha=function(){return Nt.getClearAlpha()},this.setClearAlpha=function(){Nt.setClearAlpha.apply(Nt,arguments)},this.clear=function(S,U,V){let X=0;(S===void 0||S)&&(X|=16384),(U===void 0||U)&&(X|=256),(V===void 0||V)&&(X|=1024),q.clear(X)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",zt,!1),t.removeEventListener("webglcontextrestored",Ut,!1),ht.dispose(),_t.dispose(),Z.dispose(),lt.dispose(),St.dispose(),E.dispose(),gt.dispose(),ot.dispose(),ot.removeEventListener("sessionstart",bi),ot.removeEventListener("sessionend",Ge),mt&&(mt.dispose(),mt=null),rn.stop()};function zt(S){S.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),M=!0}function Ut(){console.log("THREE.WebGLRenderer: Context Restored."),M=!1;const S=kt.autoReset,U=Et.enabled,V=Et.autoUpdate,X=Et.needsUpdate,et=Et.type;D(),kt.autoReset=S,Et.enabled=U,Et.autoUpdate=V,Et.needsUpdate=X,Et.type=et}function ie(S){const U=S.target;U.removeEventListener("dispose",ie),Kt(U)}function Kt(S){Se(S),Z.remove(S)}function Se(S){const U=Z.get(S).programs;U!==void 0&&U.forEach(function(V){Y.releaseProgram(V)})}function ke(S,U){S.render(function(V){y.renderBufferImmediate(V,U)})}this.renderBufferImmediate=function(S,U){gt.initAttributes();const V=Z.get(S);S.hasPositions&&!V.position&&(V.position=q.createBuffer()),S.hasNormals&&!V.normal&&(V.normal=q.createBuffer()),S.hasUvs&&!V.uv&&(V.uv=q.createBuffer()),S.hasColors&&!V.color&&(V.color=q.createBuffer());const X=U.getAttributes();S.hasPositions&&(q.bindBuffer(34962,V.position),q.bufferData(34962,S.positionArray,35048),gt.enableAttribute(X.position.location),q.vertexAttribPointer(X.position.location,3,5126,!1,0,0)),S.hasNormals&&(q.bindBuffer(34962,V.normal),q.bufferData(34962,S.normalArray,35048),gt.enableAttribute(X.normal.location),q.vertexAttribPointer(X.normal.location,3,5126,!1,0,0)),S.hasUvs&&(q.bindBuffer(34962,V.uv),q.bufferData(34962,S.uvArray,35048),gt.enableAttribute(X.uv.location),q.vertexAttribPointer(X.uv.location,2,5126,!1,0,0)),S.hasColors&&(q.bindBuffer(34962,V.color),q.bufferData(34962,S.colorArray,35048),gt.enableAttribute(X.color.location),q.vertexAttribPointer(X.color.location,3,5126,!1,0,0)),gt.disableUnusedAttributes(),q.drawArrays(4,0,S.count),S.count=0},this.renderBufferDirect=function(S,U,V,X,et,Vt){U===null&&(U=st);const Rt=et.isMesh&&et.matrixWorld.determinant()<0,Pt=hs(S,U,X,et);xt.setMaterial(X,Rt);let Ot=V.index;const Wt=V.attributes.position;if(Ot===null){if(Wt===void 0||Wt.count===0)return}else if(Ot.count===0)return;let Ht=1;X.wireframe===!0&&(Ot=P.getWireframeAttribute(V),Ht=2),(V.morphAttributes.position!==void 0||V.morphAttributes.normal!==void 0)&&Tt.update(et,V,X,Pt),gt.setup(et,X,Pt,V,Ot);let jt,Ft=k;Ot!==null&&(jt=ut.get(Ot),Ft=pt,Ft.setIndex(jt));const pn=Ot!==null?Ot.count:Wt.count,le=V.drawRange.start*Ht,fn=V.drawRange.count*Ht,Be=Vt!==null?Vt.start*Ht:0,Ee=Vt!==null?Vt.count*Ht:1/0,Ve=Math.max(le,Be),pe=Math.min(pn,le+fn,Be+Ee)-1,Je=Math.max(0,pe-Ve+1);if(Je!==0){if(et.isMesh)X.wireframe===!0?(xt.setLineWidth(X.wireframeLinewidth*Mt()),Ft.setMode(1)):Ft.setMode(4);else if(et.isLine){let fe=X.linewidth;fe===void 0&&(fe=1),xt.setLineWidth(fe*Mt()),et.isLineSegments?Ft.setMode(1):et.isLineLoop?Ft.setMode(2):Ft.setMode(3)}else et.isPoints?Ft.setMode(0):et.isSprite&&Ft.setMode(4);if(et.isInstancedMesh)Ft.renderInstances(Ve,Je,et.count);else if(V.isInstancedBufferGeometry){const fe=Math.min(V.instanceCount,V._maxInstanceCount);Ft.renderInstances(Ve,Je,fe)}else Ft.render(Ve,Je)}},this.compile=function(S,U){m=_t.get(S),m.init(),b.push(m),S.traverseVisible(function(V){V.isLight&&V.layers.test(U.layers)&&(m.pushLight(V),V.castShadow&&m.pushShadow(V))}),m.setupLights(y.physicallyCorrectLights),S.traverse(function(V){const X=V.material;if(X)if(Array.isArray(X))for(let et=0;et<X.length;et++){const Vt=X[et];ri(Vt,S,V)}else ri(X,S,V)}),b.pop(),m=null};let Le=null;function Re(S){Le&&Le(S)}function bi(){rn.stop()}function Ge(){rn.start()}const rn=new bu;rn.setAnimationLoop(Re),typeof window!="undefined"&&rn.setContext(window),this.setAnimationLoop=function(S){Le=S,ot.setAnimationLoop(S),S===null?rn.stop():rn.start()},ot.addEventListener("sessionstart",bi),ot.addEventListener("sessionend",Ge),this.render=function(S,U){if(U!==void 0&&U.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(M===!0)return;S.autoUpdate===!0&&S.updateMatrixWorld(),U.parent===null&&U.updateMatrixWorld(),ot.enabled===!0&&ot.isPresenting===!0&&(ot.cameraAutoUpdate===!0&&ot.updateCamera(U),U=ot.getCamera()),S.isScene===!0&&S.onBeforeRender(y,S,U,R),m=_t.get(S,b.length),m.init(),b.push(m),vt.multiplyMatrices(U.projectionMatrix,U.matrixWorldInverse),at.setFromProjectionMatrix(vt),bt=this.localClippingEnabled,yt=Lt.init(this.clippingPlanes,bt,U),g=ht.get(S,v.length),g.init(),v.push(g),sn(S,U,0,y.sortObjects),g.finish(),y.sortObjects===!0&&g.sort(rt,H),yt===!0&&Lt.beginShadows();const V=m.state.shadowsArray;if(Et.render(V,S,U),yt===!0&&Lt.endShadows(),this.info.autoReset===!0&&this.info.reset(),Nt.render(g,S),m.setupLights(y.physicallyCorrectLights),U.isArrayCamera){const X=U.cameras;for(let et=0,Vt=X.length;et<Vt;et++){const Rt=X[et];cs(g,S,Rt,Rt.viewport)}}else cs(g,S,U);R!==null&&(nt.updateMultisampleRenderTarget(R),nt.updateRenderTargetMipmap(R)),S.isScene===!0&&S.onAfterRender(y,S,U),xt.buffers.depth.setTest(!0),xt.buffers.depth.setMask(!0),xt.buffers.color.setMask(!0),xt.setPolygonOffset(!1),gt.resetDefaultState(),L=-1,A=null,b.pop(),b.length>0?m=b[b.length-1]:m=null,v.pop(),v.length>0?g=v[v.length-1]:g=null};function sn(S,U,V,X){if(S.visible===!1)return;if(S.layers.test(U.layers)){if(S.isGroup)V=S.renderOrder;else if(S.isLOD)S.autoUpdate===!0&&S.update(U);else if(S.isLight)m.pushLight(S),S.castShadow&&m.pushShadow(S);else if(S.isSprite){if(!S.frustumCulled||at.intersectsSprite(S)){X&&J.setFromMatrixPosition(S.matrixWorld).applyMatrix4(vt);const Rt=E.update(S),Pt=S.material;Pt.visible&&g.push(S,Rt,Pt,V,J.z,null)}}else if(S.isImmediateRenderObject)X&&J.setFromMatrixPosition(S.matrixWorld).applyMatrix4(vt),g.push(S,null,S.material,V,J.z,null);else if((S.isMesh||S.isLine||S.isPoints)&&(S.isSkinnedMesh&&S.skeleton.frame!==kt.render.frame&&(S.skeleton.update(),S.skeleton.frame=kt.render.frame),!S.frustumCulled||at.intersectsObject(S))){X&&J.setFromMatrixPosition(S.matrixWorld).applyMatrix4(vt);const Rt=E.update(S),Pt=S.material;if(Array.isArray(Pt)){const Ot=Rt.groups;for(let Wt=0,Ht=Ot.length;Wt<Ht;Wt++){const jt=Ot[Wt],Ft=Pt[jt.materialIndex];Ft&&Ft.visible&&g.push(S,Rt,Ft,V,J.z,jt)}}else Pt.visible&&g.push(S,Rt,Pt,V,J.z,null)}}const Vt=S.children;for(let Rt=0,Pt=Vt.length;Rt<Pt;Rt++)sn(Vt[Rt],U,V,X)}function cs(S,U,V,X){const et=S.opaque,Vt=S.transmissive,Rt=S.transparent;m.setupLightsView(V),Vt.length>0&&ni(et,U,V),X&&xt.viewport(N.copy(X)),et.length>0&&ii(et,U,V),Vt.length>0&&ii(Vt,U,V),Rt.length>0&&ii(Rt,U,V)}function ni(S,U,V){if(mt===null){const Rt=a===!0&&dt.isWebGL2===!0?pu:yn;mt=new Rt(1024,1024,{generateMipmaps:!0,type:$.convert(sr)!==null?sr:ur,minFilter:xo,magFilter:_e,wrapS:Xe,wrapT:Xe})}const X=y.getRenderTarget();y.setRenderTarget(mt),y.clear();const et=y.toneMapping;y.toneMapping=gi,ii(S,U,V),y.toneMapping=et,nt.updateMultisampleRenderTarget(mt),nt.updateRenderTargetMipmap(mt),y.setRenderTarget(X)}function ii(S,U,V){const X=U.isScene===!0?U.overrideMaterial:null;for(let et=0,Vt=S.length;et<Vt;et++){const Rt=S[et],Pt=Rt.object,Ot=Rt.geometry,Wt=X===null?Rt.material:X,Ht=Rt.group;Pt.layers.test(V.layers)&&yi(Pt,U,V,Ot,Wt,Ht)}}function yi(S,U,V,X,et,Vt){if(S.onBeforeRender(y,U,V,X,et,Vt),S.modelViewMatrix.multiplyMatrices(V.matrixWorldInverse,S.matrixWorld),S.normalMatrix.getNormalMatrix(S.modelViewMatrix),S.isImmediateRenderObject){const Rt=hs(V,U,et,S);xt.setMaterial(et),gt.reset(),ke(S,Rt)}else et.transparent===!0&&et.side===hr?(et.side=me,et.needsUpdate=!0,y.renderBufferDirect(V,U,X,et,S,Vt),et.side=Qr,et.needsUpdate=!0,y.renderBufferDirect(V,U,X,et,S,Vt),et.side=hr):y.renderBufferDirect(V,U,X,et,S,Vt);S.onAfterRender(y,U,V,X,et,Vt)}function ri(S,U,V){U.isScene!==!0&&(U=st);const X=Z.get(S),et=m.state.lights,Vt=m.state.shadowsArray,Rt=et.state.version,Pt=Y.getParameters(S,et.state,Vt,U,V),Ot=Y.getProgramCacheKey(Pt);let Wt=X.programs;X.environment=S.isMeshStandardMaterial?U.environment:null,X.fog=U.fog,X.envMap=(S.isMeshStandardMaterial?St:lt).get(S.envMap||X.environment),Wt===void 0&&(S.addEventListener("dispose",ie),Wt=new Map,X.programs=Wt);let Ht=Wt.get(Ot);if(Ht!==void 0){if(X.currentProgram===Ht&&X.lightsStateVersion===Rt)return wi(S,Pt),Ht}else Pt.uniforms=Y.getUniforms(S),S.onBuild(Pt,y),S.onBeforeCompile(Pt,y),Ht=Y.acquireProgram(Pt,Ot),Wt.set(Ot,Ht),X.uniforms=Pt.uniforms;const jt=X.uniforms;(!S.isShaderMaterial&&!S.isRawShaderMaterial||S.clipping===!0)&&(jt.clippingPlanes=Lt.uniform),wi(S,Pt),X.needsLights=Ro(S),X.lightsStateVersion=Rt,X.needsLights&&(jt.ambientLightColor.value=et.state.ambient,jt.lightProbe.value=et.state.probe,jt.directionalLights.value=et.state.directional,jt.directionalLightShadows.value=et.state.directionalShadow,jt.spotLights.value=et.state.spot,jt.spotLightShadows.value=et.state.spotShadow,jt.rectAreaLights.value=et.state.rectArea,jt.ltc_1.value=et.state.rectAreaLTC1,jt.ltc_2.value=et.state.rectAreaLTC2,jt.pointLights.value=et.state.point,jt.pointLightShadows.value=et.state.pointShadow,jt.hemisphereLights.value=et.state.hemi,jt.directionalShadowMap.value=et.state.directionalShadowMap,jt.directionalShadowMatrix.value=et.state.directionalShadowMatrix,jt.spotShadowMap.value=et.state.spotShadowMap,jt.spotShadowMatrix.value=et.state.spotShadowMatrix,jt.pointShadowMap.value=et.state.pointShadowMap,jt.pointShadowMatrix.value=et.state.pointShadowMatrix);const Ft=Ht.getUniforms(),pn=Zn.seqWithValue(Ft.seq,jt);return X.currentProgram=Ht,X.uniformsList=pn,Ht}function wi(S,U){const V=Z.get(S);V.outputEncoding=U.outputEncoding,V.instancing=U.instancing,V.skinning=U.skinning,V.morphTargets=U.morphTargets,V.morphNormals=U.morphNormals,V.numClippingPlanes=U.numClippingPlanes,V.numIntersection=U.numClipIntersection,V.vertexAlphas=U.vertexAlphas,V.vertexTangents=U.vertexTangents}function hs(S,U,V,X){U.isScene!==!0&&(U=st),nt.resetTextureUnits();const et=U.fog,Vt=V.isMeshStandardMaterial?U.environment:null,Rt=R===null?y.outputEncoding:R.texture.encoding,Pt=(V.isMeshStandardMaterial?St:lt).get(V.envMap||Vt),Ot=V.vertexColors===!0&&!!X.geometry&&!!X.geometry.attributes.color&&X.geometry.attributes.color.itemSize===4,Wt=!!X.geometry&&!!X.geometry.attributes.tangent,Ht=!!X.geometry&&!!X.geometry.morphAttributes.position,jt=!!X.geometry&&!!X.geometry.morphAttributes.normal,Ft=Z.get(V),pn=m.state.lights;if(yt===!0&&(bt===!0||S!==A)){const fe=S===A&&V.id===L;Lt.setState(V,S,fe)}let le=!1;V.version===Ft.__version?(Ft.needsLights&&Ft.lightsStateVersion!==pn.state.version||Ft.outputEncoding!==Rt||X.isInstancedMesh&&Ft.instancing===!1||!X.isInstancedMesh&&Ft.instancing===!0||X.isSkinnedMesh&&Ft.skinning===!1||!X.isSkinnedMesh&&Ft.skinning===!0||Ft.envMap!==Pt||V.fog&&Ft.fog!==et||Ft.numClippingPlanes!==void 0&&(Ft.numClippingPlanes!==Lt.numPlanes||Ft.numIntersection!==Lt.numIntersection)||Ft.vertexAlphas!==Ot||Ft.vertexTangents!==Wt||Ft.morphTargets!==Ht||Ft.morphNormals!==jt)&&(le=!0):(le=!0,Ft.__version=V.version);let fn=Ft.currentProgram;le===!0&&(fn=ri(V,U,X));let Be=!1,Ee=!1,Ve=!1;const pe=fn.getUniforms(),Je=Ft.uniforms;if(xt.useProgram(fn.program)&&(Be=!0,Ee=!0,Ve=!0),V.id!==L&&(L=V.id,Ee=!0),Be||A!==S){if(pe.setValue(q,"projectionMatrix",S.projectionMatrix),dt.logarithmicDepthBuffer&&pe.setValue(q,"logDepthBufFC",2/(Math.log(S.far+1)/Math.LN2)),A!==S&&(A=S,Ee=!0,Ve=!0),V.isShaderMaterial||V.isMeshPhongMaterial||V.isMeshToonMaterial||V.isMeshStandardMaterial||V.envMap){const fe=pe.map.cameraPosition;fe!==void 0&&fe.setValue(q,J.setFromMatrixPosition(S.matrixWorld))}(V.isMeshPhongMaterial||V.isMeshToonMaterial||V.isMeshLambertMaterial||V.isMeshBasicMaterial||V.isMeshStandardMaterial||V.isShaderMaterial)&&pe.setValue(q,"isOrthographic",S.isOrthographicCamera===!0),(V.isMeshPhongMaterial||V.isMeshToonMaterial||V.isMeshLambertMaterial||V.isMeshBasicMaterial||V.isMeshStandardMaterial||V.isShaderMaterial||V.isShadowMaterial||X.isSkinnedMesh)&&pe.setValue(q,"viewMatrix",S.matrixWorldInverse)}if(X.isSkinnedMesh){pe.setOptional(q,X,"bindMatrix"),pe.setOptional(q,X,"bindMatrixInverse");const fe=X.skeleton;fe&&(dt.floatVertexTextures?(fe.boneTexture===null&&fe.computeBoneTexture(),pe.setValue(q,"boneTexture",fe.boneTexture,nt),pe.setValue(q,"boneTextureSize",fe.boneTextureSize)):pe.setOptional(q,fe,"boneMatrices"))}return(Ee||Ft.receiveShadow!==X.receiveShadow)&&(Ft.receiveShadow=X.receiveShadow,pe.setValue(q,"receiveShadow",X.receiveShadow)),Ee&&(pe.setValue(q,"toneMappingExposure",y.toneMappingExposure),Ft.needsLights&&Lo(Je,Ve),et&&V.fog&&Q.refreshFogUniforms(Je,et),Q.refreshMaterialUniforms(Je,V,F,W,mt),Zn.upload(q,Ft.uniformsList,Je,nt)),V.isShaderMaterial&&V.uniformsNeedUpdate===!0&&(Zn.upload(q,Ft.uniformsList,Je,nt),V.uniformsNeedUpdate=!1),V.isSpriteMaterial&&pe.setValue(q,"center",X.center),pe.setValue(q,"modelViewMatrix",X.modelViewMatrix),pe.setValue(q,"normalMatrix",X.normalMatrix),pe.setValue(q,"modelMatrix",X.matrixWorld),fn}function Lo(S,U){S.ambientLightColor.needsUpdate=U,S.lightProbe.needsUpdate=U,S.directionalLights.needsUpdate=U,S.directionalLightShadows.needsUpdate=U,S.pointLights.needsUpdate=U,S.pointLightShadows.needsUpdate=U,S.spotLights.needsUpdate=U,S.spotLightShadows.needsUpdate=U,S.rectAreaLights.needsUpdate=U,S.hemisphereLights.needsUpdate=U}function Ro(S){return S.isMeshLambertMaterial||S.isMeshToonMaterial||S.isMeshPhongMaterial||S.isMeshStandardMaterial||S.isShadowMaterial||S.isShaderMaterial&&S.lights===!0}this.getActiveCubeFace=function(){return x},this.getActiveMipmapLevel=function(){return _},this.getRenderTarget=function(){return R},this.setRenderTarget=function(S,U=0,V=0){R=S,x=U,_=V,S&&Z.get(S).__webglFramebuffer===void 0&&nt.setupRenderTarget(S);let X=null,et=!1,Vt=!1;if(S){const Pt=S.texture;(Pt.isDataTexture3D||Pt.isDataTexture2DArray)&&(Vt=!0);const Ot=Z.get(S).__webglFramebuffer;S.isWebGLCubeRenderTarget?(X=Ot[U],et=!0):S.isWebGLMultisampleRenderTarget?X=Z.get(S).__webglMultisampledFramebuffer:X=Ot,N.copy(S.viewport),C.copy(S.scissor),z=S.scissorTest}else N.copy(G).multiplyScalar(F).floor(),C.copy(j).multiplyScalar(F).floor(),z=B;if(xt.bindFramebuffer(36160,X)&&dt.drawBuffers){let Pt=!1;if(S)if(S.isWebGLMultipleRenderTargets){const Ot=S.texture;if(K.length!==Ot.length||K[0]!==36064){for(let Wt=0,Ht=Ot.length;Wt<Ht;Wt++)K[Wt]=36064+Wt;K.length=Ot.length,Pt=!0}}else(K.length!==1||K[0]!==36064)&&(K[0]=36064,K.length=1,Pt=!0);else(K.length!==1||K[0]!==1029)&&(K[0]=1029,K.length=1,Pt=!0);Pt&&(dt.isWebGL2?q.drawBuffers(K):At.get("WEBGL_draw_buffers").drawBuffersWEBGL(K))}if(xt.viewport(N),xt.scissor(C),xt.setScissorTest(z),et){const Pt=Z.get(S.texture);q.framebufferTexture2D(36160,36064,34069+U,Pt.__webglTexture,V)}else if(Vt){const Pt=Z.get(S.texture),Ot=U||0;q.framebufferTextureLayer(36160,36064,Pt.__webglTexture,V||0,Ot)}L=-1},this.readRenderTargetPixels=function(S,U,V,X,et,Vt,Rt){if(!(S&&S.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Pt=Z.get(S).__webglFramebuffer;if(S.isWebGLCubeRenderTarget&&Rt!==void 0&&(Pt=Pt[Rt]),Pt){xt.bindFramebuffer(36160,Pt);try{const Ot=S.texture,Wt=Ot.format,Ht=Ot.type;if(Wt!==Ye&&$.convert(Wt)!==q.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const jt=Ht===sr&&(At.has("EXT_color_buffer_half_float")||dt.isWebGL2&&At.has("EXT_color_buffer_float"));if(Ht!==ur&&$.convert(Ht)!==q.getParameter(35738)&&!(Ht===fi&&(dt.isWebGL2||At.has("OES_texture_float")||At.has("WEBGL_color_buffer_float")))&&!jt){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}q.checkFramebufferStatus(36160)===36053?U>=0&&U<=S.width-X&&V>=0&&V<=S.height-et&&q.readPixels(U,V,X,et,$.convert(Wt),$.convert(Ht),Vt):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const Ot=R!==null?Z.get(R).__webglFramebuffer:null;xt.bindFramebuffer(36160,Ot)}}},this.copyFramebufferToTexture=function(S,U,V=0){const X=Math.pow(2,-V),et=Math.floor(U.image.width*X),Vt=Math.floor(U.image.height*X);let Rt=$.convert(U.format);dt.isWebGL2&&(Rt===6407&&(Rt=32849),Rt===6408&&(Rt=32856)),nt.setTexture2D(U,0),q.copyTexImage2D(3553,V,Rt,S.x,S.y,et,Vt,0),xt.unbindTexture()},this.copyTextureToTexture=function(S,U,V,X=0){const et=U.image.width,Vt=U.image.height,Rt=$.convert(V.format),Pt=$.convert(V.type);nt.setTexture2D(V,0),q.pixelStorei(37440,V.flipY),q.pixelStorei(37441,V.premultiplyAlpha),q.pixelStorei(3317,V.unpackAlignment),U.isDataTexture?q.texSubImage2D(3553,X,S.x,S.y,et,Vt,Rt,Pt,U.image.data):U.isCompressedTexture?q.compressedTexSubImage2D(3553,X,S.x,S.y,U.mipmaps[0].width,U.mipmaps[0].height,Rt,U.mipmaps[0].data):q.texSubImage2D(3553,X,S.x,S.y,Rt,Pt,U.image),X===0&&V.generateMipmaps&&q.generateMipmap(3553),xt.unbindTexture()},this.copyTextureToTexture3D=function(S,U,V,X,et=0){if(y.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const Vt=S.max.x-S.min.x+1,Rt=S.max.y-S.min.y+1,Pt=S.max.z-S.min.z+1,Ot=$.convert(X.format),Wt=$.convert(X.type);let Ht;if(X.isDataTexture3D)nt.setTexture3D(X,0),Ht=32879;else if(X.isDataTexture2DArray)nt.setTexture2DArray(X,0),Ht=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}q.pixelStorei(37440,X.flipY),q.pixelStorei(37441,X.premultiplyAlpha),q.pixelStorei(3317,X.unpackAlignment);const jt=q.getParameter(3314),Ft=q.getParameter(32878),pn=q.getParameter(3316),le=q.getParameter(3315),fn=q.getParameter(32877),Be=V.isCompressedTexture?V.mipmaps[0]:V.image;q.pixelStorei(3314,Be.width),q.pixelStorei(32878,Be.height),q.pixelStorei(3316,S.min.x),q.pixelStorei(3315,S.min.y),q.pixelStorei(32877,S.min.z),V.isDataTexture||V.isDataTexture3D?q.texSubImage3D(Ht,et,U.x,U.y,U.z,Vt,Rt,Pt,Ot,Wt,Be.data):V.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),q.compressedTexSubImage3D(Ht,et,U.x,U.y,U.z,Vt,Rt,Pt,Ot,Be.data)):q.texSubImage3D(Ht,et,U.x,U.y,U.z,Vt,Rt,Pt,Ot,Wt,Be),q.pixelStorei(3314,jt),q.pixelStorei(32878,Ft),q.pixelStorei(3316,pn),q.pixelStorei(3315,le),q.pixelStorei(32877,fn),et===0&&X.generateMipmaps&&q.generateMipmap(Ht),xt.unbindTexture()},this.initTexture=function(S){nt.setTexture2D(S,0),xt.unbindTexture()},this.resetState=function(){x=0,_=0,R=null,xt.reset(),gt.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class _b extends Qt{}_b.prototype.isWebGL1Renderer=!0;class So{constructor(t,e=1,n=1e3){this.name="",this.color=new wt(t),this.near=e,this.far=n}clone(){return new So(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}So.prototype.isFog=!0;class wl extends Zt{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),e}}wl.prototype.isScene=!0;class as{constructor(t,e){this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=es,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=bn()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let i=0,s=this.stride;i<s;i++)this.array[t+i]=e.array[n+i];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=bn()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=bn()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}as.prototype.isInterleavedBuffer=!0;const he=new T;class ns{constructor(t,e,n,i=!1){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=i===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)he.x=this.getX(e),he.y=this.getY(e),he.z=this.getZ(e),he.applyMatrix4(t),this.setXYZ(e,he.x,he.y,he.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)he.x=this.getX(e),he.y=this.getY(e),he.z=this.getZ(e),he.applyNormalMatrix(t),this.setXYZ(e,he.x,he.y,he.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)he.x=this.getX(e),he.y=this.getY(e),he.z=this.getZ(e),he.transformDirection(t),this.setXYZ(e,he.x,he.y,he.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this}setXYZW(t,e,n,i,s){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this.data.array[t+3]=s,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[i+s])}return new ge(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new ns(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[i+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}ns.prototype.isInterleavedBufferAttribute=!0;class ku extends Pe{constructor(t){super(),this.type="SpriteMaterial",this.color=new wt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}ku.prototype.isSpriteMaterial=!0;let Zi;const zr=new T,Ki=new T,Ji=new T,$i=new it,Ur=new it,Bu=new It,Hs=new T,Hr=new T,Gs=new T,bh=new it,Fa=new it,yh=new it;class xb extends Zt{constructor(t){if(super(),this.type="Sprite",Zi===void 0){Zi=new $t;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new as(e,5);Zi.setIndex([0,1,2,0,2,3]),Zi.setAttribute("position",new ns(n,3,0,!1)),Zi.setAttribute("uv",new ns(n,2,3,!1))}this.geometry=Zi,this.material=t!==void 0?t:new ku,this.center=new it(.5,.5)}raycast(t,e){t.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Ki.setFromMatrixScale(this.matrixWorld),Bu.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),Ji.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Ki.multiplyScalar(-Ji.z);const n=this.material.rotation;let i,s;n!==0&&(s=Math.cos(n),i=Math.sin(n));const a=this.center;Ws(Hs.set(-.5,-.5,0),Ji,a,Ki,i,s),Ws(Hr.set(.5,-.5,0),Ji,a,Ki,i,s),Ws(Gs.set(.5,.5,0),Ji,a,Ki,i,s),bh.set(0,0),Fa.set(1,0),yh.set(1,1);let h=t.ray.intersectTriangle(Hs,Hr,Gs,!1,zr);if(h===null&&(Ws(Hr.set(-.5,.5,0),Ji,a,Ki,i,s),Fa.set(0,1),h=t.ray.intersectTriangle(Hs,Gs,Hr,!1,zr),h===null))return;const u=t.ray.origin.distanceTo(zr);u<t.near||u>t.far||e.push({distance:u,point:zr.clone(),uv:de.getUV(zr,Hs,Hr,Gs,bh,Fa,yh,new it),face:null,object:this})}copy(t){return super.copy(t),t.center!==void 0&&this.center.copy(t.center),this.material=t.material,this}}xb.prototype.isSprite=!0;function Ws(o,t,e,n,i,s){$i.subVectors(o,e).addScalar(.5).multiply(n),i!==void 0?(Ur.x=s*$i.x-i*$i.y,Ur.y=i*$i.x+s*$i.y):Ur.copy($i),o.copy(t),o.x+=Ur.x,o.y+=Ur.y,o.applyMatrix4(Bu)}const wh=new T,Mh=new te,Sh=new te,bb=new T,Eh=new It;class Vu extends xe{constructor(t,e){super(t,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new It,this.bindMatrixInverse=new It}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new te,e=this.geometry.attributes.skinWeight;for(let n=0,i=e.count;n<i;n++){t.x=e.getX(n),t.y=e.getY(n),t.z=e.getZ(n),t.w=e.getW(n);const s=1/t.manhattanLength();s!==1/0?t.multiplyScalar(s):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const n=this.skeleton,i=this.geometry;Mh.fromBufferAttribute(i.attributes.skinIndex,t),Sh.fromBufferAttribute(i.attributes.skinWeight,t),wh.fromBufferAttribute(i.attributes.position,t).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let s=0;s<4;s++){const a=Sh.getComponent(s);if(a!==0){const h=Mh.getComponent(s);Eh.multiplyMatrices(n.bones[h].matrixWorld,n.boneInverses[h]),e.addScaledVector(bb.copy(wh).applyMatrix4(Eh),a)}}return e.applyMatrix4(this.bindMatrixInverse)}}Vu.prototype.isSkinnedMesh=!0;class yb extends Zt{constructor(){super(),this.type="Bone"}}yb.prototype.isBone=!0;class wb extends Me{constructor(t=null,e=1,n=1,i,s,a,h,u,d=_e,f=_e,g,m){super(null,a,h,u,d,f,i,s,g,m),this.image={data:t,width:e,height:n},this.magFilter=d,this.minFilter=f,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}wb.prototype.isDataTexture=!0;class rl extends ge{constructor(t,e,n,i=1){typeof n=="number"&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(t,e,n),this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}rl.prototype.isInstancedBufferAttribute=!0;const Th=new It,Ch=new It,qs=[],Gr=new xe;class Mb extends xe{constructor(t,e,n){super(t,e),this.instanceMatrix=new rl(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,t*3)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,t*16)}raycast(t,e){const n=this.matrixWorld,i=this.count;if(Gr.geometry=this.geometry,Gr.material=this.material,Gr.material!==void 0)for(let s=0;s<i;s++){this.getMatrixAt(s,Th),Ch.multiplyMatrices(n,Th),Gr.matrixWorld=Ch,Gr.raycast(t,qs);for(let a=0,h=qs.length;a<h;a++){const u=qs[a];u.instanceId=s,u.object=this,e.push(u)}qs.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new rl(new Float32Array(this.instanceMatrix.count*3),3)),e.toArray(this.instanceColor.array,t*3)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,t*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}Mb.prototype.isInstancedMesh=!0;class xr extends Pe{constructor(t){super(),this.type="LineBasicMaterial",this.color=new wt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this}}xr.prototype.isLineBasicMaterial=!0;const Ah=new T,Ph=new T,Lh=new It,ka=new _i,js=new gr;class Eo extends Zt{constructor(t=new $t,e=new xr){super(),this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,n=[0];for(let i=1,s=e.count;i<s;i++)Ah.fromBufferAttribute(e,i-1),Ph.fromBufferAttribute(e,i),n[i]=n[i-1],n[i]+=Ah.distanceTo(Ph);t.setAttribute("lineDistance",new ee(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,s=t.params.Line.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),js.copy(n.boundingSphere),js.applyMatrix4(i),js.radius+=s,t.ray.intersectsSphere(js)===!1)return;Lh.copy(i).invert(),ka.copy(t.ray).applyMatrix4(Lh);const h=s/((this.scale.x+this.scale.y+this.scale.z)/3),u=h*h,d=new T,f=new T,g=new T,m=new T,v=this.isLineSegments?2:1;if(n.isBufferGeometry){const b=n.index,M=n.attributes.position;if(b!==null){const x=Math.max(0,a.start),_=Math.min(b.count,a.start+a.count);for(let R=x,L=_-1;R<L;R+=v){const A=b.getX(R),N=b.getX(R+1);if(d.fromBufferAttribute(M,A),f.fromBufferAttribute(M,N),ka.distanceSqToSegment(d,f,m,g)>u)continue;m.applyMatrix4(this.matrixWorld);const z=t.ray.origin.distanceTo(m);z<t.near||z>t.far||e.push({distance:z,point:g.clone().applyMatrix4(this.matrixWorld),index:R,face:null,faceIndex:null,object:this})}}else{const x=Math.max(0,a.start),_=Math.min(M.count,a.start+a.count);for(let R=x,L=_-1;R<L;R+=v){if(d.fromBufferAttribute(M,R),f.fromBufferAttribute(M,R+1),ka.distanceSqToSegment(d,f,m,g)>u)continue;m.applyMatrix4(this.matrixWorld);const N=t.ray.origin.distanceTo(m);N<t.near||N>t.far||e.push({distance:N,point:g.clone().applyMatrix4(this.matrixWorld),index:R,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const h=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[h]=s}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Eo.prototype.isLine=!0;const Rh=new T,Dh=new T;class Ml extends Eo{constructor(t,e){super(t,e),this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,n=[];for(let i=0,s=e.count;i<s;i+=2)Rh.fromBufferAttribute(e,i),Dh.fromBufferAttribute(e,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+Rh.distanceTo(Dh);t.setAttribute("lineDistance",new ee(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}Ml.prototype.isLineSegments=!0;class Sb extends Eo{constructor(t,e){super(t,e),this.type="LineLoop"}}Sb.prototype.isLineLoop=!0;class Ou extends Pe{constructor(t){super(),this.type="PointsMaterial",this.color=new wt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this}}Ou.prototype.isPointsMaterial=!0;const Ih=new It,sl=new _i,Xs=new gr,Ys=new T;class Eb extends Zt{constructor(t=new $t,e=new Ou){super(),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,s=t.params.Points.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Xs.copy(n.boundingSphere),Xs.applyMatrix4(i),Xs.radius+=s,t.ray.intersectsSphere(Xs)===!1)return;Ih.copy(i).invert(),sl.copy(t.ray).applyMatrix4(Ih);const h=s/((this.scale.x+this.scale.y+this.scale.z)/3),u=h*h;if(n.isBufferGeometry){const d=n.index,g=n.attributes.position;if(d!==null){const m=Math.max(0,a.start),v=Math.min(d.count,a.start+a.count);for(let b=m,y=v;b<y;b++){const M=d.getX(b);Ys.fromBufferAttribute(g,M),Nh(Ys,M,u,i,t,e,this)}}else{const m=Math.max(0,a.start),v=Math.min(g.count,a.start+a.count);for(let b=m,y=v;b<y;b++)Ys.fromBufferAttribute(g,b),Nh(Ys,b,u,i,t,e,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const h=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[h]=s}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Eb.prototype.isPoints=!0;function Nh(o,t,e,n,i,s,a){const h=sl.distanceSqToPoint(o);if(h<e){const u=new T;sl.closestPointToPoint(o,u),u.applyMatrix4(n);const d=i.ray.origin.distanceTo(u);if(d<i.near||d>i.far)return;s.push({distance:d,distanceToRay:Math.sqrt(h),point:u,index:t,face:null,object:a})}}class Tb extends Me{constructor(t,e,n,i,s,a,h,u,d){super(t,e,n,i,s,a,h,u,d),this.format=h!==void 0?h:Xn,this.minFilter=a!==void 0?a:en,this.magFilter=s!==void 0?s:en,this.generateMipmaps=!1;const f=this;function g(){f.needsUpdate=!0,t.requestVideoFrameCallback(g)}"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(g)}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;"requestVideoFrameCallback"in t===!1&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}Tb.prototype.isVideoTexture=!0;class Cb extends Me{constructor(t,e,n,i,s,a,h,u,d,f,g,m){super(null,a,h,u,d,f,i,s,g,m),this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}Cb.prototype.isCompressedTexture=!0;class Ab extends Me{constructor(t,e,n,i,s,a,h,u,d){super(t,e,n,i,s,a,h,u,d),this.needsUpdate=!0}}Ab.prototype.isCanvasTexture=!0;class Pb extends Me{constructor(t,e,n,i,s,a,h,u,d,f){if(f=f!==void 0?f:or,f!==or&&f!==ts)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&f===or&&(n=oo),n===void 0&&f===ts&&(n=Kr),super(null,i,s,a,h,u,f,n,d),this.image={width:t,height:e},this.magFilter=h!==void 0?h:_e,this.minFilter=u!==void 0?u:_e,this.flipY=!1,this.generateMipmaps=!1}}Pb.prototype.isDepthTexture=!0;class To extends $t{constructor(t=1,e=1,n=1,i=8,s=1,a=!1,h=0,u=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:i,heightSegments:s,openEnded:a,thetaStart:h,thetaLength:u};const d=this;i=Math.floor(i),s=Math.floor(s);const f=[],g=[],m=[],v=[];let b=0;const y=[],M=n/2;let x=0;_(),a===!1&&(t>0&&R(!0),e>0&&R(!1)),this.setIndex(f),this.setAttribute("position",new ee(g,3)),this.setAttribute("normal",new ee(m,3)),this.setAttribute("uv",new ee(v,2));function _(){const L=new T,A=new T;let N=0;const C=(e-t)/n;for(let z=0;z<=s;z++){const tt=[],W=z/s,F=W*(e-t)+t;for(let rt=0;rt<=i;rt++){const H=rt/i,G=H*u+h,j=Math.sin(G),B=Math.cos(G);A.x=F*j,A.y=-W*n+M,A.z=F*B,g.push(A.x,A.y,A.z),L.set(j,C,B).normalize(),m.push(L.x,L.y,L.z),v.push(H,1-W),tt.push(b++)}y.push(tt)}for(let z=0;z<i;z++)for(let tt=0;tt<s;tt++){const W=y[tt][z],F=y[tt+1][z],rt=y[tt+1][z+1],H=y[tt][z+1];f.push(W,F,H),f.push(F,rt,H),N+=6}d.addGroup(x,N,0),x+=N}function R(L){const A=b,N=new it,C=new T;let z=0;const tt=L===!0?t:e,W=L===!0?1:-1;for(let rt=1;rt<=i;rt++)g.push(0,M*W,0),m.push(0,W,0),v.push(.5,.5),b++;const F=b;for(let rt=0;rt<=i;rt++){const G=rt/i*u+h,j=Math.cos(G),B=Math.sin(G);C.x=tt*B,C.y=M*W,C.z=tt*j,g.push(C.x,C.y,C.z),m.push(0,W,0),N.x=j*.5+.5,N.y=B*.5*W+.5,v.push(N.x,N.y),b++}for(let rt=0;rt<i;rt++){const H=A+rt,G=F+rt;L===!0?f.push(G,G+1,H):f.push(G+1,G,H),z+=3}d.addGroup(x,z,L===!0?1:2),x+=z}}static fromJSON(t){return new To(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}new T;new T;new T;new de;class nn{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,i=this.getPoint(0),s=0;e.push(0);for(let a=1;a<=t;a++)n=this.getPoint(a/t),s+=n.distanceTo(i),e.push(s),i=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const n=this.getLengths();let i=0;const s=n.length;let a;e?a=e:a=t*n[s-1];let h=0,u=s-1,d;for(;h<=u;)if(i=Math.floor(h+(u-h)/2),d=n[i]-a,d<0)h=i+1;else if(d>0)u=i-1;else{u=i;break}if(i=u,n[i]===a)return i/(s-1);const f=n[i],m=n[i+1]-f,v=(a-f)/m;return(i+v)/(s-1)}getTangent(t,e){let i=t-1e-4,s=t+1e-4;i<0&&(i=0),s>1&&(s=1);const a=this.getPoint(i),h=this.getPoint(s),u=e||(a.isVector2?new it:new T);return u.copy(h).sub(a).normalize(),u}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e){const n=new T,i=[],s=[],a=[],h=new T,u=new It;for(let v=0;v<=t;v++){const b=v/t;i[v]=this.getTangentAt(b,new T),i[v].normalize()}s[0]=new T,a[0]=new T;let d=Number.MAX_VALUE;const f=Math.abs(i[0].x),g=Math.abs(i[0].y),m=Math.abs(i[0].z);f<=d&&(d=f,n.set(1,0,0)),g<=d&&(d=g,n.set(0,1,0)),m<=d&&n.set(0,0,1),h.crossVectors(i[0],n).normalize(),s[0].crossVectors(i[0],h),a[0].crossVectors(i[0],s[0]);for(let v=1;v<=t;v++){if(s[v]=s[v-1].clone(),a[v]=a[v-1].clone(),h.crossVectors(i[v-1],i[v]),h.length()>Number.EPSILON){h.normalize();const b=Math.acos(De(i[v-1].dot(i[v]),-1,1));s[v].applyMatrix4(u.makeRotationAxis(h,b))}a[v].crossVectors(i[v],s[v])}if(e===!0){let v=Math.acos(De(s[0].dot(s[t]),-1,1));v/=t,i[0].dot(h.crossVectors(s[0],s[t]))>0&&(v=-v);for(let b=1;b<=t;b++)s[b].applyMatrix4(u.makeRotationAxis(i[b],v*b)),a[b].crossVectors(i[b],s[b])}return{tangents:i,normals:s,binormals:a}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class Co extends nn{constructor(t=0,e=0,n=1,i=1,s=0,a=Math.PI*2,h=!1,u=0){super(),this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=i,this.aStartAngle=s,this.aEndAngle=a,this.aClockwise=h,this.aRotation=u}getPoint(t,e){const n=e||new it,i=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const a=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=i;for(;s>i;)s-=i;s<Number.EPSILON&&(a?s=0:s=i),this.aClockwise===!0&&!a&&(s===i?s=-i:s=s-i);const h=this.aStartAngle+t*s;let u=this.aX+this.xRadius*Math.cos(h),d=this.aY+this.yRadius*Math.sin(h);if(this.aRotation!==0){const f=Math.cos(this.aRotation),g=Math.sin(this.aRotation),m=u-this.aX,v=d-this.aY;u=m*f-v*g+this.aX,d=m*g+v*f+this.aY}return n.set(u,d)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}Co.prototype.isEllipseCurve=!0;class zu extends Co{constructor(t,e,n,i,s,a){super(t,e,n,n,i,s,a),this.type="ArcCurve"}}zu.prototype.isArcCurve=!0;function Sl(){let o=0,t=0,e=0,n=0;function i(s,a,h,u){o=s,t=h,e=-3*s+3*a-2*h-u,n=2*s-2*a+h+u}return{initCatmullRom:function(s,a,h,u,d){i(a,h,d*(h-s),d*(u-a))},initNonuniformCatmullRom:function(s,a,h,u,d,f,g){let m=(a-s)/d-(h-s)/(d+f)+(h-a)/f,v=(h-a)/f-(u-a)/(f+g)+(u-h)/g;m*=f,v*=f,i(a,h,m,v)},calc:function(s){const a=s*s,h=a*s;return o+t*s+e*a+n*h}}}const Zs=new T,Ba=new Sl,Va=new Sl,Oa=new Sl;class Uu extends nn{constructor(t=[],e=!1,n="centripetal",i=.5){super(),this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=i}getPoint(t,e=new T){const n=e,i=this.points,s=i.length,a=(s-(this.closed?0:1))*t;let h=Math.floor(a),u=a-h;this.closed?h+=h>0?0:(Math.floor(Math.abs(h)/s)+1)*s:u===0&&h===s-1&&(h=s-2,u=1);let d,f;this.closed||h>0?d=i[(h-1)%s]:(Zs.subVectors(i[0],i[1]).add(i[0]),d=Zs);const g=i[h%s],m=i[(h+1)%s];if(this.closed||h+2<s?f=i[(h+2)%s]:(Zs.subVectors(i[s-1],i[s-2]).add(i[s-1]),f=Zs),this.curveType==="centripetal"||this.curveType==="chordal"){const v=this.curveType==="chordal"?.5:.25;let b=Math.pow(d.distanceToSquared(g),v),y=Math.pow(g.distanceToSquared(m),v),M=Math.pow(m.distanceToSquared(f),v);y<1e-4&&(y=1),b<1e-4&&(b=y),M<1e-4&&(M=y),Ba.initNonuniformCatmullRom(d.x,g.x,m.x,f.x,b,y,M),Va.initNonuniformCatmullRom(d.y,g.y,m.y,f.y,b,y,M),Oa.initNonuniformCatmullRom(d.z,g.z,m.z,f.z,b,y,M)}else this.curveType==="catmullrom"&&(Ba.initCatmullRom(d.x,g.x,m.x,f.x,this.tension),Va.initCatmullRom(d.y,g.y,m.y,f.y,this.tension),Oa.initCatmullRom(d.z,g.z,m.z,f.z,this.tension));return n.set(Ba.calc(u),Va.calc(u),Oa.calc(u)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(i.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const i=this.points[e];t.points.push(i.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(new T().fromArray(i))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}Uu.prototype.isCatmullRomCurve3=!0;function Fh(o,t,e,n,i){const s=(n-t)*.5,a=(i-e)*.5,h=o*o,u=o*h;return(2*e-2*n+s+a)*u+(-3*e+3*n-2*s-a)*h+s*o+e}function Lb(o,t){const e=1-o;return e*e*t}function Rb(o,t){return 2*(1-o)*o*t}function Db(o,t){return o*o*t}function Jr(o,t,e,n){return Lb(o,t)+Rb(o,e)+Db(o,n)}function Ib(o,t){const e=1-o;return e*e*e*t}function Nb(o,t){const e=1-o;return 3*e*e*o*t}function Fb(o,t){return 3*(1-o)*o*o*t}function kb(o,t){return o*o*o*t}function $r(o,t,e,n,i){return Ib(o,t)+Nb(o,e)+Fb(o,n)+kb(o,i)}class El extends nn{constructor(t=new it,e=new it,n=new it,i=new it){super(),this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new it){const n=e,i=this.v0,s=this.v1,a=this.v2,h=this.v3;return n.set($r(t,i.x,s.x,a.x,h.x),$r(t,i.y,s.y,a.y,h.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}El.prototype.isCubicBezierCurve=!0;class Hu extends nn{constructor(t=new T,e=new T,n=new T,i=new T){super(),this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new T){const n=e,i=this.v0,s=this.v1,a=this.v2,h=this.v3;return n.set($r(t,i.x,s.x,a.x,h.x),$r(t,i.y,s.y,a.y,h.y),$r(t,i.z,s.z,a.z,h.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Hu.prototype.isCubicBezierCurve3=!0;class Ao extends nn{constructor(t=new it,e=new it){super(),this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new it){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const n=e||new it;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Ao.prototype.isLineCurve=!0;class Bb extends nn{constructor(t=new T,e=new T){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new T){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Tl extends nn{constructor(t=new it,e=new it,n=new it){super(),this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new it){const n=e,i=this.v0,s=this.v1,a=this.v2;return n.set(Jr(t,i.x,s.x,a.x),Jr(t,i.y,s.y,a.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Tl.prototype.isQuadraticBezierCurve=!0;class Gu extends nn{constructor(t=new T,e=new T,n=new T){super(),this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new T){const n=e,i=this.v0,s=this.v1,a=this.v2;return n.set(Jr(t,i.x,s.x,a.x),Jr(t,i.y,s.y,a.y),Jr(t,i.z,s.z,a.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Gu.prototype.isQuadraticBezierCurve3=!0;class Cl extends nn{constructor(t=[]){super(),this.type="SplineCurve",this.points=t}getPoint(t,e=new it){const n=e,i=this.points,s=(i.length-1)*t,a=Math.floor(s),h=s-a,u=i[a===0?a:a-1],d=i[a],f=i[a>i.length-2?i.length-1:a+1],g=i[a>i.length-3?i.length-1:a+2];return n.set(Fh(h,u.x,d.x,f.x,g.x),Fh(h,u.y,d.y,f.y,g.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const i=this.points[e];t.points.push(i.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(new it().fromArray(i))}return this}}Cl.prototype.isSplineCurve=!0;var Wu=Object.freeze({__proto__:null,ArcCurve:zu,CatmullRomCurve3:Uu,CubicBezierCurve:El,CubicBezierCurve3:Hu,EllipseCurve:Co,LineCurve:Ao,LineCurve3:Bb,QuadraticBezierCurve:Tl,QuadraticBezierCurve3:Gu,SplineCurve:Cl});const Vb={triangulate:function(o,t,e=2){const n=t&&t.length,i=n?t[0]*e:o.length;let s=qu(o,0,i,e,!0);const a=[];if(!s||s.next===s.prev)return a;let h,u,d,f,g,m,v;if(n&&(s=Gb(o,t,s,e)),o.length>80*e){h=d=o[0],u=f=o[1];for(let b=e;b<i;b+=e)g=o[b],m=o[b+1],g<h&&(h=g),m<u&&(u=m),g>d&&(d=g),m>f&&(f=m);v=Math.max(d-h,f-u),v=v!==0?1/v:0}return is(s,a,e,h,u,v),a}};function qu(o,t,e,n,i){let s,a;if(i===ty(o,t,e,n)>0)for(s=t;s<e;s+=n)a=kh(s,o[s],o[s+1],a);else for(s=e-n;s>=t;s-=n)a=kh(s,o[s],o[s+1],a);return a&&Po(a,a.next)&&(ss(a),a=a.next),a}function $n(o,t){if(!o)return o;t||(t=o);let e=o,n;do if(n=!1,!e.steiner&&(Po(e,e.next)||ae(e.prev,e,e.next)===0)){if(ss(e),e=t=e.prev,e===e.next)break;n=!0}else e=e.next;while(n||e!==t);return t}function is(o,t,e,n,i,s,a){if(!o)return;!a&&s&&Yb(o,n,i,s);let h=o,u,d;for(;o.prev!==o.next;){if(u=o.prev,d=o.next,s?zb(o,n,i,s):Ob(o)){t.push(u.i/e),t.push(o.i/e),t.push(d.i/e),ss(o),o=d.next,h=d.next;continue}if(o=d,o===h){a?a===1?(o=Ub($n(o),t,e),is(o,t,e,n,i,s,2)):a===2&&Hb(o,t,e,n,i,s):is($n(o),t,e,n,i,s,1);break}}}function Ob(o){const t=o.prev,e=o,n=o.next;if(ae(t,e,n)>=0)return!1;let i=o.next.next;for(;i!==o.prev;){if(nr(t.x,t.y,e.x,e.y,n.x,n.y,i.x,i.y)&&ae(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function zb(o,t,e,n){const i=o.prev,s=o,a=o.next;if(ae(i,s,a)>=0)return!1;const h=i.x<s.x?i.x<a.x?i.x:a.x:s.x<a.x?s.x:a.x,u=i.y<s.y?i.y<a.y?i.y:a.y:s.y<a.y?s.y:a.y,d=i.x>s.x?i.x>a.x?i.x:a.x:s.x>a.x?s.x:a.x,f=i.y>s.y?i.y>a.y?i.y:a.y:s.y>a.y?s.y:a.y,g=ol(h,u,t,e,n),m=ol(d,f,t,e,n);let v=o.prevZ,b=o.nextZ;for(;v&&v.z>=g&&b&&b.z<=m;){if(v!==o.prev&&v!==o.next&&nr(i.x,i.y,s.x,s.y,a.x,a.y,v.x,v.y)&&ae(v.prev,v,v.next)>=0||(v=v.prevZ,b!==o.prev&&b!==o.next&&nr(i.x,i.y,s.x,s.y,a.x,a.y,b.x,b.y)&&ae(b.prev,b,b.next)>=0))return!1;b=b.nextZ}for(;v&&v.z>=g;){if(v!==o.prev&&v!==o.next&&nr(i.x,i.y,s.x,s.y,a.x,a.y,v.x,v.y)&&ae(v.prev,v,v.next)>=0)return!1;v=v.prevZ}for(;b&&b.z<=m;){if(b!==o.prev&&b!==o.next&&nr(i.x,i.y,s.x,s.y,a.x,a.y,b.x,b.y)&&ae(b.prev,b,b.next)>=0)return!1;b=b.nextZ}return!0}function Ub(o,t,e){let n=o;do{const i=n.prev,s=n.next.next;!Po(i,s)&&ju(i,n,n.next,s)&&rs(i,s)&&rs(s,i)&&(t.push(i.i/e),t.push(n.i/e),t.push(s.i/e),ss(n),ss(n.next),n=o=s),n=n.next}while(n!==o);return $n(n)}function Hb(o,t,e,n,i,s){let a=o;do{let h=a.next.next;for(;h!==a.prev;){if(a.i!==h.i&&Jb(a,h)){let u=Xu(a,h);a=$n(a,a.next),u=$n(u,u.next),is(a,t,e,n,i,s),is(u,t,e,n,i,s);return}h=h.next}a=a.next}while(a!==o)}function Gb(o,t,e,n){const i=[];let s,a,h,u,d;for(s=0,a=t.length;s<a;s++)h=t[s]*n,u=s<a-1?t[s+1]*n:o.length,d=qu(o,h,u,n,!1),d===d.next&&(d.steiner=!0),i.push(Kb(d));for(i.sort(Wb),s=0;s<i.length;s++)qb(i[s],e),e=$n(e,e.next);return e}function Wb(o,t){return o.x-t.x}function qb(o,t){if(t=jb(o,t),t){const e=Xu(t,o);$n(t,t.next),$n(e,e.next)}}function jb(o,t){let e=t;const n=o.x,i=o.y;let s=-1/0,a;do{if(i<=e.y&&i>=e.next.y&&e.next.y!==e.y){const m=e.x+(i-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(m<=n&&m>s){if(s=m,m===n){if(i===e.y)return e;if(i===e.next.y)return e.next}a=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!a)return null;if(n===s)return a;const h=a,u=a.x,d=a.y;let f=1/0,g;e=a;do n>=e.x&&e.x>=u&&n!==e.x&&nr(i<d?n:s,i,u,d,i<d?s:n,i,e.x,e.y)&&(g=Math.abs(i-e.y)/(n-e.x),rs(e,o)&&(g<f||g===f&&(e.x>a.x||e.x===a.x&&Xb(a,e)))&&(a=e,f=g)),e=e.next;while(e!==h);return a}function Xb(o,t){return ae(o.prev,o,t.prev)<0&&ae(t.next,o,o.next)<0}function Yb(o,t,e,n){let i=o;do i.z===null&&(i.z=ol(i.x,i.y,t,e,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==o);i.prevZ.nextZ=null,i.prevZ=null,Zb(i)}function Zb(o){let t,e,n,i,s,a,h,u,d=1;do{for(e=o,o=null,s=null,a=0;e;){for(a++,n=e,h=0,t=0;t<d&&(h++,n=n.nextZ,!!n);t++);for(u=d;h>0||u>0&&n;)h!==0&&(u===0||!n||e.z<=n.z)?(i=e,e=e.nextZ,h--):(i=n,n=n.nextZ,u--),s?s.nextZ=i:o=i,i.prevZ=s,s=i;e=n}s.nextZ=null,d*=2}while(a>1);return o}function ol(o,t,e,n,i){return o=32767*(o-e)*i,t=32767*(t-n)*i,o=(o|o<<8)&16711935,o=(o|o<<4)&252645135,o=(o|o<<2)&858993459,o=(o|o<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,o|t<<1}function Kb(o){let t=o,e=o;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==o);return e}function nr(o,t,e,n,i,s,a,h){return(i-a)*(t-h)-(o-a)*(s-h)>=0&&(o-a)*(n-h)-(e-a)*(t-h)>=0&&(e-a)*(s-h)-(i-a)*(n-h)>=0}function Jb(o,t){return o.next.i!==t.i&&o.prev.i!==t.i&&!$b(o,t)&&(rs(o,t)&&rs(t,o)&&Qb(o,t)&&(ae(o.prev,o,t.prev)||ae(o,t.prev,t))||Po(o,t)&&ae(o.prev,o,o.next)>0&&ae(t.prev,t,t.next)>0)}function ae(o,t,e){return(t.y-o.y)*(e.x-t.x)-(t.x-o.x)*(e.y-t.y)}function Po(o,t){return o.x===t.x&&o.y===t.y}function ju(o,t,e,n){const i=Js(ae(o,t,e)),s=Js(ae(o,t,n)),a=Js(ae(e,n,o)),h=Js(ae(e,n,t));return!!(i!==s&&a!==h||i===0&&Ks(o,e,t)||s===0&&Ks(o,n,t)||a===0&&Ks(e,o,n)||h===0&&Ks(e,t,n))}function Ks(o,t,e){return t.x<=Math.max(o.x,e.x)&&t.x>=Math.min(o.x,e.x)&&t.y<=Math.max(o.y,e.y)&&t.y>=Math.min(o.y,e.y)}function Js(o){return o>0?1:o<0?-1:0}function $b(o,t){let e=o;do{if(e.i!==o.i&&e.next.i!==o.i&&e.i!==t.i&&e.next.i!==t.i&&ju(e,e.next,o,t))return!0;e=e.next}while(e!==o);return!1}function rs(o,t){return ae(o.prev,o,o.next)<0?ae(o,t,o.next)>=0&&ae(o,o.prev,t)>=0:ae(o,t,o.prev)<0||ae(o,o.next,t)<0}function Qb(o,t){let e=o,n=!1;const i=(o.x+t.x)/2,s=(o.y+t.y)/2;do e.y>s!=e.next.y>s&&e.next.y!==e.y&&i<(e.next.x-e.x)*(s-e.y)/(e.next.y-e.y)+e.x&&(n=!n),e=e.next;while(e!==o);return n}function Xu(o,t){const e=new al(o.i,o.x,o.y),n=new al(t.i,t.x,t.y),i=o.next,s=t.prev;return o.next=t,t.prev=o,e.next=i,i.prev=e,n.next=e,e.prev=n,s.next=n,n.prev=s,n}function kh(o,t,e,n){const i=new al(o,t,e);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function ss(o){o.next.prev=o.prev,o.prev.next=o.next,o.prevZ&&(o.prevZ.nextZ=o.nextZ),o.nextZ&&(o.nextZ.prevZ=o.prevZ)}function al(o,t,e){this.i=o,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function ty(o,t,e,n){let i=0;for(let s=t,a=e-n;s<e;s+=n)i+=(o[a]-o[s])*(o[s+1]+o[a+1]),a=s;return i}class Kn{static area(t){const e=t.length;let n=0;for(let i=e-1,s=0;s<e;i=s++)n+=t[i].x*t[s].y-t[s].x*t[i].y;return n*.5}static isClockWise(t){return Kn.area(t)<0}static triangulateShape(t,e){const n=[],i=[],s=[];Bh(t),Vh(n,t);let a=t.length;e.forEach(Bh);for(let u=0;u<e.length;u++)i.push(a),a+=e[u].length,Vh(n,e[u]);const h=Vb.triangulate(n,i);for(let u=0;u<h.length;u+=3)s.push(h.slice(u,u+3));return s}}function Bh(o){const t=o.length;t>2&&o[t-1].equals(o[0])&&o.pop()}function Vh(o,t){for(let e=0;e<t.length;e++)o.push(t[e].x),o.push(t[e].y)}class br extends $t{constructor(t,e){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,i=[],s=[];for(let h=0,u=t.length;h<u;h++){const d=t[h];a(d)}this.setAttribute("position",new ee(i,3)),this.setAttribute("uv",new ee(s,2)),this.computeVertexNormals();function a(h){const u=[],d=e.curveSegments!==void 0?e.curveSegments:12,f=e.steps!==void 0?e.steps:1;let g=e.depth!==void 0?e.depth:100,m=e.bevelEnabled!==void 0?e.bevelEnabled:!0,v=e.bevelThickness!==void 0?e.bevelThickness:6,b=e.bevelSize!==void 0?e.bevelSize:v-2,y=e.bevelOffset!==void 0?e.bevelOffset:0,M=e.bevelSegments!==void 0?e.bevelSegments:3;const x=e.extrudePath,_=e.UVGenerator!==void 0?e.UVGenerator:ey;e.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),g=e.amount);let R,L=!1,A,N,C,z;x&&(R=x.getSpacedPoints(f),L=!0,m=!1,A=x.computeFrenetFrames(f,!1),N=new T,C=new T,z=new T),m||(M=0,v=0,b=0,y=0);const tt=h.extractPoints(d);let W=tt.shape;const F=tt.holes;if(!Kn.isClockWise(W)){W=W.reverse();for(let Z=0,nt=F.length;Z<nt;Z++){const lt=F[Z];Kn.isClockWise(lt)&&(F[Z]=lt.reverse())}}const H=Kn.triangulateShape(W,F),G=W;for(let Z=0,nt=F.length;Z<nt;Z++){const lt=F[Z];W=W.concat(lt)}function j(Z,nt,lt){return nt||console.error("THREE.ExtrudeGeometry: vec does not exist"),nt.clone().multiplyScalar(lt).add(Z)}const B=W.length,K=H.length;function at(Z,nt,lt){let St,ut,P;const E=Z.x-nt.x,Y=Z.y-nt.y,Q=lt.x-Z.x,ht=lt.y-Z.y,_t=E*E+Y*Y,Lt=E*ht-Y*Q;if(Math.abs(Lt)>Number.EPSILON){const Et=Math.sqrt(_t),Nt=Math.sqrt(Q*Q+ht*ht),Tt=nt.x-Y/Et,k=nt.y+E/Et,pt=lt.x-ht/Nt,$=lt.y+Q/Nt,gt=((pt-Tt)*ht-($-k)*Q)/(E*ht-Y*Q);St=Tt+E*gt-Z.x,ut=k+Y*gt-Z.y;const D=St*St+ut*ut;if(D<=2)return new it(St,ut);P=Math.sqrt(D/2)}else{let Et=!1;E>Number.EPSILON?Q>Number.EPSILON&&(Et=!0):E<-Number.EPSILON?Q<-Number.EPSILON&&(Et=!0):Math.sign(Y)===Math.sign(ht)&&(Et=!0),Et?(St=-Y,ut=E,P=Math.sqrt(_t)):(St=E,ut=Y,P=Math.sqrt(_t/2))}return new it(St/P,ut/P)}const yt=[];for(let Z=0,nt=G.length,lt=nt-1,St=Z+1;Z<nt;Z++,lt++,St++)lt===nt&&(lt=0),St===nt&&(St=0),yt[Z]=at(G[Z],G[lt],G[St]);const bt=[];let mt,vt=yt.concat();for(let Z=0,nt=F.length;Z<nt;Z++){const lt=F[Z];mt=[];for(let St=0,ut=lt.length,P=ut-1,E=St+1;St<ut;St++,P++,E++)P===ut&&(P=0),E===ut&&(E=0),mt[St]=at(lt[St],lt[P],lt[E]);bt.push(mt),vt=vt.concat(mt)}for(let Z=0;Z<M;Z++){const nt=Z/M,lt=v*Math.cos(nt*Math.PI/2),St=b*Math.sin(nt*Math.PI/2)+y;for(let ut=0,P=G.length;ut<P;ut++){const E=j(G[ut],yt[ut],St);Ct(E.x,E.y,-lt)}for(let ut=0,P=F.length;ut<P;ut++){const E=F[ut];mt=bt[ut];for(let Y=0,Q=E.length;Y<Q;Y++){const ht=j(E[Y],mt[Y],St);Ct(ht.x,ht.y,-lt)}}}const J=b+y;for(let Z=0;Z<B;Z++){const nt=m?j(W[Z],vt[Z],J):W[Z];L?(C.copy(A.normals[0]).multiplyScalar(nt.x),N.copy(A.binormals[0]).multiplyScalar(nt.y),z.copy(R[0]).add(C).add(N),Ct(z.x,z.y,z.z)):Ct(nt.x,nt.y,0)}for(let Z=1;Z<=f;Z++)for(let nt=0;nt<B;nt++){const lt=m?j(W[nt],vt[nt],J):W[nt];L?(C.copy(A.normals[Z]).multiplyScalar(lt.x),N.copy(A.binormals[Z]).multiplyScalar(lt.y),z.copy(R[Z]).add(C).add(N),Ct(z.x,z.y,z.z)):Ct(lt.x,lt.y,g/f*Z)}for(let Z=M-1;Z>=0;Z--){const nt=Z/M,lt=v*Math.cos(nt*Math.PI/2),St=b*Math.sin(nt*Math.PI/2)+y;for(let ut=0,P=G.length;ut<P;ut++){const E=j(G[ut],yt[ut],St);Ct(E.x,E.y,g+lt)}for(let ut=0,P=F.length;ut<P;ut++){const E=F[ut];mt=bt[ut];for(let Y=0,Q=E.length;Y<Q;Y++){const ht=j(E[Y],mt[Y],St);L?Ct(ht.x,ht.y+R[f-1].y,R[f-1].x+lt):Ct(ht.x,ht.y,g+lt)}}}st(),Mt();function st(){const Z=i.length/3;if(m){let nt=0,lt=B*nt;for(let St=0;St<K;St++){const ut=H[St];At(ut[2]+lt,ut[1]+lt,ut[0]+lt)}nt=f+M*2,lt=B*nt;for(let St=0;St<K;St++){const ut=H[St];At(ut[0]+lt,ut[1]+lt,ut[2]+lt)}}else{for(let nt=0;nt<K;nt++){const lt=H[nt];At(lt[2],lt[1],lt[0])}for(let nt=0;nt<K;nt++){const lt=H[nt];At(lt[0]+B*f,lt[1]+B*f,lt[2]+B*f)}}n.addGroup(Z,i.length/3-Z,0)}function Mt(){const Z=i.length/3;let nt=0;q(G,nt),nt+=G.length;for(let lt=0,St=F.length;lt<St;lt++){const ut=F[lt];q(ut,nt),nt+=ut.length}n.addGroup(Z,i.length/3-Z,1)}function q(Z,nt){let lt=Z.length;for(;--lt>=0;){const St=lt;let ut=lt-1;ut<0&&(ut=Z.length-1);for(let P=0,E=f+M*2;P<E;P++){const Y=B*P,Q=B*(P+1),ht=nt+St+Y,_t=nt+ut+Y,Lt=nt+ut+Q,Et=nt+St+Q;dt(ht,_t,Lt,Et)}}}function Ct(Z,nt,lt){u.push(Z),u.push(nt),u.push(lt)}function At(Z,nt,lt){xt(Z),xt(nt),xt(lt);const St=i.length/3,ut=_.generateTopUV(n,i,St-3,St-2,St-1);kt(ut[0]),kt(ut[1]),kt(ut[2])}function dt(Z,nt,lt,St){xt(Z),xt(nt),xt(St),xt(nt),xt(lt),xt(St);const ut=i.length/3,P=_.generateSideWallUV(n,i,ut-6,ut-3,ut-2,ut-1);kt(P[0]),kt(P[1]),kt(P[3]),kt(P[1]),kt(P[2]),kt(P[3])}function xt(Z){i.push(u[Z*3+0]),i.push(u[Z*3+1]),i.push(u[Z*3+2])}function kt(Z){s.push(Z.x),s.push(Z.y)}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes,n=this.parameters.options;return ny(e,n,t)}static fromJSON(t,e){const n=[];for(let s=0,a=t.shapes.length;s<a;s++){const h=e[t.shapes[s]];n.push(h)}const i=t.options.extrudePath;return i!==void 0&&(t.options.extrudePath=new Wu[i.type]().fromJSON(i)),new br(n,t.options)}}const ey={generateTopUV:function(o,t,e,n,i){const s=t[e*3],a=t[e*3+1],h=t[n*3],u=t[n*3+1],d=t[i*3],f=t[i*3+1];return[new it(s,a),new it(h,u),new it(d,f)]},generateSideWallUV:function(o,t,e,n,i,s){const a=t[e*3],h=t[e*3+1],u=t[e*3+2],d=t[n*3],f=t[n*3+1],g=t[n*3+2],m=t[i*3],v=t[i*3+1],b=t[i*3+2],y=t[s*3],M=t[s*3+1],x=t[s*3+2];return Math.abs(h-f)<Math.abs(a-d)?[new it(a,1-u),new it(d,1-g),new it(m,1-b),new it(y,1-x)]:[new it(h,1-u),new it(f,1-g),new it(v,1-b),new it(M,1-x)]}};function ny(o,t,e){if(e.shapes=[],Array.isArray(o))for(let n=0,i=o.length;n<i;n++){const s=o[n];e.shapes.push(s.uuid)}else e.shapes.push(o.uuid);return t.extrudePath!==void 0&&(e.options.extrudePath=t.extrudePath.toJSON()),e}class Al extends $t{constructor(t,e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],i=[],s=[],a=[];let h=0,u=0;if(Array.isArray(t)===!1)d(t);else for(let f=0;f<t.length;f++)d(t[f]),this.addGroup(h,u,f),h+=u,u=0;this.setIndex(n),this.setAttribute("position",new ee(i,3)),this.setAttribute("normal",new ee(s,3)),this.setAttribute("uv",new ee(a,2));function d(f){const g=i.length/3,m=f.extractPoints(e);let v=m.shape;const b=m.holes;Kn.isClockWise(v)===!1&&(v=v.reverse());for(let M=0,x=b.length;M<x;M++){const _=b[M];Kn.isClockWise(_)===!0&&(b[M]=_.reverse())}const y=Kn.triangulateShape(v,b);for(let M=0,x=b.length;M<x;M++){const _=b[M];v=v.concat(_)}for(let M=0,x=v.length;M<x;M++){const _=v[M];i.push(_.x,_.y,0),s.push(0,0,1),a.push(_.x,_.y)}for(let M=0,x=y.length;M<x;M++){const _=y[M],R=_[0]+g,L=_[1]+g,A=_[2]+g;n.push(R,L,A),u+=3}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes;return iy(e,t)}static fromJSON(t,e){const n=[];for(let i=0,s=t.shapes.length;i<s;i++){const a=e[t.shapes[i]];n.push(a)}return new Al(n,t.curveSegments)}}function iy(o,t){if(t.shapes=[],Array.isArray(o))for(let e=0,n=o.length;e<n;e++){const i=o[e];t.shapes.push(i.uuid)}else t.shapes.push(o.uuid);return t}class Pl extends $t{constructor(t=1,e=32,n=16,i=0,s=Math.PI*2,a=0,h=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:i,phiLength:s,thetaStart:a,thetaLength:h},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const u=Math.min(a+h,Math.PI);let d=0;const f=[],g=new T,m=new T,v=[],b=[],y=[],M=[];for(let x=0;x<=n;x++){const _=[],R=x/n;let L=0;x==0&&a==0?L=.5/e:x==n&&u==Math.PI&&(L=-.5/e);for(let A=0;A<=e;A++){const N=A/e;g.x=-t*Math.cos(i+N*s)*Math.sin(a+R*h),g.y=t*Math.cos(a+R*h),g.z=t*Math.sin(i+N*s)*Math.sin(a+R*h),b.push(g.x,g.y,g.z),m.copy(g).normalize(),y.push(m.x,m.y,m.z),M.push(N+L,1-R),_.push(d++)}f.push(_)}for(let x=0;x<n;x++)for(let _=0;_<e;_++){const R=f[x][_+1],L=f[x][_],A=f[x+1][_],N=f[x+1][_+1];(x!==0||a>0)&&v.push(R,L,N),(x!==n-1||u<Math.PI)&&v.push(L,A,N)}this.setIndex(v),this.setAttribute("position",new ee(b,3)),this.setAttribute("normal",new ee(y,3)),this.setAttribute("uv",new ee(M,2))}static fromJSON(t){return new Pl(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class ry extends Pe{constructor(t){super(),this.type="ShadowMaterial",this.color=new wt(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}ry.prototype.isShadowMaterial=!0;class Yu extends Pe{constructor(t){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new wt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new wt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=fr,this.normalScale=new it(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}Yu.prototype.isMeshStandardMaterial=!0;class sy extends Yu{constructor(t){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new it(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return De(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.sheenTint=new wt(0),this.transmission=0,this.transmissionMap=null,this.thickness=.01,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationTint=new wt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularTint=new wt(1,1,1),this.specularTintMap=null,this._clearcoat=0,this._transmission=0,this.setValues(t)}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.sheenTint.copy(t.sheenTint),this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationTint.copy(t.attenuationTint),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularTint.copy(t.specularTint),this.specularTintMap=t.specularTintMap,this}}sy.prototype.isMeshPhysicalMaterial=!0;class oy extends Pe{constructor(t){super(),this.type="MeshPhongMaterial",this.color=new wt(16777215),this.specular=new wt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new wt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=fr,this.normalScale=new it(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=mo,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}oy.prototype.isMeshPhongMaterial=!0;class ay extends Pe{constructor(t){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new wt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new wt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=fr,this.normalScale=new it(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}ay.prototype.isMeshToonMaterial=!0;class ly extends Pe{constructor(t){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=fr,this.normalScale=new it(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}ly.prototype.isMeshNormalMaterial=!0;class cy extends Pe{constructor(t){super(),this.type="MeshLambertMaterial",this.color=new wt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new wt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=mo,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}cy.prototype.isMeshLambertMaterial=!0;class hy extends Pe{constructor(t){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new wt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=fr,this.normalScale=new it(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this}}hy.prototype.isMeshMatcapMaterial=!0;class uy extends xr{constructor(t){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}uy.prototype.isLineDashedMaterial=!0;const oe={arraySlice:function(o,t,e){return oe.isTypedArray(o)?new o.constructor(o.subarray(t,e!==void 0?e:o.length)):o.slice(t,e)},convertArray:function(o,t,e){return!o||!e&&o.constructor===t?o:typeof t.BYTES_PER_ELEMENT=="number"?new t(o):Array.prototype.slice.call(o)},isTypedArray:function(o){return ArrayBuffer.isView(o)&&!(o instanceof DataView)},getKeyframeOrder:function(o){function t(i,s){return o[i]-o[s]}const e=o.length,n=new Array(e);for(let i=0;i!==e;++i)n[i]=i;return n.sort(t),n},sortedArray:function(o,t,e){const n=o.length,i=new o.constructor(n);for(let s=0,a=0;a!==n;++s){const h=e[s]*t;for(let u=0;u!==t;++u)i[a++]=o[h+u]}return i},flattenJSON:function(o,t,e,n){let i=1,s=o[0];for(;s!==void 0&&s[n]===void 0;)s=o[i++];if(s===void 0)return;let a=s[n];if(a!==void 0)if(Array.isArray(a))do a=s[n],a!==void 0&&(t.push(s.time),e.push.apply(e,a)),s=o[i++];while(s!==void 0);else if(a.toArray!==void 0)do a=s[n],a!==void 0&&(t.push(s.time),a.toArray(e,e.length)),s=o[i++];while(s!==void 0);else do a=s[n],a!==void 0&&(t.push(s.time),e.push(a)),s=o[i++];while(s!==void 0)},subclip:function(o,t,e,n,i=30){const s=o.clone();s.name=t;const a=[];for(let u=0;u<s.tracks.length;++u){const d=s.tracks[u],f=d.getValueSize(),g=[],m=[];for(let v=0;v<d.times.length;++v){const b=d.times[v]*i;if(!(b<e||b>=n)){g.push(d.times[v]);for(let y=0;y<f;++y)m.push(d.values[v*f+y])}}g.length!==0&&(d.times=oe.convertArray(g,d.times.constructor),d.values=oe.convertArray(m,d.values.constructor),a.push(d))}s.tracks=a;let h=1/0;for(let u=0;u<s.tracks.length;++u)h>s.tracks[u].times[0]&&(h=s.tracks[u].times[0]);for(let u=0;u<s.tracks.length;++u)s.tracks[u].shift(-1*h);return s.resetDuration(),s},makeClipAdditive:function(o,t=0,e=o,n=30){n<=0&&(n=30);const i=e.tracks.length,s=t/n;for(let a=0;a<i;++a){const h=e.tracks[a],u=h.ValueTypeName;if(u==="bool"||u==="string")continue;const d=o.tracks.find(function(x){return x.name===h.name&&x.ValueTypeName===u});if(d===void 0)continue;let f=0;const g=h.getValueSize();h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(f=g/3);let m=0;const v=d.getValueSize();d.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(m=v/3);const b=h.times.length-1;let y;if(s<=h.times[0]){const x=f,_=g-f;y=oe.arraySlice(h.values,x,_)}else if(s>=h.times[b]){const x=b*g+f,_=x+g-f;y=oe.arraySlice(h.values,x,_)}else{const x=h.createInterpolant(),_=f,R=g-f;x.evaluate(s),y=oe.arraySlice(x.resultBuffer,_,R)}u==="quaternion"&&new we().fromArray(y).normalize().conjugate().toArray(y);const M=d.times.length;for(let x=0;x<M;++x){const _=x*v+m;if(u==="quaternion")we.multiplyQuaternionsFlat(d.values,_,y,0,d.values,_);else{const R=v-m*2;for(let L=0;L<R;++L)d.values[_+L]-=y[L]}}}return o.blendMode=cu,o}};class Qn{constructor(t,e,n,i){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,i=e[n],s=e[n-1];t:{e:{let a;n:{i:if(!(t<i)){for(let h=n+2;;){if(i===void 0){if(t<s)break i;return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,t,s)}if(n===h)break;if(s=i,i=e[++n],t<i)break e}a=e.length;break n}if(!(t>=s)){const h=e[1];t<h&&(n=2,s=h);for(let u=n-2;;){if(s===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(n===u)break;if(i=s,s=e[--n-1],t>=s)break e}a=n,n=0;break n}break t}for(;n<a;){const h=n+a>>>1;t<e[h]?a=h:n=h+1}if(i=e[n],s=e[n-1],s===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(i===void 0)return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,s,t)}this._cachedIndex=n,this.intervalChanged_(n,s,i)}return this.interpolate_(n,s,t,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,s=t*i;for(let a=0;a!==i;++a)e[a]=n[s+a];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}Qn.prototype.beforeStart_=Qn.prototype.copySampleValue_;Qn.prototype.afterEnd_=Qn.prototype.copySampleValue_;class dy extends Qn{constructor(t,e,n,i){super(t,e,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:tr,endingEnd:tr}}intervalChanged_(t,e,n){const i=this.parameterPositions;let s=t-2,a=t+1,h=i[s],u=i[a];if(h===void 0)switch(this.getSettings_().endingStart){case er:s=t,h=2*e-n;break;case co:s=i.length-2,h=e+i[s]-i[s+1];break;default:s=t,h=n}if(u===void 0)switch(this.getSettings_().endingEnd){case er:a=t,u=2*n-e;break;case co:a=1,u=n+i[1]-i[0];break;default:a=t-1,u=e}const d=(n-e)*.5,f=this.valueSize;this._weightPrev=d/(e-h),this._weightNext=d/(u-n),this._offsetPrev=s*f,this._offsetNext=a*f}interpolate_(t,e,n,i){const s=this.resultBuffer,a=this.sampleValues,h=this.valueSize,u=t*h,d=u-h,f=this._offsetPrev,g=this._offsetNext,m=this._weightPrev,v=this._weightNext,b=(n-e)/(i-e),y=b*b,M=y*b,x=-m*M+2*m*y-m*b,_=(1+m)*M+(-1.5-2*m)*y+(-.5+m)*b+1,R=(-1-v)*M+(1.5+v)*y+.5*b,L=v*M-v*y;for(let A=0;A!==h;++A)s[A]=x*a[f+A]+_*a[d+A]+R*a[u+A]+L*a[g+A];return s}}class Zu extends Qn{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const s=this.resultBuffer,a=this.sampleValues,h=this.valueSize,u=t*h,d=u-h,f=(n-e)/(i-e),g=1-f;for(let m=0;m!==h;++m)s[m]=a[d+m]*g+a[u+m]*f;return s}}class py extends Qn{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t){return this.copySampleValue_(t-1)}}class Sn{constructor(t,e,n,i){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=oe.convertArray(e,this.TimeBufferType),this.values=oe.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:oe.convertArray(t.times,Array),values:oe.convertArray(t.values,Array)};const i=t.getInterpolation();i!==t.DefaultInterpolation&&(n.interpolation=i)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new py(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new Zu(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new dy(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case ao:e=this.InterpolantFactoryMethodDiscrete;break;case lo:e=this.InterpolantFactoryMethodLinear;break;case ra:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return ao;case this.InterpolantFactoryMethodLinear:return lo;case this.InterpolantFactoryMethodSmooth:return ra}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]*=t}return this}trim(t,e){const n=this.times,i=n.length;let s=0,a=i-1;for(;s!==i&&n[s]<t;)++s;for(;a!==-1&&n[a]>e;)--a;if(++a,s!==0||a!==i){s>=a&&(a=Math.max(a,1),s=a-1);const h=this.getValueSize();this.times=oe.arraySlice(n,s,a),this.values=oe.arraySlice(this.values,s*h,a*h)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,i=this.values,s=n.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let a=null;for(let h=0;h!==s;h++){const u=n[h];if(typeof u=="number"&&isNaN(u)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,h,u),t=!1;break}if(a!==null&&a>u){console.error("THREE.KeyframeTrack: Out of order keys.",this,h,u,a),t=!1;break}a=u}if(i!==void 0&&oe.isTypedArray(i))for(let h=0,u=i.length;h!==u;++h){const d=i[h];if(isNaN(d)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,h,d),t=!1;break}}return t}optimize(){const t=oe.arraySlice(this.times),e=oe.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===ra,s=t.length-1;let a=1;for(let h=1;h<s;++h){let u=!1;const d=t[h],f=t[h+1];if(d!==f&&(h!==1||d!==t[0]))if(i)u=!0;else{const g=h*n,m=g-n,v=g+n;for(let b=0;b!==n;++b){const y=e[g+b];if(y!==e[m+b]||y!==e[v+b]){u=!0;break}}}if(u){if(h!==a){t[a]=t[h];const g=h*n,m=a*n;for(let v=0;v!==n;++v)e[m+v]=e[g+v]}++a}}if(s>0){t[a]=t[s];for(let h=s*n,u=a*n,d=0;d!==n;++d)e[u+d]=e[h+d];++a}return a!==t.length?(this.times=oe.arraySlice(t,0,a),this.values=oe.arraySlice(e,0,a*n)):(this.times=t,this.values=e),this}clone(){const t=oe.arraySlice(this.times,0),e=oe.arraySlice(this.values,0),n=this.constructor,i=new n(this.name,t,e);return i.createInterpolant=this.createInterpolant,i}}Sn.prototype.TimeBufferType=Float32Array;Sn.prototype.ValueBufferType=Float32Array;Sn.prototype.DefaultInterpolation=lo;class yr extends Sn{}yr.prototype.ValueTypeName="bool";yr.prototype.ValueBufferType=Array;yr.prototype.DefaultInterpolation=ao;yr.prototype.InterpolantFactoryMethodLinear=void 0;yr.prototype.InterpolantFactoryMethodSmooth=void 0;class Ku extends Sn{}Ku.prototype.ValueTypeName="color";class uo extends Sn{}uo.prototype.ValueTypeName="number";class fy extends Qn{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const s=this.resultBuffer,a=this.sampleValues,h=this.valueSize,u=(n-e)/(i-e);let d=t*h;for(let f=d+h;d!==f;d+=4)we.slerpFlat(s,0,a,d-h,a,d,u);return s}}class ls extends Sn{InterpolantFactoryMethodLinear(t){return new fy(this.times,this.values,this.getValueSize(),t)}}ls.prototype.ValueTypeName="quaternion";ls.prototype.DefaultInterpolation=lo;ls.prototype.InterpolantFactoryMethodSmooth=void 0;class wr extends Sn{}wr.prototype.ValueTypeName="string";wr.prototype.ValueBufferType=Array;wr.prototype.DefaultInterpolation=ao;wr.prototype.InterpolantFactoryMethodLinear=void 0;wr.prototype.InterpolantFactoryMethodSmooth=void 0;class po extends Sn{}po.prototype.ValueTypeName="vector";class Oh{constructor(t,e=-1,n,i=pl){this.name=t,this.tracks=n,this.duration=e,this.blendMode=i,this.uuid=bn(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,i=1/(t.fps||1);for(let a=0,h=n.length;a!==h;++a)e.push(gy(n[a]).scale(i));const s=new this(t.name,t.duration,e,t.blendMode);return s.uuid=t.uuid,s}static toJSON(t){const e=[],n=t.tracks,i={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let s=0,a=n.length;s!==a;++s)e.push(Sn.toJSON(n[s]));return i}static CreateFromMorphTargetSequence(t,e,n,i){const s=e.length,a=[];for(let h=0;h<s;h++){let u=[],d=[];u.push((h+s-1)%s,h,(h+1)%s),d.push(0,1,0);const f=oe.getKeyframeOrder(u);u=oe.sortedArray(u,1,f),d=oe.sortedArray(d,1,f),!i&&u[0]===0&&(u.push(s),d.push(d[0])),a.push(new uo(".morphTargetInfluences["+e[h].name+"]",u,d).scale(1/n))}return new this(t,-1,a)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const i=t;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===e)return n[i];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const i={},s=/^([\w-]*?)([\d]+)$/;for(let h=0,u=t.length;h<u;h++){const d=t[h],f=d.name.match(s);if(f&&f.length>1){const g=f[1];let m=i[g];m||(i[g]=m=[]),m.push(d)}}const a=[];for(const h in i)a.push(this.CreateFromMorphTargetSequence(h,i[h],e,n));return a}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(g,m,v,b,y){if(v.length!==0){const M=[],x=[];oe.flattenJSON(v,M,x,b),M.length!==0&&y.push(new g(m,M,x))}},i=[],s=t.name||"default",a=t.fps||30,h=t.blendMode;let u=t.length||-1;const d=t.hierarchy||[];for(let g=0;g<d.length;g++){const m=d[g].keys;if(!(!m||m.length===0))if(m[0].morphTargets){const v={};let b;for(b=0;b<m.length;b++)if(m[b].morphTargets)for(let y=0;y<m[b].morphTargets.length;y++)v[m[b].morphTargets[y]]=-1;for(const y in v){const M=[],x=[];for(let _=0;_!==m[b].morphTargets.length;++_){const R=m[b];M.push(R.time),x.push(R.morphTarget===y?1:0)}i.push(new uo(".morphTargetInfluence["+y+"]",M,x))}u=v.length*(a||1)}else{const v=".bones["+e[g].name+"]";n(po,v+".position",m,"pos",i),n(ls,v+".quaternion",m,"rot",i),n(po,v+".scale",m,"scl",i)}}return i.length===0?null:new this(s,u,i,h)}resetDuration(){const t=this.tracks;let e=0;for(let n=0,i=t.length;n!==i;++n){const s=this.tracks[n];e=Math.max(e,s.times[s.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function my(o){switch(o.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return uo;case"vector":case"vector2":case"vector3":case"vector4":return po;case"color":return Ku;case"quaternion":return ls;case"bool":case"boolean":return yr;case"string":return wr}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+o)}function gy(o){if(o.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=my(o.type);if(o.times===void 0){const e=[],n=[];oe.flattenJSON(o.keys,e,n,"value"),o.times=e,o.values=n}return t.parse!==void 0?t.parse(o):new t(o.name,o.times,o.values,o.interpolation)}const pr={enabled:!1,files:{},add:function(o,t){this.enabled!==!1&&(this.files[o]=t)},get:function(o){if(this.enabled!==!1)return this.files[o]},remove:function(o){delete this.files[o]},clear:function(){this.files={}}};class vy{constructor(t,e,n){const i=this;let s=!1,a=0,h=0,u;const d=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(f){h++,s===!1&&i.onStart!==void 0&&i.onStart(f,a,h),s=!0},this.itemEnd=function(f){a++,i.onProgress!==void 0&&i.onProgress(f,a,h),a===h&&(s=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(f){i.onError!==void 0&&i.onError(f)},this.resolveURL=function(f){return u?u(f):f},this.setURLModifier=function(f){return u=f,this},this.addHandler=function(f,g){return d.push(f,g),this},this.removeHandler=function(f){const g=d.indexOf(f);return g!==-1&&d.splice(g,2),this},this.getHandler=function(f){for(let g=0,m=d.length;g<m;g+=2){const v=d[g],b=d[g+1];if(v.global&&(v.lastIndex=0),v.test(f))return b}return null}}}const _y=new vy;class ei{constructor(t){this.manager=t!==void 0?t:_y,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise(function(i,s){n.load(t,i,e,s)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const cn={};class xy extends ei{constructor(t){super(t)}load(t,e,n,i){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,a=pr.get(t);if(a!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(a),s.manager.itemEnd(t)},0),a;if(cn[t]!==void 0){cn[t].push({onLoad:e,onProgress:n,onError:i});return}const h=/^data:(.*?)(;base64)?,(.*)$/,u=t.match(h);let d;if(u){const f=u[1],g=!!u[2];let m=u[3];m=decodeURIComponent(m),g&&(m=atob(m));try{let v;const b=(this.responseType||"").toLowerCase();switch(b){case"arraybuffer":case"blob":const y=new Uint8Array(m.length);for(let x=0;x<m.length;x++)y[x]=m.charCodeAt(x);b==="blob"?v=new Blob([y.buffer],{type:f}):v=y.buffer;break;case"document":v=new DOMParser().parseFromString(m,f);break;case"json":v=JSON.parse(m);break;default:v=m;break}setTimeout(function(){e&&e(v),s.manager.itemEnd(t)},0)}catch(v){setTimeout(function(){i&&i(v),s.manager.itemError(t),s.manager.itemEnd(t)},0)}}else{cn[t]=[],cn[t].push({onLoad:e,onProgress:n,onError:i}),d=new XMLHttpRequest,d.open("GET",t,!0),d.addEventListener("load",function(f){const g=this.response,m=cn[t];if(delete cn[t],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),pr.add(t,g);for(let v=0,b=m.length;v<b;v++){const y=m[v];y.onLoad&&y.onLoad(g)}s.manager.itemEnd(t)}else{for(let v=0,b=m.length;v<b;v++){const y=m[v];y.onError&&y.onError(f)}s.manager.itemError(t),s.manager.itemEnd(t)}},!1),d.addEventListener("progress",function(f){const g=cn[t];for(let m=0,v=g.length;m<v;m++){const b=g[m];b.onProgress&&b.onProgress(f)}},!1),d.addEventListener("error",function(f){const g=cn[t];delete cn[t];for(let m=0,v=g.length;m<v;m++){const b=g[m];b.onError&&b.onError(f)}s.manager.itemError(t),s.manager.itemEnd(t)},!1),d.addEventListener("abort",function(f){const g=cn[t];delete cn[t];for(let m=0,v=g.length;m<v;m++){const b=g[m];b.onError&&b.onError(f)}s.manager.itemError(t),s.manager.itemEnd(t)},!1),this.responseType!==void 0&&(d.responseType=this.responseType),this.withCredentials!==void 0&&(d.withCredentials=this.withCredentials),d.overrideMimeType&&d.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const f in this.requestHeader)d.setRequestHeader(f,this.requestHeader[f]);d.send(null)}return s.manager.itemStart(t),d}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class Ju extends ei{constructor(t){super(t)}load(t,e,n,i){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,a=pr.get(t);if(a!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(a),s.manager.itemEnd(t)},0),a;const h=document.createElementNS("http://www.w3.org/1999/xhtml","img");function u(){h.removeEventListener("load",u,!1),h.removeEventListener("error",d,!1),pr.add(t,this),e&&e(this),s.manager.itemEnd(t)}function d(f){h.removeEventListener("load",u,!1),h.removeEventListener("error",d,!1),i&&i(f),s.manager.itemError(t),s.manager.itemEnd(t)}return h.addEventListener("load",u,!1),h.addEventListener("error",d,!1),t.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(h.crossOrigin=this.crossOrigin),s.manager.itemStart(t),h.src=t,h}}class by extends ei{constructor(t){super(t)}load(t,e,n,i){const s=new yo,a=new Ju(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let h=0;function u(d){a.load(t[d],function(f){s.images[d]=f,h++,h===6&&(s.needsUpdate=!0,e&&e(s))},void 0,i)}for(let d=0;d<t.length;++d)u(d);return s}}class yy extends ei{constructor(t){super(t)}load(t,e,n,i){const s=new Me,a=new Ju(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(t,function(h){s.image=h;const u=t.search(/\.jpe?g($|\?)/i)>0||t.search(/^data\:image\/jpeg/)===0;s.format=u?Xn:Ye,s.needsUpdate=!0,e!==void 0&&e(s)},n,i),s}}class wy extends nn{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new Ao(e,t))}getPoint(t){const e=t*this.getLength(),n=this.getCurveLengths();let i=0;for(;i<n.length;){if(n[i]>=e){const s=n[i]-e,a=this.curves[i],h=a.getLength(),u=h===0?0:1-s/h;return a.getPointAt(u)}i++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,i=this.curves.length;n<i;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let i=0,s=this.curves;i<s.length;i++){const a=s[i],h=a&&a.isEllipseCurve?t*2:a&&(a.isLineCurve||a.isLineCurve3)?1:a&&a.isSplineCurve?t*a.points.length:t,u=a.getPoints(h);for(let d=0;d<u.length;d++){const f=u[d];n&&n.equals(f)||(e.push(f),n=f)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const i=t.curves[e];this.curves.push(i.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const i=this.curves[e];t.curves.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const i=t.curves[e];this.curves.push(new Wu[i.type]().fromJSON(i))}return this}}class ll extends wy{constructor(t){super(),this.type="Path",this.currentPoint=new it,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new Ao(this.currentPoint.clone(),new it(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,i){const s=new Tl(this.currentPoint.clone(),new it(t,e),new it(n,i));return this.curves.push(s),this.currentPoint.set(n,i),this}bezierCurveTo(t,e,n,i,s,a){const h=new El(this.currentPoint.clone(),new it(t,e),new it(n,i),new it(s,a));return this.curves.push(h),this.currentPoint.set(s,a),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new Cl(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,i,s,a){const h=this.currentPoint.x,u=this.currentPoint.y;return this.absarc(t+h,e+u,n,i,s,a),this}absarc(t,e,n,i,s,a){return this.absellipse(t,e,n,n,i,s,a),this}ellipse(t,e,n,i,s,a,h,u){const d=this.currentPoint.x,f=this.currentPoint.y;return this.absellipse(t+d,e+f,n,i,s,a,h,u),this}absellipse(t,e,n,i,s,a,h,u){const d=new Co(t,e,n,i,s,a,h,u);if(this.curves.length>0){const g=d.getPoint(0);g.equals(this.currentPoint)||this.lineTo(g.x,g.y)}this.curves.push(d);const f=d.getPoint(1);return this.currentPoint.copy(f),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class Ll extends ll{constructor(t){super(t),this.uuid=bn(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,i=this.holes.length;n<i;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const i=t.holes[e];this.holes.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const i=this.holes[e];t.holes.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const i=t.holes[e];this.holes.push(new ll().fromJSON(i))}return this}}class Mn extends Zt{constructor(t,e=1){super(),this.type="Light",this.color=new wt(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}Mn.prototype.isLight=!0;class $u extends Mn{constructor(t,e,n){super(t,n),this.type="HemisphereLight",this.position.copy(Zt.DefaultUp),this.updateMatrix(),this.groundColor=new wt(e)}copy(t){return Mn.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}$u.prototype.isHemisphereLight=!0;const zh=new It,Uh=new T,Hh=new T;class Rl{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new it(512,512),this.map=null,this.mapPass=null,this.matrix=new It,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new wo,this._frameExtents=new it(1,1),this._viewportCount=1,this._viewports=[new te(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;Uh.setFromMatrixPosition(t.matrixWorld),e.position.copy(Uh),Hh.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Hh),e.updateMatrixWorld(),zh.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(zh),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Qu extends Rl{constructor(){super(new Ie(50,1,.5,500)),this.focus=1}updateMatrices(t){const e=this.camera,n=nl*2*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height,s=t.distance||e.far;(n!==e.fov||i!==e.aspect||s!==e.far)&&(e.fov=n,e.aspect=i,e.far=s,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}Qu.prototype.isSpotLightShadow=!0;class My extends Mn{constructor(t,e,n=0,i=Math.PI/3,s=0,a=1){super(t,e),this.type="SpotLight",this.position.copy(Zt.DefaultUp),this.updateMatrix(),this.target=new Zt,this.distance=n,this.angle=i,this.penumbra=s,this.decay=a,this.shadow=new Qu}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}My.prototype.isSpotLight=!0;const Gh=new It,Wr=new T,za=new T;class td extends Rl{constructor(){super(new Ie(90,1,.5,500)),this._frameExtents=new it(4,2),this._viewportCount=6,this._viewports=[new te(2,1,1,1),new te(0,1,1,1),new te(3,1,1,1),new te(1,1,1,1),new te(3,0,1,1),new te(1,0,1,1)],this._cubeDirections=[new T(1,0,0),new T(-1,0,0),new T(0,0,1),new T(0,0,-1),new T(0,1,0),new T(0,-1,0)],this._cubeUps=[new T(0,1,0),new T(0,1,0),new T(0,1,0),new T(0,1,0),new T(0,0,1),new T(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,i=this.matrix,s=t.distance||n.far;s!==n.far&&(n.far=s,n.updateProjectionMatrix()),Wr.setFromMatrixPosition(t.matrixWorld),n.position.copy(Wr),za.copy(n.position),za.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(za),n.updateMatrixWorld(),i.makeTranslation(-Wr.x,-Wr.y,-Wr.z),Gh.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Gh)}}td.prototype.isPointLightShadow=!0;class Sy extends Mn{constructor(t,e,n=0,i=1){super(t,e),this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new td}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}Sy.prototype.isPointLight=!0;class ed extends Rl{constructor(){super(new xl(-5,5,5,-5,.5,500))}}ed.prototype.isDirectionalLightShadow=!0;class Ey extends Mn{constructor(t,e){super(t,e),this.type="DirectionalLight",this.position.copy(Zt.DefaultUp),this.updateMatrix(),this.target=new Zt,this.shadow=new ed}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Ey.prototype.isDirectionalLight=!0;class Ty extends Mn{constructor(t,e){super(t,e),this.type="AmbientLight"}}Ty.prototype.isAmbientLight=!0;class Cy extends Mn{constructor(t,e,n=10,i=10){super(t,e),this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}Cy.prototype.isRectAreaLight=!0;class nd{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new T)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,i=t.y,s=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.282095),e.addScaledVector(a[1],.488603*i),e.addScaledVector(a[2],.488603*s),e.addScaledVector(a[3],.488603*n),e.addScaledVector(a[4],1.092548*(n*i)),e.addScaledVector(a[5],1.092548*(i*s)),e.addScaledVector(a[6],.315392*(3*s*s-1)),e.addScaledVector(a[7],1.092548*(n*s)),e.addScaledVector(a[8],.546274*(n*n-i*i)),e}getIrradianceAt(t,e){const n=t.x,i=t.y,s=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.886227),e.addScaledVector(a[1],2*.511664*i),e.addScaledVector(a[2],2*.511664*s),e.addScaledVector(a[3],2*.511664*n),e.addScaledVector(a[4],2*.429043*n*i),e.addScaledVector(a[5],2*.429043*i*s),e.addScaledVector(a[6],.743125*s*s-.247708),e.addScaledVector(a[7],2*.429043*n*s),e.addScaledVector(a[8],.429043*(n*n-i*i)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(t,e+i*3);return this}toArray(t=[],e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(t,e+i*3);return t}static getBasisAt(t,e){const n=t.x,i=t.y,s=t.z;e[0]=.282095,e[1]=.488603*i,e[2]=.488603*s,e[3]=.488603*n,e[4]=1.092548*n*i,e[5]=1.092548*i*s,e[6]=.315392*(3*s*s-1),e[7]=1.092548*n*s,e[8]=.546274*(n*n-i*i)}}nd.prototype.isSphericalHarmonics3=!0;class Dl extends Mn{constructor(t=new nd,e=1){super(void 0,e),this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}Dl.prototype.isLightProbe=!0;class Ay{static decodeText(t){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(t);let e="";for(let n=0,i=t.length;n<i;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.substr(0,e+1)}}class Py extends $t{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}Py.prototype.isInstancedBufferGeometry=!0;class Ly extends ei{constructor(t){super(t),typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,i){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,a=pr.get(t);if(a!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(a),s.manager.itemEnd(t)},0),a;const h={};h.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",h.headers=this.requestHeader,fetch(t,h).then(function(u){return u.blob()}).then(function(u){return createImageBitmap(u,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(u){pr.add(t,u),e&&e(u),s.manager.itemEnd(t)}).catch(function(u){i&&i(u),s.manager.itemError(t),s.manager.itemEnd(t)}),s.manager.itemStart(t)}}Ly.prototype.isImageBitmapLoader=!0;let $s;const Ry={getContext:function(){return $s===void 0&&($s=new(window.AudioContext||window.webkitAudioContext)),$s},setContext:function(o){$s=o}};class Dy extends ei{constructor(t){super(t)}load(t,e,n,i){const s=this,a=new xy(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(h){try{const u=h.slice(0);Ry.getContext().decodeAudioData(u,function(f){e(f)})}catch(u){i?i(u):console.error(u),s.manager.itemError(t)}},n,i)}}class Iy extends Dl{constructor(t,e,n=1){super(void 0,n);const i=new wt().set(t),s=new wt().set(e),a=new T(i.r,i.g,i.b),h=new T(s.r,s.g,s.b),u=Math.sqrt(Math.PI),d=u*Math.sqrt(.75);this.sh.coefficients[0].copy(a).add(h).multiplyScalar(u),this.sh.coefficients[1].copy(a).sub(h).multiplyScalar(d)}}Iy.prototype.isHemisphereLightProbe=!0;class Ny extends Dl{constructor(t,e=1){super(void 0,e);const n=new wt().set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}Ny.prototype.isAmbientLightProbe=!0;class Fy extends Zt{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),this._connected===!0?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=t,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=t,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}class ky{constructor(t,e,n){this.binding=t,this.valueSize=n;let i,s,a;switch(e){case"quaternion":i=this._slerp,s=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":i=this._select,s=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:i=this._lerp,s=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=s,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,i=this.valueSize,s=t*i+i;let a=this.cumulativeWeight;if(a===0){for(let h=0;h!==i;++h)n[s+h]=n[h];a=e}else{a+=e;const h=e/a;this._mixBufferRegion(n,s,0,h,i)}this.cumulativeWeight=a}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,i=t*e+e,s=this.cumulativeWeight,a=this.cumulativeWeightAdditive,h=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const u=e*this._origIndex;this._mixBufferRegion(n,i,u,1-s,e)}a>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*e,1,e);for(let u=e,d=e+e;u!==d;++u)if(n[u]!==n[u+e]){h.setValue(n,i);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,i=n*this._origIndex;t.getValue(e,i);for(let s=n,a=i;s!==a;++s)e[s]=e[i+s%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=this.valueSize*3;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,i,s){if(i>=.5)for(let a=0;a!==s;++a)t[e+a]=t[n+a]}_slerp(t,e,n,i){we.slerpFlat(t,e,t,e,t,n,i)}_slerpAdditive(t,e,n,i,s){const a=this._workIndex*s;we.multiplyQuaternionsFlat(t,a,t,e,t,n),we.slerpFlat(t,e,t,e,t,a,i)}_lerp(t,e,n,i,s){const a=1-i;for(let h=0;h!==s;++h){const u=e+h;t[u]=t[u]*a+t[n+h]*i}}_lerpAdditive(t,e,n,i,s){for(let a=0;a!==s;++a){const h=e+a;t[h]=t[h]+t[n+a]*i}}}const Il="\\[\\]\\.:\\/",By=new RegExp("["+Il+"]","g"),Nl="[^"+Il+"]",Vy="[^"+Il.replace("\\.","")+"]",Oy=/((?:WC+[\/:])*)/.source.replace("WC",Nl),zy=/(WCOD+)?/.source.replace("WCOD",Vy),Uy=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Nl),Hy=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Nl),Gy=new RegExp("^"+Oy+zy+Uy+Hy+"$"),Wy=["material","materials","bones"];class qy{constructor(t,e,n){const i=n||Jt.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,i)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,s=n.length;i!==s;++i)n[i].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}}class Jt{constructor(t,e,n){this.path=e,this.parsedPath=n||Jt.parseTrackName(e),this.node=Jt.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new Jt.Composite(t,e,n):new Jt(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(By,"")}static parseTrackName(t){const e=Gy.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const s=n.nodeName.substring(i+1);Wy.indexOf(s)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=s)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(!e||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(n!==void 0)return n}if(t.children){const n=function(s){for(let a=0;a<s.length;a++){const h=s[a];if(h.name===e||h.uuid===e)return h;const u=n(h.children);if(u)return u}return null},i=n(t.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)t[e++]=n[i]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,i=e.propertyName;let s=e.propertyIndex;if(t||(t=Jt.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let d=e.objectIndex;switch(n){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let f=0;f<t.length;f++)if(t[f].name===d){d=f;break}break;default:if(t[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[n]}if(d!==void 0){if(t[d]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[d]}}const a=t[i];if(a===void 0){const d=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+d+"."+i+" but it wasn't found.",t);return}let h=this.Versioning.None;this.targetObject=t,t.needsUpdate!==void 0?h=this.Versioning.NeedsUpdate:t.matrixWorldNeedsUpdate!==void 0&&(h=this.Versioning.MatrixWorldNeedsUpdate);let u=this.BindingType.Direct;if(s!==void 0){if(i==="morphTargetInfluences"){if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(t.geometry.isBufferGeometry){if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[s]!==void 0&&(s=t.morphTargetDictionary[s])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}u=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=s}else a.fromArray!==void 0&&a.toArray!==void 0?(u=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(u=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=i;this.getValue=this.GetterByBindingType[u],this.setValue=this.SetterByBindingTypeAndVersioning[u][h]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Jt.Composite=qy;Jt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Jt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Jt.prototype.GetterByBindingType=[Jt.prototype._getValue_direct,Jt.prototype._getValue_array,Jt.prototype._getValue_arrayElement,Jt.prototype._getValue_toArray];Jt.prototype.SetterByBindingTypeAndVersioning=[[Jt.prototype._setValue_direct,Jt.prototype._setValue_direct_setNeedsUpdate,Jt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Jt.prototype._setValue_array,Jt.prototype._setValue_array_setNeedsUpdate,Jt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Jt.prototype._setValue_arrayElement,Jt.prototype._setValue_arrayElement_setNeedsUpdate,Jt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Jt.prototype._setValue_fromArray,Jt.prototype._setValue_fromArray_setNeedsUpdate,Jt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class jy{constructor(t,e,n=null,i=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=i;const s=e.tracks,a=s.length,h=new Array(a),u={endingStart:tr,endingEnd:tr};for(let d=0;d!==a;++d){const f=s[d].createInterpolant(null);h[d]=f,f.settings=u}this._interpolantSettings=u,this._interpolants=h,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Ag,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const i=this._clip.duration,s=t._clip.duration,a=s/i,h=i/s;t.warp(1,a,e),this.warp(h,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const i=this._mixer,s=i.time,a=this.timeScale;let h=this._timeScaleInterpolant;h===null&&(h=i._lendControlInterpolant(),this._timeScaleInterpolant=h);const u=h.parameterPositions,d=h.sampleValues;return u[0]=s,u[1]=s+n,d[0]=t/a,d[1]=e/a,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,i){if(!this.enabled){this._updateWeight(t);return}const s=this._startTime;if(s!==null){const u=(t-s)*n;if(u<0||n===0)return;this._startTime=null,e=n*u}e*=this._updateTimeScale(t);const a=this._updateTime(e),h=this._updateWeight(t);if(h>0){const u=this._interpolants,d=this._propertyBindings;switch(this.blendMode){case cu:for(let f=0,g=u.length;f!==g;++f)u[f].evaluate(a),d[f].accumulateAdditive(h);break;case pl:default:for(let f=0,g=u.length;f!==g;++f)u[f].evaluate(a),d[f].accumulate(i,h)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(n!==null){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;n!==null&&(e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let i=this.time+t,s=this._loopCount;const a=n===Pg;if(t===0)return s===-1?i:a&&(s&1)===1?e-i:i;if(n===Cg){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i>=e)i=e;else if(i<0)i=0;else{this.time=i;break t}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(s===-1&&(t>=0?(s=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),i>=e||i<0){const h=Math.floor(i/e);i-=e*h,s+=Math.abs(h);const u=this.repetitions-s;if(u<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=t>0?e:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(u===1){const d=t<0;this._setEndings(d,!d,a)}else this._setEndings(!1,!1,a);this._loopCount=s,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:h})}}else this.time=i;if(a&&(s&1)===1)return e-i}return i}_setEndings(t,e,n){const i=this._interpolantSettings;n?(i.endingStart=er,i.endingEnd=er):(t?i.endingStart=this.zeroSlopeAtStart?er:tr:i.endingStart=co,e?i.endingEnd=this.zeroSlopeAtEnd?er:tr:i.endingEnd=co)}_scheduleFading(t,e,n){const i=this._mixer,s=i.time;let a=this._weightInterpolant;a===null&&(a=i._lendControlInterpolant(),this._weightInterpolant=a);const h=a.parameterPositions,u=a.sampleValues;return h[0]=s,u[0]=e,h[1]=s+t,u[1]=n,this}}class Xy extends ti{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,i=t._clip.tracks,s=i.length,a=t._propertyBindings,h=t._interpolants,u=n.uuid,d=this._bindingsByRootAndName;let f=d[u];f===void 0&&(f={},d[u]=f);for(let g=0;g!==s;++g){const m=i[g],v=m.name;let b=f[v];if(b!==void 0)a[g]=b;else{if(b=a[g],b!==void 0){b._cacheIndex===null&&(++b.referenceCount,this._addInactiveBinding(b,u,v));continue}const y=e&&e._propertyBindings[g].binding.parsedPath;b=new ky(Jt.create(n,v,y),m.ValueTypeName,m.getValueSize()),++b.referenceCount,this._addInactiveBinding(b,u,v),a[g]=b}h[g].resultBuffer=b.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(t._cacheIndex===null){const n=(t._localRoot||this._root).uuid,i=t._clip.uuid,s=this._actionsByClip[i];this._bindAction(t,s&&s.knownActions[0]),this._addInactiveAction(t,i,n)}const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const s=e[n];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const s=e[n];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(t,e,n){const i=this._actions,s=this._actionsByClip;let a=s[e];if(a===void 0)a={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,s[e]=a;else{const h=a.knownActions;t._byClipCacheIndex=h.length,h.push(t)}t._cacheIndex=i.length,i.push(t),a.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],i=t._cacheIndex;n._cacheIndex=i,e[i]=n,e.pop(),t._cacheIndex=null;const s=t._clip.uuid,a=this._actionsByClip,h=a[s],u=h.knownActions,d=u[u.length-1],f=t._byClipCacheIndex;d._byClipCacheIndex=f,u[f]=d,u.pop(),t._byClipCacheIndex=null;const g=h.actionByRoot,m=(t._localRoot||this._root).uuid;delete g[m],u.length===0&&delete a[s],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const s=e[n];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,i=this._nActiveActions++,s=e[i];t._cacheIndex=i,e[i]=t,s._cacheIndex=n,e[n]=s}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,i=--this._nActiveActions,s=e[i];t._cacheIndex=i,e[i]=t,s._cacheIndex=n,e[n]=s}_addInactiveBinding(t,e,n){const i=this._bindingsByRootAndName,s=this._bindings;let a=i[e];a===void 0&&(a={},i[e]=a),a[n]=t,t._cacheIndex=s.length,s.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,i=n.rootNode.uuid,s=n.path,a=this._bindingsByRootAndName,h=a[i],u=e[e.length-1],d=t._cacheIndex;u._cacheIndex=d,e[d]=u,e.pop(),delete h[s],Object.keys(h).length===0&&delete a[i]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,i=this._nActiveBindings++,s=e[i];t._cacheIndex=i,e[i]=t,s._cacheIndex=n,e[n]=s}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,i=--this._nActiveBindings,s=e[i];t._cacheIndex=i,e[i]=t,s._cacheIndex=n,e[n]=s}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return n===void 0&&(n=new Zu(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,i=--this._nActiveControlInterpolants,s=e[i];t.__cacheIndex=i,e[i]=t,s.__cacheIndex=n,e[n]=s}clipAction(t,e,n){const i=e||this._root,s=i.uuid;let a=typeof t=="string"?Oh.findByName(i,t):t;const h=a!==null?a.uuid:t,u=this._actionsByClip[h];let d=null;if(n===void 0&&(a!==null?n=a.blendMode:n=pl),u!==void 0){const g=u.actionByRoot[s];if(g!==void 0&&g.blendMode===n)return g;d=u.knownActions[0],a===null&&(a=d._clip)}if(a===null)return null;const f=new jy(this,a,e,n);return this._bindAction(f,d),this._addInactiveAction(f,h,s),f}existingAction(t,e){const n=e||this._root,i=n.uuid,s=typeof t=="string"?Oh.findByName(n,t):t,a=s?s.uuid:t,h=this._actionsByClip[a];return h!==void 0&&h.actionByRoot[i]||null}stopAllAction(){const t=this._actions,e=this._nActiveActions;for(let n=e-1;n>=0;--n)t[n].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,i=this.time+=t,s=Math.sign(t),a=this._accuIndex^=1;for(let d=0;d!==n;++d)e[d]._update(i,t,s,a);const h=this._bindings,u=this._nActiveBindings;for(let d=0;d!==u;++d)h[d].apply(a);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,i=this._actionsByClip,s=i[n];if(s!==void 0){const a=s.knownActions;for(let h=0,u=a.length;h!==u;++h){const d=a[h];this._deactivateAction(d);const f=d._cacheIndex,g=e[e.length-1];d._cacheIndex=null,d._byClipCacheIndex=null,g._cacheIndex=f,e[f]=g,e.pop(),this._removeInactiveBindingsForAction(d)}delete i[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const a in n){const h=n[a].actionByRoot,u=h[e];u!==void 0&&(this._deactivateAction(u),this._removeInactiveAction(u))}const i=this._bindingsByRootAndName,s=i[e];if(s!==void 0)for(const a in s){const h=s[a];h.restoreOriginalState(),this._removeInactiveBinding(h)}}uncacheAction(t,e){const n=this.existingAction(t,e);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}Xy.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class Yy extends as{constructor(t,e,n=1){super(t,e),this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}Yy.prototype.isInstancedInterleavedBuffer=!0;class Zy{constructor(t,e,n=0,i=1/0){this.ray=new _i(t,e),this.near=n,this.far=i,this.camera=null,this.layers=new fu,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(t,e=!1,n=[]){return cl(t,this,n,e),n.sort(Wh),n}intersectObjects(t,e=!1,n=[]){for(let i=0,s=t.length;i<s;i++)cl(t[i],this,n,e);return n.sort(Wh),n}}function Wh(o,t){return o.distance-t.distance}function cl(o,t,e,n){if(o.layers.test(t.layers)&&o.raycast(t,e),n===!0){const i=o.children;for(let s=0,a=i.length;s<a;s++)cl(i[s],t,e,!0)}}class qh{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(De(e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}const jh=new T,Qs=new T;class id{constructor(t=new T,e=new T){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){jh.subVectors(t,this.start),Qs.subVectors(this.end,this.start);const n=Qs.dot(Qs);let s=Qs.dot(jh)/n;return e&&(s=De(s,0,1)),s}closestPointToPoint(t,e,n){const i=this.closestPointToPointParameter(t,e);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}class Ky extends Zt{constructor(t){super(),this.material=t,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}}Ky.prototype.isImmediateRenderObject=!0;const qn=new T,to=new It,Ua=new It;class Jy extends Ml{constructor(t){const e=rd(t),n=new $t,i=[],s=[],a=new wt(0,0,1),h=new wt(0,1,0);for(let d=0;d<e.length;d++){const f=e[d];f.parent&&f.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),s.push(a.r,a.g,a.b),s.push(h.r,h.g,h.b))}n.setAttribute("position",new ee(i,3)),n.setAttribute("color",new ee(s,3));const u=new xr({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,u),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,i=n.getAttribute("position");Ua.copy(this.root.matrixWorld).invert();for(let s=0,a=0;s<e.length;s++){const h=e[s];h.parent&&h.parent.isBone&&(to.multiplyMatrices(Ua,h.matrixWorld),qn.setFromMatrixPosition(to),i.setXYZ(a,qn.x,qn.y,qn.z),to.multiplyMatrices(Ua,h.parent.matrixWorld),qn.setFromMatrixPosition(to),i.setXYZ(a+1,qn.x,qn.y,qn.z),a+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function rd(o){const t=[];o&&o.isBone&&t.push(o);for(let e=0;e<o.children.length;e++)t.push.apply(t,rd(o.children[e]));return t}class sd extends Ml{constructor(t=10,e=10,n=4473924,i=8947848){n=new wt(n),i=new wt(i);const s=e/2,a=t/e,h=t/2,u=[],d=[];for(let m=0,v=0,b=-h;m<=e;m++,b+=a){u.push(-h,0,b,h,0,b),u.push(b,0,-h,b,0,h);const y=m===s?n:i;y.toArray(d,v),v+=3,y.toArray(d,v),v+=3,y.toArray(d,v),v+=3,y.toArray(d,v),v+=3}const f=new $t;f.setAttribute("position",new ee(u,3)),f.setAttribute("color",new ee(d,3));const g=new xr({vertexColors:!0,toneMapped:!1});super(f,g),this.type="GridHelper"}}const Xh=new T;let eo,Ha;class Ga extends Zt{constructor(t=new T(0,0,1),e=new T(0,0,0),n=1,i=16776960,s=n*.2,a=s*.2){super(),this.type="ArrowHelper",eo===void 0&&(eo=new $t,eo.setAttribute("position",new ee([0,0,0,0,1,0],3)),Ha=new To(0,.5,1,5,1),Ha.translate(0,-.5,0)),this.position.copy(e),this.line=new Eo(eo,new xr({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new xe(Ha,new xi({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(n,s,a)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{Xh.set(t.z,0,-t.x).normalize();const e=Math.acos(t.y);this.quaternion.setFromAxisAngle(Xh,e)}}setLength(t,e=t*.2,n=e*.2){this.line.scale.set(1,Math.max(1e-4,t-e),1),this.line.updateMatrix(),this.cone.scale.set(n,e,n),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}}const $y=new Float32Array(1);new Int32Array($y.buffer);nn.create=function(o,t){return console.log("THREE.Curve.create() has been deprecated"),o.prototype=Object.create(nn.prototype),o.prototype.constructor=o,o.prototype.getPoint=t,o};ll.prototype.fromPoints=function(o){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(o)};sd.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};Jy.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};ei.prototype.extractUrlBase=function(o){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Ay.extractUrlBase(o)};ei.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};un.prototype.center=function(o){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(o)};un.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};un.prototype.isIntersectionBox=function(o){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(o)};un.prototype.isIntersectionSphere=function(o){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(o)};un.prototype.size=function(o){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(o)};gr.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};wo.prototype.setFromMatrix=function(o){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(o)};id.prototype.center=function(o){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(o)};ye.prototype.flattenToArrayOffset=function(o,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(o,t)};ye.prototype.multiplyVector3=function(o){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),o.applyMatrix3(this)};ye.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};ye.prototype.applyToBufferAttribute=function(o){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),o.applyMatrix3(this)};ye.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};ye.prototype.getInverse=function(o){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(o).invert()};It.prototype.extractPosition=function(o){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(o)};It.prototype.flattenToArrayOffset=function(o,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(o,t)};It.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new T().setFromMatrixColumn(this,3)};It.prototype.setRotationFromQuaternion=function(o){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(o)};It.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};It.prototype.multiplyVector3=function(o){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)};It.prototype.multiplyVector4=function(o){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)};It.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};It.prototype.rotateAxis=function(o){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),o.transformDirection(this)};It.prototype.crossVector=function(o){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)};It.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};It.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};It.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};It.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};It.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};It.prototype.applyToBufferAttribute=function(o){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)};It.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};It.prototype.makeFrustum=function(o,t,e,n,i,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(o,t,n,e,i,s)};It.prototype.getInverse=function(o){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(o).invert()};vn.prototype.isIntersectionLine=function(o){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(o)};we.prototype.multiplyVector3=function(o){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),o.applyQuaternion(this)};we.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};_i.prototype.isIntersectionBox=function(o){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(o)};_i.prototype.isIntersectionPlane=function(o){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(o)};_i.prototype.isIntersectionSphere=function(o){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(o)};de.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};de.prototype.barycoordFromPoint=function(o,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(o,t)};de.prototype.midpoint=function(o){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(o)};de.prototypenormal=function(o){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(o)};de.prototype.plane=function(o){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(o)};de.barycoordFromPoint=function(o,t,e,n,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),de.getBarycoord(o,t,e,n,i)};de.normal=function(o,t,e,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),de.getNormal(o,t,e,n)};Ll.prototype.extractAllPoints=function(o){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(o)};Ll.prototype.extrude=function(o){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new br(this,o)};Ll.prototype.makeGeometry=function(o){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Al(this,o)};it.prototype.fromAttribute=function(o,t,e){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(o,t,e)};it.prototype.distanceToManhattan=function(o){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(o)};it.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};T.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};T.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};T.prototype.getPositionFromMatrix=function(o){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(o)};T.prototype.getScaleFromMatrix=function(o){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(o)};T.prototype.getColumnFromMatrix=function(o,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,o)};T.prototype.applyProjection=function(o){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(o)};T.prototype.fromAttribute=function(o,t,e){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(o,t,e)};T.prototype.distanceToManhattan=function(o){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(o)};T.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};te.prototype.fromAttribute=function(o,t,e){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(o,t,e)};te.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};Zt.prototype.getChildByName=function(o){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(o)};Zt.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};Zt.prototype.translate=function(o,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,o)};Zt.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};Zt.prototype.applyMatrix=function(o){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(o)};Object.defineProperties(Zt.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(o){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=o}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});xe.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(xe.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),Lg},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});Vu.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Ie.prototype.setLens=function(o,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),t!==void 0&&(this.filmGauge=t),this.setFocalLength(o)};Object.defineProperties(Mn.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(o){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=o}},shadowCameraLeft:{set:function(o){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=o}},shadowCameraRight:{set:function(o){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=o}},shadowCameraTop:{set:function(o){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=o}},shadowCameraBottom:{set:function(o){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=o}},shadowCameraNear:{set:function(o){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=o}},shadowCameraFar:{set:function(o){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=o}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(o){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=o}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(o){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=o}},shadowMapHeight:{set:function(o){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=o}}});Object.defineProperties(ge.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===ho},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(ho)}}});ge.prototype.setDynamic=function(o){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(o===!0?ho:es),this};ge.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},ge.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};$t.prototype.addIndex=function(o){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(o)};$t.prototype.addAttribute=function(o,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(t&&t.isBufferAttribute)&&!(t&&t.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(o,new ge(arguments[1],arguments[2]))):o==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(o,t)};$t.prototype.addDrawCall=function(o,t,e){e!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(o,t)};$t.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};$t.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};$t.prototype.removeAttribute=function(o){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(o)};$t.prototype.applyMatrix=function(o){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(o)};Object.defineProperties($t.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});as.prototype.setDynamic=function(o){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(o===!0?ho:es),this};as.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};br.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};br.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};br.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};wl.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(Pe.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new wt}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(o){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=o===su}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(o){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=o}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties(vi.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(o){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=o}}});Qt.prototype.clearTarget=function(o,t,e,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(o),this.clear(t,e,n)};Qt.prototype.animate=function(o){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(o)};Qt.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};Qt.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};Qt.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};Qt.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};Qt.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};Qt.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};Qt.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};Qt.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};Qt.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};Qt.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};Qt.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};Qt.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};Qt.prototype.enableScissorTest=function(o){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(o)};Qt.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};Qt.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};Qt.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};Qt.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};Qt.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};Qt.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};Qt.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};Qt.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};Qt.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};Qt.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(Qt.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(o){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=o}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(o){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=o}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(o){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=o===!0?bo:He}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(Nu.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(yn.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(o){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=o}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(o){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=o}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(o){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=o}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(o){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=o}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(o){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=o}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(o){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=o}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(o){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=o}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(o){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=o}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(o){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=o}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(o){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=o}}});Fy.prototype.load=function(o){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;return new Dy().load(o,function(n){t.setBuffer(n)}),this};vl.prototype.updateCubeMap=function(o,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(o,t)};vl.prototype.clear=function(o,t,e,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(o,t,e,n)};mr.crossOrigin=void 0;mr.loadTexture=function(o,t,e,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new yy;i.setCrossOrigin(this.crossOrigin);const s=i.load(o,e,void 0,n);return t&&(s.mapping=t),s};mr.loadTextureCube=function(o,t,e,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new by;i.setCrossOrigin(this.crossOrigin);const s=i.load(o,e,void 0,n);return t&&(s.mapping=t),s};mr.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};mr.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:iu}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=iu);const Yh={type:"change"},Wa={type:"start"},qa={type:"end"};class Qy extends ti{constructor(t,e){super(),e===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),e===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=t,this.domElement=e,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new T,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:Ri.ROTATE,MIDDLE:Ri.DOLLY,RIGHT:Ri.PAN},this.touches={ONE:Di.ROTATE,TWO:Di.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return h.phi},this.getAzimuthalAngle=function(){return h.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(D){D.addEventListener("keydown",_t),this._domElementKeyEvents=D},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(Yh),n.update(),s=i.NONE},this.update=function(){const D=new T,ot=new we().setFromUnitVectors(t.up,new T(0,1,0)),zt=ot.clone().invert(),Ut=new T,ie=new we,Kt=2*Math.PI;return function(){const ke=n.object.position;D.copy(ke).sub(n.target),D.applyQuaternion(ot),h.setFromVector3(D),n.autoRotate&&s===i.NONE&&tt(C()),n.enableDamping?(h.theta+=u.theta*n.dampingFactor,h.phi+=u.phi*n.dampingFactor):(h.theta+=u.theta,h.phi+=u.phi);let Le=n.minAzimuthAngle,Re=n.maxAzimuthAngle;return isFinite(Le)&&isFinite(Re)&&(Le<-Math.PI?Le+=Kt:Le>Math.PI&&(Le-=Kt),Re<-Math.PI?Re+=Kt:Re>Math.PI&&(Re-=Kt),Le<=Re?h.theta=Math.max(Le,Math.min(Re,h.theta)):h.theta=h.theta>(Le+Re)/2?Math.max(Le,h.theta):Math.min(Re,h.theta)),h.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,h.phi)),h.makeSafe(),h.radius*=d,h.radius=Math.max(n.minDistance,Math.min(n.maxDistance,h.radius)),n.enableDamping===!0?n.target.addScaledVector(f,n.dampingFactor):n.target.add(f),D.setFromSpherical(h),D.applyQuaternion(zt),ke.copy(n.target).add(D),n.object.lookAt(n.target),n.enableDamping===!0?(u.theta*=1-n.dampingFactor,u.phi*=1-n.dampingFactor,f.multiplyScalar(1-n.dampingFactor)):(u.set(0,0,0),f.set(0,0,0)),d=1,g||Ut.distanceToSquared(n.object.position)>a||8*(1-ie.dot(n.object.quaternion))>a?(n.dispatchEvent(Yh),Ut.copy(n.object.position),ie.copy(n.object.quaternion),g=!1,!0):!1}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",Tt),n.domElement.removeEventListener("pointerdown",lt),n.domElement.removeEventListener("pointercancel",P),n.domElement.removeEventListener("wheel",ht),n.domElement.removeEventListener("pointermove",St),n.domElement.removeEventListener("pointerup",ut),n._domElementKeyEvents!==null&&n._domElementKeyEvents.removeEventListener("keydown",_t)};const n=this,i={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let s=i.NONE;const a=1e-6,h=new qh,u=new qh;let d=1;const f=new T;let g=!1;const m=new it,v=new it,b=new it,y=new it,M=new it,x=new it,_=new it,R=new it,L=new it,A=[],N={};function C(){return 2*Math.PI/60/60*n.autoRotateSpeed}function z(){return Math.pow(.95,n.zoomSpeed)}function tt(D){u.theta-=D}function W(D){u.phi-=D}const F=function(){const D=new T;return function(zt,Ut){D.setFromMatrixColumn(Ut,0),D.multiplyScalar(-zt),f.add(D)}}(),rt=function(){const D=new T;return function(zt,Ut){n.screenSpacePanning===!0?D.setFromMatrixColumn(Ut,1):(D.setFromMatrixColumn(Ut,0),D.crossVectors(n.object.up,D)),D.multiplyScalar(zt),f.add(D)}}(),H=function(){const D=new T;return function(zt,Ut){const ie=n.domElement;if(n.object.isPerspectiveCamera){const Kt=n.object.position;D.copy(Kt).sub(n.target);let Se=D.length();Se*=Math.tan(n.object.fov/2*Math.PI/180),F(2*zt*Se/ie.clientHeight,n.object.matrix),rt(2*Ut*Se/ie.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(F(zt*(n.object.right-n.object.left)/n.object.zoom/ie.clientWidth,n.object.matrix),rt(Ut*(n.object.top-n.object.bottom)/n.object.zoom/ie.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function G(D){n.object.isPerspectiveCamera?d/=D:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*D)),n.object.updateProjectionMatrix(),g=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function j(D){n.object.isPerspectiveCamera?d*=D:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/D)),n.object.updateProjectionMatrix(),g=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function B(D){m.set(D.clientX,D.clientY)}function K(D){_.set(D.clientX,D.clientY)}function at(D){y.set(D.clientX,D.clientY)}function yt(D){v.set(D.clientX,D.clientY),b.subVectors(v,m).multiplyScalar(n.rotateSpeed);const ot=n.domElement;tt(2*Math.PI*b.x/ot.clientHeight),W(2*Math.PI*b.y/ot.clientHeight),m.copy(v),n.update()}function bt(D){R.set(D.clientX,D.clientY),L.subVectors(R,_),L.y>0?G(z()):L.y<0&&j(z()),_.copy(R),n.update()}function mt(D){M.set(D.clientX,D.clientY),x.subVectors(M,y).multiplyScalar(n.panSpeed),H(x.x,x.y),y.copy(M),n.update()}function vt(D){D.deltaY<0?j(z()):D.deltaY>0&&G(z()),n.update()}function J(D){let ot=!1;switch(D.code){case n.keys.UP:H(0,n.keyPanSpeed),ot=!0;break;case n.keys.BOTTOM:H(0,-n.keyPanSpeed),ot=!0;break;case n.keys.LEFT:H(n.keyPanSpeed,0),ot=!0;break;case n.keys.RIGHT:H(-n.keyPanSpeed,0),ot=!0;break}ot&&(D.preventDefault(),n.update())}function st(){if(A.length===1)m.set(A[0].pageX,A[0].pageY);else{const D=.5*(A[0].pageX+A[1].pageX),ot=.5*(A[0].pageY+A[1].pageY);m.set(D,ot)}}function Mt(){if(A.length===1)y.set(A[0].pageX,A[0].pageY);else{const D=.5*(A[0].pageX+A[1].pageX),ot=.5*(A[0].pageY+A[1].pageY);y.set(D,ot)}}function q(){const D=A[0].pageX-A[1].pageX,ot=A[0].pageY-A[1].pageY,zt=Math.sqrt(D*D+ot*ot);_.set(0,zt)}function Ct(){n.enableZoom&&q(),n.enablePan&&Mt()}function At(){n.enableZoom&&q(),n.enableRotate&&st()}function dt(D){if(A.length==1)v.set(D.pageX,D.pageY);else{const zt=gt(D),Ut=.5*(D.pageX+zt.x),ie=.5*(D.pageY+zt.y);v.set(Ut,ie)}b.subVectors(v,m).multiplyScalar(n.rotateSpeed);const ot=n.domElement;tt(2*Math.PI*b.x/ot.clientHeight),W(2*Math.PI*b.y/ot.clientHeight),m.copy(v)}function xt(D){if(A.length===1)M.set(D.pageX,D.pageY);else{const ot=gt(D),zt=.5*(D.pageX+ot.x),Ut=.5*(D.pageY+ot.y);M.set(zt,Ut)}x.subVectors(M,y).multiplyScalar(n.panSpeed),H(x.x,x.y),y.copy(M)}function kt(D){const ot=gt(D),zt=D.pageX-ot.x,Ut=D.pageY-ot.y,ie=Math.sqrt(zt*zt+Ut*Ut);R.set(0,ie),L.set(0,Math.pow(R.y/_.y,n.zoomSpeed)),G(L.y),_.copy(R)}function Z(D){n.enableZoom&&kt(D),n.enablePan&&xt(D)}function nt(D){n.enableZoom&&kt(D),n.enableRotate&&dt(D)}function lt(D){n.enabled!==!1&&(A.length===0&&(n.domElement.setPointerCapture(D.pointerId),n.domElement.addEventListener("pointermove",St),n.domElement.addEventListener("pointerup",ut)),k(D),D.pointerType==="touch"?Lt(D):E(D))}function St(D){n.enabled!==!1&&(D.pointerType==="touch"?Et(D):Y(D))}function ut(D){n.enabled!==!1&&(D.pointerType==="touch"?Nt():Q(),pt(D),A.length===0&&(n.domElement.releasePointerCapture(D.pointerId),n.domElement.removeEventListener("pointermove",St),n.domElement.removeEventListener("pointerup",ut)))}function P(D){pt(D)}function E(D){let ot;switch(D.button){case 0:ot=n.mouseButtons.LEFT;break;case 1:ot=n.mouseButtons.MIDDLE;break;case 2:ot=n.mouseButtons.RIGHT;break;default:ot=-1}switch(ot){case Ri.DOLLY:if(n.enableZoom===!1)return;K(D),s=i.DOLLY;break;case Ri.ROTATE:if(D.ctrlKey||D.metaKey||D.shiftKey){if(n.enablePan===!1)return;at(D),s=i.PAN}else{if(n.enableRotate===!1)return;B(D),s=i.ROTATE}break;case Ri.PAN:if(D.ctrlKey||D.metaKey||D.shiftKey){if(n.enableRotate===!1)return;B(D),s=i.ROTATE}else{if(n.enablePan===!1)return;at(D),s=i.PAN}break;default:s=i.NONE}s!==i.NONE&&n.dispatchEvent(Wa)}function Y(D){if(n.enabled!==!1)switch(s){case i.ROTATE:if(n.enableRotate===!1)return;yt(D);break;case i.DOLLY:if(n.enableZoom===!1)return;bt(D);break;case i.PAN:if(n.enablePan===!1)return;mt(D);break}}function Q(D){n.dispatchEvent(qa),s=i.NONE}function ht(D){n.enabled===!1||n.enableZoom===!1||s!==i.NONE&&s!==i.ROTATE||(D.preventDefault(),n.dispatchEvent(Wa),vt(D),n.dispatchEvent(qa))}function _t(D){n.enabled===!1||n.enablePan===!1||J(D)}function Lt(D){switch($(D),A.length){case 1:switch(n.touches.ONE){case Di.ROTATE:if(n.enableRotate===!1)return;st(),s=i.TOUCH_ROTATE;break;case Di.PAN:if(n.enablePan===!1)return;Mt(),s=i.TOUCH_PAN;break;default:s=i.NONE}break;case 2:switch(n.touches.TWO){case Di.DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;Ct(),s=i.TOUCH_DOLLY_PAN;break;case Di.DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;At(),s=i.TOUCH_DOLLY_ROTATE;break;default:s=i.NONE}break;default:s=i.NONE}s!==i.NONE&&n.dispatchEvent(Wa)}function Et(D){switch($(D),s){case i.TOUCH_ROTATE:if(n.enableRotate===!1)return;dt(D),n.update();break;case i.TOUCH_PAN:if(n.enablePan===!1)return;xt(D),n.update();break;case i.TOUCH_DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;Z(D),n.update();break;case i.TOUCH_DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;nt(D),n.update();break;default:s=i.NONE}}function Nt(D){n.dispatchEvent(qa),s=i.NONE}function Tt(D){n.enabled!==!1&&D.preventDefault()}function k(D){A.push(D)}function pt(D){delete N[D.pointerId];for(let ot=0;ot<A.length;ot++)if(A[ot].pointerId==D.pointerId){A.splice(ot,1);return}}function $(D){let ot=N[D.pointerId];ot===void 0&&(ot=new it,N[D.pointerId]=ot),ot.set(D.pageX,D.pageY)}function gt(D){const ot=D.pointerId===A[0].pointerId?A[1]:A[0];return N[ot.pointerId]}n.domElement.addEventListener("contextmenu",Tt),n.domElement.addEventListener("pointerdown",lt),n.domElement.addEventListener("pointercancel",P),n.domElement.addEventListener("wheel",ht,{passive:!1}),this.update()}}const so=0,tw=1,ew=new T,Zh=new id,ja=new vn,Kh=new T,no=new de;class Jh{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new $h,this.unassigned=new $h,this.vertices=[]}setFromPoints(t){Array.isArray(t)!==!0&&console.error("THREE.ConvexHull: Points parameter is not an array."),t.length<4&&console.error("THREE.ConvexHull: The algorithm needs at least four points."),this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.vertices.push(new nw(t[e]));return this.compute(),this}setFromObject(t){const e=[];return t.updateMatrixWorld(!0),t.traverse(function(n){const i=n.geometry;if(i!==void 0){if(i.isGeometry){console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");return}else if(i.isBufferGeometry){const s=i.attributes.position;if(s!==void 0)for(let a=0,h=s.count;a<h;a++){const u=new T;u.fromBufferAttribute(s,a).applyMatrix4(n.matrixWorld),e.push(u)}}}}),this.setFromPoints(e)}containsPoint(t){const e=this.faces;for(let n=0,i=e.length;n<i;n++)if(e[n].distanceToPoint(t)>this.tolerance)return!1;return!0}intersectRay(t,e){const n=this.faces;let i=-1/0,s=1/0;for(let a=0,h=n.length;a<h;a++){const u=n[a],d=u.distanceToPoint(t.origin),f=u.normal.dot(t.direction);if(d>0&&f>=0)return null;const g=f!==0?-d/f:0;if(!(g<=0)&&(f>0?s=Math.min(g,s):i=Math.max(g,i),i>s))return null}return i!==-1/0?t.at(i,e):t.at(s,e),e}intersectsRay(t){return this.intersectRay(t,ew)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,e.outside===null?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(t.next!==null&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(t.outside!==null){const e=t.outside;let n=t.outside;for(;n.next!==null&&n.next.face===t;)n=n.next;return this.assigned.removeSubList(e,n),e.prev=n.next=null,t.outside=null,e}}deleteFaceVertices(t,e){const n=this.removeAllVerticesFromFace(t);if(n!==void 0)if(e===void 0)this.unassigned.appendChain(n);else{let i=n;do{const s=i.next;e.distanceToPoint(i.point)>this.tolerance?this.addVertexToFace(i,e):this.unassigned.append(i),i=s}while(i!==null)}return this}resolveUnassignedPoints(t){if(this.unassigned.isEmpty()===!1){let e=this.unassigned.first();do{const n=e.next;let i=this.tolerance,s=null;for(let a=0;a<t.length;a++){const h=t[a];if(h.mark===so){const u=h.distanceToPoint(e.point);if(u>i&&(i=u,s=h),i>1e3*this.tolerance)break}}s!==null&&this.addVertexToFace(e,s),e=n}while(e!==null)}return this}computeExtremes(){const t=new T,e=new T,n=[],i=[];for(let s=0;s<3;s++)n[s]=i[s]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let s=0,a=this.vertices.length;s<a;s++){const h=this.vertices[s],u=h.point;for(let d=0;d<3;d++)u.getComponent(d)<t.getComponent(d)&&(t.setComponent(d,u.getComponent(d)),n[d]=h);for(let d=0;d<3;d++)u.getComponent(d)>e.getComponent(d)&&(e.setComponent(d,u.getComponent(d)),i[d]=h)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:n,max:i}}computeInitialHull(){const t=this.vertices,e=this.computeExtremes(),n=e.min,i=e.max;let s=0,a=0;for(let m=0;m<3;m++){const v=i[m].point.getComponent(m)-n[m].point.getComponent(m);v>s&&(s=v,a=m)}const h=n[a],u=i[a];let d,f;s=0,Zh.set(h.point,u.point);for(let m=0,v=this.vertices.length;m<v;m++){const b=t[m];if(b!==h&&b!==u){Zh.closestPointToPoint(b.point,!0,Kh);const y=Kh.distanceToSquared(b.point);y>s&&(s=y,d=b)}}s=-1,ja.setFromCoplanarPoints(h.point,u.point,d.point);for(let m=0,v=this.vertices.length;m<v;m++){const b=t[m];if(b!==h&&b!==u&&b!==d){const y=Math.abs(ja.distanceToPoint(b.point));y>s&&(s=y,f=b)}}const g=[];if(ja.distanceToPoint(f.point)<0){g.push(hn.create(h,u,d),hn.create(f,u,h),hn.create(f,d,u),hn.create(f,h,d));for(let m=0;m<3;m++){const v=(m+1)%3;g[m+1].getEdge(2).setTwin(g[0].getEdge(v)),g[m+1].getEdge(1).setTwin(g[v+1].getEdge(0))}}else{g.push(hn.create(h,d,u),hn.create(f,h,u),hn.create(f,u,d),hn.create(f,d,h));for(let m=0;m<3;m++){const v=(m+1)%3;g[m+1].getEdge(2).setTwin(g[0].getEdge((3-m)%3)),g[m+1].getEdge(0).setTwin(g[v+1].getEdge(1))}}for(let m=0;m<4;m++)this.faces.push(g[m]);for(let m=0,v=t.length;m<v;m++){const b=t[m];if(b!==h&&b!==u&&b!==d&&b!==f){s=this.tolerance;let y=null;for(let M=0;M<4;M++){const x=this.faces[M].distanceToPoint(b.point);x>s&&(s=x,y=this.faces[M])}y!==null&&this.addVertexToFace(b,y)}}return this}reindexFaces(){const t=[];for(let e=0;e<this.faces.length;e++){const n=this.faces[e];n.mark===so&&t.push(n)}return this.faces=t,this}nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let t,e=0;const n=this.assigned.first().face;let i=n.outside;do{const s=n.distanceToPoint(i.point);s>e&&(e=s,t=i),i=i.next}while(i!==null&&i.face===n);return t}}computeHorizon(t,e,n,i){this.deleteFaceVertices(n),n.mark=tw;let s;e===null?s=e=n.getEdge(0):s=e.next;do{const a=s.twin,h=a.face;h.mark===so&&(h.distanceToPoint(t)>this.tolerance?this.computeHorizon(t,a,h,i):i.push(s)),s=s.next}while(s!==e);return this}addAdjoiningFace(t,e){const n=hn.create(t,e.tail(),e.head());return this.faces.push(n),n.getEdge(-1).setTwin(e.twin),n.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let n=null,i=null;for(let s=0;s<e.length;s++){const a=e[s],h=this.addAdjoiningFace(t,a);n===null?n=h:h.next.setTwin(i),this.newFaces.push(h.face),i=h}return n.next.setTwin(i),this}addVertexToHull(t){const e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();(t=this.nextVertexToAdd())!==void 0;)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}}class hn{constructor(){this.normal=new T,this.midpoint=new T,this.area=0,this.constant=0,this.outside=null,this.mark=so,this.edge=null}static create(t,e,n){const i=new hn,s=new Xa(t,i),a=new Xa(e,i),h=new Xa(n,i);return s.next=h.prev=a,a.next=s.prev=h,h.next=a.prev=s,i.edge=s,i.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),n=this.edge.next.head();return no.set(t.point,e.point,n.point),no.getNormal(this.normal),no.getMidpoint(this.midpoint),this.area=no.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class Xa{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return e!==null?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return e!==null?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class nw{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class $h{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,e.prev===null?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,e.next===null?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return this.head===null?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(this.head===null?this.head=t:this.tail.next=t,t.prev=this.tail;t.next!==null;)t=t.next;return this.tail=t,this}remove(t){return t.prev===null?this.head=t.next:t.prev.next=t.next,t.next===null?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return t.prev===null?this.head=e.next:t.prev.next=e.next,e.next===null?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return this.head===null}}class iw extends $t{constructor(t){super();const e=[],n=[];Jh===void 0&&console.error("THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull");const s=new Jh().setFromPoints(t).faces;for(let a=0;a<s.length;a++){const h=s[a];let u=h.edge;do{const d=u.head().point;e.push(d.x,d.y,d.z),n.push(h.normal.x,h.normal.y,h.normal.z),u=u.next}while(u!==h.edge)}this.setAttribute("position",new ee(e,3)),this.setAttribute("normal",new ee(n,3))}}class od{constructor(t,e=32){this.lut=[],this.map=[],this.n=0,this.minV=0,this.maxV=1,this.setColorMap(t,e)}set(t){return t.isLut===!0&&this.copy(t),this}setMin(t){return this.minV=t,this}setMax(t){return this.maxV=t,this}setColorMap(t,e=32){this.map=Ya[t]||Ya.rainbow,this.n=e;const n=1/this.n;this.lut.length=0;for(let i=0;i<=1;i+=n)for(let s=0;s<this.map.length-1;s++)if(i>=this.map[s][0]&&i<this.map[s+1][0]){const a=this.map[s][0],h=this.map[s+1][0],u=new wt(this.map[s][1]),d=new wt(this.map[s+1][1]),f=u.lerp(d,(i-a)/(h-a));this.lut.push(f)}return this}copy(t){return this.lut=t.lut,this.map=t.map,this.n=t.n,this.minV=t.minV,this.maxV=t.maxV,this}getColor(t){t<=this.minV?t=this.minV:t>=this.maxV&&(t=this.maxV),t=(t-this.minV)/(this.maxV-this.minV);let e=Math.round(t*this.n);return e==this.n&&(e-=1),this.lut[e]}addColorMap(t,e){return Ya[t]=e,this}createCanvas(){const t=document.createElement("canvas");return t.width=1,t.height=this.n,this.updateCanvas(t),t}updateCanvas(t){const e=t.getContext("2d",{alpha:!1}),n=e.getImageData(0,0,1,this.n),i=n.data;let s=0;const a=1/this.n;for(let h=1;h>=0;h-=a)for(let u=this.map.length-1;u>=0;u--)if(h<this.map[u][0]&&h>=this.map[u-1][0]){const d=this.map[u-1][0],f=this.map[u][0],g=new wt(this.map[u-1][1]),m=new wt(this.map[u][1]),v=g.lerp(m,(h-d)/(f-d));i[s*4]=Math.round(v.r*255),i[s*4+1]=Math.round(v.g*255),i[s*4+2]=Math.round(v.b*255),i[s*4+3]=255,s+=1}return e.putImageData(n,0,0),t}}od.prototype.isLut=!0;const Ya={rainbow:[[0,255],[.2,65535],[.5,65280],[.8,16776960],[1,16711680]],cooltowarm:[[0,3952322],[.2,10206463],[.5,14474460],[.8,16163717],[1,11797542]],blackbody:[[0,0],[.2,7864320],[.5,15086080],[.8,16776960],[1,16777215]],grayscale:[[0,0],[.2,4210752],[.5,8355712],[.8,12566463],[1,16777215]]};var Ce=.01,rw=1,sw=10;const Qh=new Zy;var hl=new it(0,0);let Jn,io,Ne,lr,ir,ce,tu,rr,Za;var wn=[],fo="#ffffff",Ue=[],eu="#ffffff",Ze=[],nu="#ffffff",mi=[],qr=.1;const ad=new od("rainbow",512);ad.setMin(0);ad.setMax(1);function ow(){let o=document.getElementById("buildingVisualization"),t=o.parentElement.clientWidth,e=o.parentElement.clientHeight;Jn.aspect=t/e,Jn.updateProjectionMatrix(),lr.setSize(t,e)}function aw(o){}function lw(o){}function cw(o){let t=lr.getContext().canvas.getBoundingClientRect();hl.x=(o.clientX-t.left)/(t.right-t.left)*2-1,hl.y=-((o.clientY-t.top)/(t.bottom-t.top))*2+1,ce.style.left=o.clientX+15+"px",ce.style.top=o.clientY-5+"px"}function hw(){Ne=new wl,Ne.background=new wt(10526880),Ne.fog=new So(10526880,200,1e3),Jn=new Ie(45,window.innerWidth/window.innerHeight,.001,100),Jn.position.set(0,1,1),io=document.getElementById("buildingVisualization");let o=io.parentElement.clientWidth,t=io.parentElement.clientHeight;lr=new Qt({antialias:!0,canvas:io}),lr.setSize(o,t),Za=new $u(16777215,526368,.8),Za.position.set(0,200,20),Ne.add(Za),tu=new sd(rw,sw),Ne.add(tu),ir=new Qy(Jn,lr.domElement),ir.target.set(0,0,0),ir.enableZoom=!0,ir.update()}function uw(){ce=document.createElement("div"),document.body.appendChild(ce),ce.style.position="absolute",ce.style.top="0px",ce.style.left="0px",ce.style.width="80px",ce.style.height="20px",ce.style.borderRadius="1px",ce.style.borderWidth="1px",ce.style.borderStyle="solid",ce.style.backgroundColor="white",ce.style.opacity="0.9",ce.innerText="Hello World",ce.zIndex="1000",ce.style.fontSize="12px",ce.style.display="none",ce.style.textAlign="center"}function dw(){rr?(ce.innerText=rr.displayInfo,ce.style.display="block"):ce.style.display="none"}function pw(o){for(var t=Object.keys(o);wn.length>0;)Ne.remove(wn.pop());for(var e=new T,n=0;n<t.length;n++){let h=t[n],u=o[h].coordinate;o[h].mass;var i=new Pl(.1*Ce*.4,10,10);i.center();var s=new xi({color:fo,transparent:!0,opacity:.7}),a=new xe(i,s);a.position.x=u[0]*Ce,a.position.y=u[1]*Ce,a.position.z=u[2]*Ce,a.name="node number: "+cr(h)+" Coord: "+ue(u[0])+", "+ue(u[1])+", "+ue(u[2]),a.targetColor=fo,a.displayInfo="node number: "+cr(h),a.displayInfo=a.name,wn.push(a),Ne.add(a),e.x+=a.position.x/t.length,e.y+=a.position.y/t.length,e.z+=a.position.z/t.length}ir.target.set(e.x,e.y,e.z),Jn.position.set(e.x*3,e.y*3,e.z*3),qr=Math.hypot(...e.toArray())*2,console.log("arrowHelperLength: "+qr),mi[0].scale.set(qr,1,1),mi[1].scale.set(1,qr,1),mi[2].scale.set(1,1,qr),console.log(mi[2])}function fw(o,t){for(var e=Object.keys(o);Ue.length>0;)Ne.remove(Ue.pop());for(var n=0;n<e.length;n++){let h=e[n],u=o[h].listNodeNumber[0],d=o[h].listNodeNumber[1],f=new T(t[u].coordinate[0],t[u].coordinate[1],t[u].coordinate[2]),g=new T(t[d].coordinate[0],t[d].coordinate[1],t[d].coordinate[2]),m=new T((f.x+g.x)/2,(f.y+g.y)/2,(f.z+g.z)/2);var i=new To(.1/2*.6*Ce,.1/2*.6*Ce,1,10);i.center();let v=f.sub(g),b=v.length();i.scale(1,b*Ce,1);var s=new xi({color:eu,transparent:!0,opacity:.7}),a=new xe(i,s);a.position.x=m.x*Ce,a.position.y=m.y*Ce,a.position.z=m.z*Ce,a.name="node number: "+cr(h)+" Coord: "+ue(f.x)+", "+ue(f.y)+", "+ue(f.z)+" Coord: "+ue(g.x)+", "+ue(g.y)+", "+ue(g.z),a.targetColor=eu,a.displayInfo="element number: "+cr(h);let y=new we;y.setFromUnitVectors(new T(0,1,0),new T(...v.divideScalar(b).toArray())),a.quaternion.copy(y),Ue.push(a),Ne.add(a),console.log(new T(v.divideScalar(b))),console.log(y),console.log(a)}}function mw(o,t){for(var e=Object.keys(o);Ze.length>0;)Ne.remove(Ze.pop());for(var n=0;n<e.length;n++){let h=e[n],u=o[h].listNodeNumber[0],d=o[h].listNodeNumber[1],f=o[h].listNodeNumber[2],g=o[h].listNodeNumber[3],m=new T(t[u].coordinate[0],t[u].coordinate[2],t[u].coordinate[1]),v=new T(t[d].coordinate[0],t[d].coordinate[2],t[d].coordinate[1]),b=new T(t[f].coordinate[0],t[f].coordinate[2],t[f].coordinate[1]),y=new T(t[g].coordinate[0],t[g].coordinate[2],t[g].coordinate[1]),M=new T((m.x+v.x+b.x+y.x)/4,(m.y+v.y+b.y+y.y)/4,(m.z+v.z+b.z+y.z)/4);var i=new iw([m,v,b,y]);i.center(),i.scale(Ce,Ce,Ce);var s=new xi({color:nu,transparent:!0,opacity:.7}),a=new xe(i,s);a.position.x=M.x*Ce,a.position.y=M.y*Ce,a.position.z=M.z*Ce,a.name="element number: "+cr(h)+" Coord: "+ue(m.x)+", "+ue(m.y)+", "+ue(m.z)+" Coord: "+ue(v.x)+", "+ue(v.y)+", "+ue(v.z)+" Coord: "+ue(b.x)+", "+ue(b.y)+", "+ue(b.z)+" Coord: "+ue(y.x)+", "+ue(y.y)+", "+ue(y.z),a.targetColor=nu,a.displayInfo="element number: "+cr(h),Ze.push(a),Ne.add(a)}}function gw(){let o=1,t=new T(0,0,0);var e=16711680,n=65280,i=255,s=new T(1,0,0),a=new T(0,1,0),h=new T(0,0,1),u=new Ga(s,t,o,e,.003,.003);Ne.add(u);var d=new Ga(a,t,o,n,.003,.003);Ne.add(d);var f=new Ga(h,t,o,i,.003,.003);Ne.add(f),mi.push(u),mi.push(u),mi.push(u)}function ld(){requestAnimationFrame(ld),ir.update(),Rw()}function vw(o){wn.forEach(function(t){t.material.color.set(o)})}function _w(){Ue.forEach(function(o){o.material.color.set(o.targetColor)})}function xw(){Ze.forEach(function(o){o.material.color.set(o.targetColor)})}function bw(o){wn&&wn.forEach(function(t){t.scale.set(o,o,o)})}function yw(o){wn&&wn.forEach(function(t){t.material.opacity=o})}function ww(o){fo=o}function Mw(o){Ue&&Ue.forEach(function(t){t.scale.set(o,1,o)})}function Sw(o){Ue&&Ue.forEach(function(t){t.material.opacity=o})}function Ew(o){Ue.forEach(function(t){t.targetColor=o})}function Tw(){for(let o=0;o<Ue.length;o++){let t=new wt(16777215);t.setHex(Math.random()*16777215),Ue[o].material.color.set(t),Ue[o].targetColor=t}}function Cw(o){Ze&&Ze.forEach(function(t){t.material.opacity=o})}function Aw(o){Ze.forEach(function(t){t.targetColor=o})}function Pw(o){Ze.forEach(function(t){t.visible=o})}function Lw(){for(let o=0;o<Ze.length;o++){let t=new wt(16777215);t.setHex(Math.random()*16777215),Ze[o].material.color.set(t),Ze[o].targetColor=t}}function Rw(){if(Qh.setFromCamera(hl,Jn),wn||Ue||Ze){const o=Qh.intersectObjects(Array.prototype.concat(wn,Ue,Ze),!1);o.length>0?rr!=o[0].object&&(rr=o[0].object,rr.material.color.setHex(16777215)):(vw(fo),_w(),xw(),rr=null)}dw(),lr.render(Ne,Jn)}window.addEventListener("resize",ow,!1);window.addEventListener("pointermove",cw,!1);window.addEventListener("mousedown",aw,!1);window.addEventListener("mouseup",lw,!1);hw();uw();gw();ld();var Dw=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{},ul={exports:{}};/*! Tweakpane 3.0.5 (c) 2016 cocopon, licensed under the MIT license. */(function(o,t){(function(e,n){n(t)})(Dw,function(e){class n{constructor(r){const[l,p]=r.split("-"),w=l.split(".");this.major=parseInt(w[0],10),this.minor=parseInt(w[1],10),this.patch=parseInt(w[2],10),this.prerelease=p!=null?p:null}toString(){const r=[this.major,this.minor,this.patch].join(".");return this.prerelease!==null?[r,this.prerelease].join("-"):r}}class i{constructor(r){this.controller_=r}get disabled(){return this.controller_.viewProps.get("disabled")}set disabled(r){this.controller_.viewProps.set("disabled",r)}get hidden(){return this.controller_.viewProps.get("hidden")}set hidden(r){this.controller_.viewProps.set("hidden",r)}dispose(){this.controller_.viewProps.set("disposed",!0)}}class s{constructor(r){this.target=r}}class a extends s{constructor(r,l,p,w){super(r),this.value=l,this.presetKey=p,this.last=w!=null?w:!0}}class h extends s{constructor(r,l,p){super(r),this.value=l,this.presetKey=p}}class u extends s{constructor(r,l){super(r),this.expanded=l}}function d(c){return c}function f(c){return c==null}function g(c,r){if(c.length!==r.length)return!1;for(let l=0;l<c.length;l++)if(c[l]!==r[l])return!1;return!0}const m={alreadydisposed:()=>"View has been already disposed",invalidparams:c=>`Invalid parameters for '${c.name}'`,nomatchingcontroller:c=>`No matching controller for '${c.key}'`,nomatchingview:c=>`No matching view for '${JSON.stringify(c.params)}'`,notbindable:()=>"Value is not bindable",propertynotfound:c=>`Property '${c.name}' not found`,shouldneverhappen:()=>"This error should never happen"};class v{constructor(r){var l;this.message=(l=m[r.type](r.context))!==null&&l!==void 0?l:"Unexpected error",this.name=this.constructor.name,this.stack=new Error(this.message).stack,this.type=r.type}static alreadyDisposed(){return new v({type:"alreadydisposed"})}static notBindable(){return new v({type:"notbindable"})}static propertyNotFound(r){return new v({type:"propertynotfound",context:{name:r}})}static shouldNeverHappen(){return new v({type:"shouldneverhappen"})}}class b{constructor(r,l,p){this.obj_=r,this.key_=l,this.presetKey_=p!=null?p:l}static isBindable(r){return!(r===null||typeof r!="object")}get key(){return this.key_}get presetKey(){return this.presetKey_}read(){return this.obj_[this.key_]}write(r){this.obj_[this.key_]=r}writeProperty(r,l){const p=this.read();if(!b.isBindable(p))throw v.notBindable();if(!(r in p))throw v.propertyNotFound(r);p[r]=l}}class y extends i{get label(){return this.controller_.props.get("label")}set label(r){this.controller_.props.set("label",r)}get title(){var r;return(r=this.controller_.valueController.props.get("title"))!==null&&r!==void 0?r:""}set title(r){this.controller_.valueController.props.set("title",r)}on(r,l){const p=l.bind(this);return this.controller_.valueController.emitter.on(r,()=>{p(new s(this))}),this}}class M{constructor(){this.observers_={}}on(r,l){let p=this.observers_[r];return p||(p=this.observers_[r]=[]),p.push({handler:l}),this}off(r,l){const p=this.observers_[r];return p&&(this.observers_[r]=p.filter(w=>w.handler!==l)),this}emit(r,l){const p=this.observers_[r];!p||p.forEach(w=>{w.handler(l)})}}const x="tp";function _(c){return(l,p)=>[x,"-",c,"v",l?`_${l}`:"",p?`-${p}`:""].join("")}function R(c,r){return l=>r(c(l))}function L(c){return c.rawValue}function A(c,r){c.emitter.on("change",R(L,r)),r(c.rawValue)}function N(c,r,l){A(c.value(r),l)}function C(c,r,l){l?c.classList.add(r):c.classList.remove(r)}function z(c,r){return l=>{C(c,r,l)}}function tt(c,r){A(c,l=>{r.textContent=l!=null?l:""})}const W=_("btn");class F{constructor(r,l){this.element=r.createElement("div"),this.element.classList.add(W()),l.viewProps.bindClassModifiers(this.element);const p=r.createElement("button");p.classList.add(W("b")),l.viewProps.bindDisabled(p),this.element.appendChild(p),this.buttonElement=p;const w=r.createElement("div");w.classList.add(W("t")),tt(l.props.value("title"),w),this.buttonElement.appendChild(w)}}class rt{constructor(r,l){this.emitter=new M,this.onClick_=this.onClick_.bind(this),this.props=l.props,this.viewProps=l.viewProps,this.view=new F(r,{props:this.props,viewProps:this.viewProps}),this.view.buttonElement.addEventListener("click",this.onClick_)}onClick_(){this.emitter.emit("click",{sender:this})}}class H{constructor(r,l){var p;this.constraint_=l==null?void 0:l.constraint,this.equals_=(p=l==null?void 0:l.equals)!==null&&p!==void 0?p:(w,I)=>w===I,this.emitter=new M,this.rawValue_=r}get constraint(){return this.constraint_}get rawValue(){return this.rawValue_}set rawValue(r){this.setRawValue(r,{forceEmit:!1,last:!0})}setRawValue(r,l){const p=l!=null?l:{forceEmit:!1,last:!0},w=this.constraint_?this.constraint_.constrain(r):r;!!this.equals_(this.rawValue_,w)&&!p.forceEmit||(this.emitter.emit("beforechange",{sender:this}),this.rawValue_=w,this.emitter.emit("change",{options:p,rawValue:w,sender:this}))}}class G{constructor(r){this.emitter=new M,this.value_=r}get rawValue(){return this.value_}set rawValue(r){this.setRawValue(r,{forceEmit:!1,last:!0})}setRawValue(r,l){const p=l!=null?l:{forceEmit:!1,last:!0};this.value_===r&&!p.forceEmit||(this.emitter.emit("beforechange",{sender:this}),this.value_=r,this.emitter.emit("change",{options:p,rawValue:this.value_,sender:this}))}}function j(c,r){const l=r==null?void 0:r.constraint,p=r==null?void 0:r.equals;return!l&&!p?new G(c):new H(c,r)}class B{constructor(r){this.emitter=new M,this.valMap_=r;for(const l in this.valMap_)this.valMap_[l].emitter.on("change",()=>{this.emitter.emit("change",{key:l,sender:this})})}static createCore(r){return Object.keys(r).reduce((p,w)=>Object.assign(p,{[w]:j(r[w])}),{})}static fromObject(r){const l=this.createCore(r);return new B(l)}get(r){return this.valMap_[r].rawValue}set(r,l){this.valMap_[r].rawValue=l}value(r){return this.valMap_[r]}}function K(c,r){const p=Object.keys(r).reduce((w,I)=>{if(w===void 0)return;const O=r[I],ct=O(c[I]);return ct.succeeded?Object.assign(Object.assign({},w),{[I]:ct.value}):void 0},{});return p}function at(c,r){return c.reduce((l,p)=>{if(l===void 0)return;const w=r(p);if(!(!w.succeeded||w.value===void 0))return[...l,w.value]},[])}function yt(c){return c===null?!1:typeof c=="object"}function bt(c){return r=>l=>{if(!r&&l===void 0)return{succeeded:!1,value:void 0};if(r&&l===void 0)return{succeeded:!0,value:void 0};const p=c(l);return p!==void 0?{succeeded:!0,value:p}:{succeeded:!1,value:void 0}}}function mt(c){return{custom:r=>bt(r)(c),boolean:bt(r=>typeof r=="boolean"?r:void 0)(c),number:bt(r=>typeof r=="number"?r:void 0)(c),string:bt(r=>typeof r=="string"?r:void 0)(c),function:bt(r=>typeof r=="function"?r:void 0)(c),constant:r=>bt(l=>l===r?r:void 0)(c),raw:bt(r=>r)(c),object:r=>bt(l=>{if(!!yt(l))return K(l,r)})(c),array:r=>bt(l=>{if(!!Array.isArray(l))return at(l,r)})(c)}}const vt={optional:mt(!0),required:mt(!1)};function J(c,r){const l=vt.required.object(r)(c);return l.succeeded?l.value:void 0}function st(c){return c&&c.parentElement&&c.parentElement.removeChild(c),null}function Mt(){return["veryfirst","first","last","verylast"]}const q=_(""),Ct={veryfirst:"vfst",first:"fst",last:"lst",verylast:"vlst"};class At{constructor(r){this.parent_=null,this.blade=r.blade,this.view=r.view,this.viewProps=r.viewProps;const l=this.view.element;this.blade.value("positions").emitter.on("change",()=>{Mt().forEach(p=>{l.classList.remove(q(void 0,Ct[p]))}),this.blade.get("positions").forEach(p=>{l.classList.add(q(void 0,Ct[p]))})}),this.viewProps.handleDispose(()=>{st(l)})}get parent(){return this.parent_}}const dt="http://www.w3.org/2000/svg";function xt(c){c.offsetHeight}function kt(c,r){const l=c.style.transition;c.style.transition="none",r(),c.style.transition=l}function Z(c){return c.ontouchstart!==void 0}function nt(){return new Function("return this")()}function lt(){return nt().document}function St(){return"document"in nt()}function ut(c){return St()?c.getContext("2d"):null}const P={check:'<path d="M2 8l4 4l8 -8"/>',dropdown:'<path d="M5 7h6l-3 3 z"/>',p2dpad:'<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'};function E(c,r){const l=c.createElementNS(dt,"svg");return l.innerHTML=P[r],l}function Y(c,r,l){c.insertBefore(r,c.children[l])}function Q(c){c.parentElement&&c.parentElement.removeChild(c)}function ht(c){for(;c.children.length>0;)c.removeChild(c.children[0])}function _t(c){for(;c.childNodes.length>0;)c.removeChild(c.childNodes[0])}function Lt(c){return c.relatedTarget?c.relatedTarget:"explicitOriginalTarget"in c?c.explicitOriginalTarget:null}const Et=_("lbl");function Nt(c,r){const l=c.createDocumentFragment();return r.split(`
`).map(w=>c.createTextNode(w)).forEach((w,I)=>{I>0&&l.appendChild(c.createElement("br")),l.appendChild(w)}),l}class Tt{constructor(r,l){this.element=r.createElement("div"),this.element.classList.add(Et()),l.viewProps.bindClassModifiers(this.element);const p=r.createElement("div");p.classList.add(Et("l")),N(l.props,"label",I=>{f(I)?this.element.classList.add(Et(void 0,"nol")):(this.element.classList.remove(Et(void 0,"nol")),_t(p),p.appendChild(Nt(r,I)))}),this.element.appendChild(p),this.labelElement=p;const w=r.createElement("div");w.classList.add(Et("v")),this.element.appendChild(w),this.valueElement=w}}class k extends At{constructor(r,l){const p=l.valueController.viewProps;super(Object.assign(Object.assign({},l),{view:new Tt(r,{props:l.props,viewProps:p}),viewProps:p})),this.props=l.props,this.valueController=l.valueController,this.view.valueElement.appendChild(this.valueController.view.element)}}const pt={id:"button",type:"blade",accept(c){const r=vt,l=J(c,{title:r.required.string,view:r.required.constant("button"),label:r.optional.string});return l?{params:l}:null},controller(c){return new k(c.document,{blade:c.blade,props:B.fromObject({label:c.params.label}),valueController:new rt(c.document,{props:B.fromObject({title:c.params.title}),viewProps:c.viewProps})})},api(c){return!(c.controller instanceof k)||!(c.controller.valueController instanceof rt)?null:new y(c.controller)}};class $ extends At{constructor(r){super(r),this.value=r.value}}function gt(){return new B({positions:j([],{equals:g})})}class D extends B{constructor(r){super(r)}static create(r){const l={completed:!0,expanded:r,expandedHeight:null,shouldFixHeight:!1,temporaryExpanded:null},p=B.createCore(l);return new D(p)}get styleExpanded(){var r;return(r=this.get("temporaryExpanded"))!==null&&r!==void 0?r:this.get("expanded")}get styleHeight(){if(!this.styleExpanded)return"0";const r=this.get("expandedHeight");return this.get("shouldFixHeight")&&!f(r)?`${r}px`:"auto"}bindExpandedClass(r,l){N(this,"expanded",()=>{this.styleExpanded?r.classList.add(l):r.classList.remove(l)})}}function ot(c,r){let l=0;return kt(r,()=>{c.set("expandedHeight",null),c.set("temporaryExpanded",!0),xt(r),l=r.clientHeight,c.set("temporaryExpanded",null),xt(r)}),l}function zt(c,r){r.style.height=c.styleHeight}function Ut(c,r){c.value("expanded").emitter.on("beforechange",()=>{c.set("completed",!1),f(c.get("expandedHeight"))&&c.set("expandedHeight",ot(c,r)),c.set("shouldFixHeight",!0),xt(r)}),c.emitter.on("change",()=>{zt(c,r)}),zt(c,r),r.addEventListener("transitionend",l=>{l.propertyName==="height"&&(c.set("shouldFixHeight",!1),c.set("expandedHeight",null),c.set("completed",!0))})}class ie extends i{constructor(r,l){super(r),this.rackApi_=l}}function Kt(c,r){return c.addBlade(Object.assign(Object.assign({},r),{view:"button"}))}function Se(c,r){return c.addBlade(Object.assign(Object.assign({},r),{view:"folder"}))}function ke(c,r){const l=r||{};return c.addBlade(Object.assign(Object.assign({},l),{view:"separator"}))}function Le(c,r){return c.addBlade(Object.assign(Object.assign({},r),{view:"tab"}))}class Re{constructor(r){this.emitter=new M,this.items_=[],this.cache_=new Set,this.onSubListAdd_=this.onSubListAdd_.bind(this),this.onSubListRemove_=this.onSubListRemove_.bind(this),this.extract_=r}get items(){return this.items_}allItems(){return Array.from(this.cache_)}find(r){for(const l of this.allItems())if(r(l))return l;return null}includes(r){return this.cache_.has(r)}add(r,l){if(this.includes(r))throw v.shouldNeverHappen();const p=l!==void 0?l:this.items_.length;this.items_.splice(p,0,r),this.cache_.add(r);const w=this.extract_(r);w&&(w.emitter.on("add",this.onSubListAdd_),w.emitter.on("remove",this.onSubListRemove_),w.allItems().forEach(I=>{this.cache_.add(I)})),this.emitter.emit("add",{index:p,item:r,root:this,target:this})}remove(r){const l=this.items_.indexOf(r);if(l<0)return;this.items_.splice(l,1),this.cache_.delete(r);const p=this.extract_(r);p&&(p.emitter.off("add",this.onSubListAdd_),p.emitter.off("remove",this.onSubListRemove_)),this.emitter.emit("remove",{index:l,item:r,root:this,target:this})}onSubListAdd_(r){this.cache_.add(r.item),this.emitter.emit("add",{index:r.index,item:r.item,root:this,target:r.target})}onSubListRemove_(r){this.cache_.delete(r.item),this.emitter.emit("remove",{index:r.index,item:r.item,root:this,target:r.target})}}class bi extends i{constructor(r){super(r),this.onBindingChange_=this.onBindingChange_.bind(this),this.emitter_=new M,this.controller_.binding.emitter.on("change",this.onBindingChange_)}get label(){return this.controller_.props.get("label")}set label(r){this.controller_.props.set("label",r)}on(r,l){const p=l.bind(this);return this.emitter_.on(r,w=>{p(w.event)}),this}refresh(){this.controller_.binding.read()}onBindingChange_(r){const l=r.sender.target.read();this.emitter_.emit("change",{event:new a(this,l,this.controller_.binding.target.presetKey,r.options.last)})}}class Ge extends k{constructor(r,l){super(r,l),this.binding=l.binding}}class rn extends i{constructor(r){super(r),this.onBindingUpdate_=this.onBindingUpdate_.bind(this),this.emitter_=new M,this.controller_.binding.emitter.on("update",this.onBindingUpdate_)}get label(){return this.controller_.props.get("label")}set label(r){this.controller_.props.set("label",r)}on(r,l){const p=l.bind(this);return this.emitter_.on(r,w=>{p(w.event)}),this}refresh(){this.controller_.binding.read()}onBindingUpdate_(r){const l=r.sender.target.read();this.emitter_.emit("update",{event:new h(this,l,this.controller_.binding.target.presetKey)})}}class sn extends k{constructor(r,l){super(r,l),this.binding=l.binding,this.viewProps.bindDisabled(this.binding.ticker),this.viewProps.handleDispose(()=>{this.binding.dispose()})}}function cs(c){return c instanceof yi?c.apiSet_:c instanceof ie?c.rackApi_.apiSet_:null}function ni(c,r){const l=c.find(p=>p.controller_===r);if(!l)throw v.shouldNeverHappen();return l}function ii(c,r,l){if(!b.isBindable(c))throw v.notBindable();return new b(c,r,l)}class yi extends i{constructor(r,l){super(r),this.onRackAdd_=this.onRackAdd_.bind(this),this.onRackRemove_=this.onRackRemove_.bind(this),this.onRackInputChange_=this.onRackInputChange_.bind(this),this.onRackMonitorUpdate_=this.onRackMonitorUpdate_.bind(this),this.emitter_=new M,this.apiSet_=new Re(cs),this.pool_=l;const p=this.controller_.rack;p.emitter.on("add",this.onRackAdd_),p.emitter.on("remove",this.onRackRemove_),p.emitter.on("inputchange",this.onRackInputChange_),p.emitter.on("monitorupdate",this.onRackMonitorUpdate_),p.children.forEach(w=>{this.setUpApi_(w)})}get children(){return this.controller_.rack.children.map(r=>ni(this.apiSet_,r))}addInput(r,l,p){const w=p||{},I=this.controller_.view.element.ownerDocument,O=this.pool_.createInput(I,ii(r,l,w.presetKey),w),ct=new bi(O);return this.add(ct,w.index)}addMonitor(r,l,p){const w=p||{},I=this.controller_.view.element.ownerDocument,O=this.pool_.createMonitor(I,ii(r,l),w),ct=new rn(O);return this.add(ct,w.index)}addFolder(r){return Se(this,r)}addButton(r){return Kt(this,r)}addSeparator(r){return ke(this,r)}addTab(r){return Le(this,r)}add(r,l){this.controller_.rack.add(r.controller_,l);const p=this.apiSet_.find(w=>w.controller_===r.controller_);return p&&this.apiSet_.remove(p),this.apiSet_.add(r),r}remove(r){this.controller_.rack.remove(r.controller_)}addBlade(r){const l=this.controller_.view.element.ownerDocument,p=this.pool_.createBlade(l,r),w=this.pool_.createBladeApi(p);return this.add(w,r.index)}on(r,l){const p=l.bind(this);return this.emitter_.on(r,w=>{p(w.event)}),this}setUpApi_(r){this.apiSet_.find(p=>p.controller_===r)||this.apiSet_.add(this.pool_.createBladeApi(r))}onRackAdd_(r){this.setUpApi_(r.bladeController)}onRackRemove_(r){if(r.isRoot){const l=ni(this.apiSet_,r.bladeController);this.apiSet_.remove(l)}}onRackInputChange_(r){const l=r.bladeController;if(l instanceof Ge){const p=ni(this.apiSet_,l),w=l.binding;this.emitter_.emit("change",{event:new a(p,w.target.read(),w.target.presetKey,r.options.last)})}else if(l instanceof $){const p=ni(this.apiSet_,l);this.emitter_.emit("change",{event:new a(p,l.value.rawValue,void 0,r.options.last)})}}onRackMonitorUpdate_(r){if(!(r.bladeController instanceof sn))throw v.shouldNeverHappen();const l=ni(this.apiSet_,r.bladeController),p=r.bladeController.binding;this.emitter_.emit("update",{event:new h(l,p.target.read(),p.target.presetKey)})}}class ri extends ie{constructor(r,l){super(r,new yi(r.rackController,l)),this.emitter_=new M,this.controller_.foldable.value("expanded").emitter.on("change",p=>{this.emitter_.emit("fold",{event:new u(this,p.sender.rawValue)})}),this.rackApi_.on("change",p=>{this.emitter_.emit("change",{event:p})}),this.rackApi_.on("update",p=>{this.emitter_.emit("update",{event:p})})}get expanded(){return this.controller_.foldable.get("expanded")}set expanded(r){this.controller_.foldable.set("expanded",r)}get title(){return this.controller_.props.get("title")}set title(r){this.controller_.props.set("title",r)}get children(){return this.rackApi_.children}addInput(r,l,p){return this.rackApi_.addInput(r,l,p)}addMonitor(r,l,p){return this.rackApi_.addMonitor(r,l,p)}addFolder(r){return this.rackApi_.addFolder(r)}addButton(r){return this.rackApi_.addButton(r)}addSeparator(r){return this.rackApi_.addSeparator(r)}addTab(r){return this.rackApi_.addTab(r)}add(r,l){return this.rackApi_.add(r,l)}remove(r){this.rackApi_.remove(r)}addBlade(r){return this.rackApi_.addBlade(r)}on(r,l){const p=l.bind(this);return this.emitter_.on(r,w=>{p(w.event)}),this}}class wi extends At{constructor(r){super({blade:r.blade,view:r.view,viewProps:r.rackController.viewProps}),this.rackController=r.rackController}}class hs{constructor(r,l){const p=_(l.viewName);this.element=r.createElement("div"),this.element.classList.add(p()),l.viewProps.bindClassModifiers(this.element)}}function Lo(c,r){for(let l=0;l<c.length;l++){const p=c[l];if(p instanceof Ge&&p.binding===r)return p}return null}function Ro(c,r){for(let l=0;l<c.length;l++){const p=c[l];if(p instanceof sn&&p.binding===r)return p}return null}function S(c,r){for(let l=0;l<c.length;l++){const p=c[l];if(p instanceof $&&p.value===r)return p}return null}function U(c){return c instanceof et?c.rack:c instanceof wi?c.rackController.rack:null}function V(c){const r=U(c);return r?r.bcSet_:null}class X{constructor(r){var l;this.onBladePositionsChange_=this.onBladePositionsChange_.bind(this),this.onSetAdd_=this.onSetAdd_.bind(this),this.onSetRemove_=this.onSetRemove_.bind(this),this.onChildDispose_=this.onChildDispose_.bind(this),this.onChildPositionsChange_=this.onChildPositionsChange_.bind(this),this.onChildInputChange_=this.onChildInputChange_.bind(this),this.onChildMonitorUpdate_=this.onChildMonitorUpdate_.bind(this),this.onChildValueChange_=this.onChildValueChange_.bind(this),this.onChildViewPropsChange_=this.onChildViewPropsChange_.bind(this),this.onDescendantLayout_=this.onDescendantLayout_.bind(this),this.onDescendantInputChange_=this.onDescendantInputChange_.bind(this),this.onDescendantMonitorUpdate_=this.onDescendantMonitorUpdate_.bind(this),this.emitter=new M,this.blade_=r!=null?r:null,(l=this.blade_)===null||l===void 0||l.value("positions").emitter.on("change",this.onBladePositionsChange_),this.bcSet_=new Re(V),this.bcSet_.emitter.on("add",this.onSetAdd_),this.bcSet_.emitter.on("remove",this.onSetRemove_)}get children(){return this.bcSet_.items}add(r,l){r.parent&&r.parent.remove(r),r.parent_=this,this.bcSet_.add(r,l)}remove(r){r.parent_=null,this.bcSet_.remove(r)}find(r){return this.bcSet_.allItems().filter(l=>l instanceof r)}onSetAdd_(r){this.updatePositions_();const l=r.target===r.root;if(this.emitter.emit("add",{bladeController:r.item,index:r.index,isRoot:l,sender:this}),!l)return;const p=r.item;if(p.viewProps.emitter.on("change",this.onChildViewPropsChange_),p.blade.value("positions").emitter.on("change",this.onChildPositionsChange_),p.viewProps.handleDispose(this.onChildDispose_),p instanceof Ge)p.binding.emitter.on("change",this.onChildInputChange_);else if(p instanceof sn)p.binding.emitter.on("update",this.onChildMonitorUpdate_);else if(p instanceof $)p.value.emitter.on("change",this.onChildValueChange_);else{const w=U(p);if(w){const I=w.emitter;I.on("layout",this.onDescendantLayout_),I.on("inputchange",this.onDescendantInputChange_),I.on("monitorupdate",this.onDescendantMonitorUpdate_)}}}onSetRemove_(r){this.updatePositions_();const l=r.target===r.root;if(this.emitter.emit("remove",{bladeController:r.item,isRoot:l,sender:this}),!l)return;const p=r.item;if(p instanceof Ge)p.binding.emitter.off("change",this.onChildInputChange_);else if(p instanceof sn)p.binding.emitter.off("update",this.onChildMonitorUpdate_);else if(p instanceof $)p.value.emitter.off("change",this.onChildValueChange_);else{const w=U(p);if(w){const I=w.emitter;I.off("layout",this.onDescendantLayout_),I.off("inputchange",this.onDescendantInputChange_),I.off("monitorupdate",this.onDescendantMonitorUpdate_)}}}updatePositions_(){const r=this.bcSet_.items.filter(w=>!w.viewProps.get("hidden")),l=r[0],p=r[r.length-1];this.bcSet_.items.forEach(w=>{const I=[];w===l&&(I.push("first"),(!this.blade_||this.blade_.get("positions").includes("veryfirst"))&&I.push("veryfirst")),w===p&&(I.push("last"),(!this.blade_||this.blade_.get("positions").includes("verylast"))&&I.push("verylast")),w.blade.set("positions",I)})}onChildPositionsChange_(){this.updatePositions_(),this.emitter.emit("layout",{sender:this})}onChildViewPropsChange_(r){this.updatePositions_(),this.emitter.emit("layout",{sender:this})}onChildDispose_(){this.bcSet_.items.filter(l=>l.viewProps.get("disposed")).forEach(l=>{this.bcSet_.remove(l)})}onChildInputChange_(r){const l=Lo(this.find(Ge),r.sender);if(!l)throw v.shouldNeverHappen();this.emitter.emit("inputchange",{bladeController:l,options:r.options,sender:this})}onChildMonitorUpdate_(r){const l=Ro(this.find(sn),r.sender);if(!l)throw v.shouldNeverHappen();this.emitter.emit("monitorupdate",{bladeController:l,sender:this})}onChildValueChange_(r){const l=S(this.find($),r.sender);if(!l)throw v.shouldNeverHappen();this.emitter.emit("inputchange",{bladeController:l,options:r.options,sender:this})}onDescendantLayout_(r){this.updatePositions_(),this.emitter.emit("layout",{sender:this})}onDescendantInputChange_(r){this.emitter.emit("inputchange",{bladeController:r.bladeController,options:r.options,sender:this})}onDescendantMonitorUpdate_(r){this.emitter.emit("monitorupdate",{bladeController:r.bladeController,sender:this})}onBladePositionsChange_(){this.updatePositions_()}}class et extends At{constructor(r,l){super(Object.assign(Object.assign({},l),{view:new hs(r,{viewName:"brk",viewProps:l.viewProps})})),this.onRackAdd_=this.onRackAdd_.bind(this),this.onRackRemove_=this.onRackRemove_.bind(this);const p=new X(l.root?void 0:l.blade);p.emitter.on("add",this.onRackAdd_),p.emitter.on("remove",this.onRackRemove_),this.rack=p,this.viewProps.handleDispose(()=>{for(let w=this.rack.children.length-1;w>=0;w--)this.rack.children[w].viewProps.set("disposed",!0)})}onRackAdd_(r){!r.isRoot||Y(this.view.element,r.bladeController.view.element,r.index)}onRackRemove_(r){!r.isRoot||Q(r.bladeController.view.element)}}const Vt=_("cnt");class Rt{constructor(r,l){this.className_=_(l.viewName||"fld"),this.element=r.createElement("div"),this.element.classList.add(this.className_(),Vt()),l.viewProps.bindClassModifiers(this.element),this.foldable_=l.foldable,this.foldable_.bindExpandedClass(this.element,this.className_(void 0,"expanded")),N(this.foldable_,"completed",z(this.element,this.className_(void 0,"cpl")));const p=r.createElement("button");p.classList.add(this.className_("b")),N(l.props,"title",ct=>{f(ct)?this.element.classList.add(this.className_(void 0,"not")):this.element.classList.remove(this.className_(void 0,"not"))}),l.viewProps.bindDisabled(p),this.element.appendChild(p),this.buttonElement=p;const w=r.createElement("div");w.classList.add(this.className_("t")),tt(l.props.value("title"),w),this.buttonElement.appendChild(w),this.titleElement=w;const I=r.createElement("div");I.classList.add(this.className_("m")),this.buttonElement.appendChild(I);const O=l.containerElement;O.classList.add(this.className_("c")),this.element.appendChild(O),this.containerElement=O}}class Pt extends wi{constructor(r,l){var p;const w=D.create((p=l.expanded)!==null&&p!==void 0?p:!0),I=new et(r,{blade:l.blade,root:l.root,viewProps:l.viewProps});super(Object.assign(Object.assign({},l),{rackController:I,view:new Rt(r,{containerElement:I.view.element,foldable:w,props:l.props,viewName:l.root?"rot":void 0,viewProps:l.viewProps})})),this.onTitleClick_=this.onTitleClick_.bind(this),this.props=l.props,this.foldable=w,Ut(this.foldable,this.view.containerElement),this.view.buttonElement.addEventListener("click",this.onTitleClick_)}get document(){return this.view.element.ownerDocument}onTitleClick_(){this.foldable.set("expanded",!this.foldable.get("expanded"))}}const Ot={id:"folder",type:"blade",accept(c){const r=vt,l=J(c,{title:r.required.string,view:r.required.constant("folder"),expanded:r.optional.boolean});return l?{params:l}:null},controller(c){return new Pt(c.document,{blade:c.blade,expanded:c.params.expanded,props:B.fromObject({title:c.params.title}),viewProps:c.viewProps})},api(c){return c.controller instanceof Pt?new ri(c.controller,c.pool):null}};class Wt extends ${constructor(r,l){const p=l.valueController.viewProps;super(Object.assign(Object.assign({},l),{value:l.valueController.value,view:new Tt(r,{props:l.props,viewProps:p}),viewProps:p})),this.props=l.props,this.valueController=l.valueController,this.view.valueElement.appendChild(this.valueController.view.element)}}class Ht extends i{}const jt=_("spr");class Ft{constructor(r,l){this.element=r.createElement("div"),this.element.classList.add(jt()),l.viewProps.bindClassModifiers(this.element);const p=r.createElement("hr");p.classList.add(jt("r")),this.element.appendChild(p)}}class pn extends At{constructor(r,l){super(Object.assign(Object.assign({},l),{view:new Ft(r,{viewProps:l.viewProps})}))}}const le={id:"separator",type:"blade",accept(c){const l=J(c,{view:vt.required.constant("separator")});return l?{params:l}:null},controller(c){return new pn(c.document,{blade:c.blade,viewProps:c.viewProps})},api(c){return c.controller instanceof pn?new Ht(c.controller):null}},fn=_("");function Be(c,r){return z(c,fn(void 0,r))}class Ee extends B{constructor(r){super(r)}static create(r){var l,p;const w=r!=null?r:{},I={disabled:(l=w.disabled)!==null&&l!==void 0?l:!1,disposed:!1,hidden:(p=w.hidden)!==null&&p!==void 0?p:!1},O=B.createCore(I);return new Ee(O)}bindClassModifiers(r){N(this,"disabled",Be(r,"disabled")),N(this,"hidden",Be(r,"hidden"))}bindDisabled(r){N(this,"disabled",l=>{r.disabled=l})}bindTabIndex(r){N(this,"disabled",l=>{r.tabIndex=l?-1:0})}handleDispose(r){this.value("disposed").emitter.on("change",l=>{l&&r()})}}const Ve=_("tbi");class pe{constructor(r,l){this.element=r.createElement("div"),this.element.classList.add(Ve()),l.viewProps.bindClassModifiers(this.element),N(l.props,"selected",I=>{I?this.element.classList.add(Ve(void 0,"sel")):this.element.classList.remove(Ve(void 0,"sel"))});const p=r.createElement("button");p.classList.add(Ve("b")),l.viewProps.bindDisabled(p),this.element.appendChild(p),this.buttonElement=p;const w=r.createElement("div");w.classList.add(Ve("t")),tt(l.props.value("title"),w),this.buttonElement.appendChild(w),this.titleElement=w}}class Je{constructor(r,l){this.emitter=new M,this.onClick_=this.onClick_.bind(this),this.props=l.props,this.viewProps=l.viewProps,this.view=new pe(r,{props:l.props,viewProps:l.viewProps}),this.view.buttonElement.addEventListener("click",this.onClick_)}onClick_(){this.emitter.emit("click",{sender:this})}}class fe{constructor(r,l){this.onItemClick_=this.onItemClick_.bind(this),this.ic_=new Je(r,{props:l.itemProps,viewProps:Ee.create()}),this.ic_.emitter.on("click",this.onItemClick_),this.cc_=new et(r,{blade:gt(),viewProps:Ee.create()}),this.props=l.props,N(this.props,"selected",p=>{this.itemController.props.set("selected",p),this.contentController.viewProps.set("hidden",!p)})}get itemController(){return this.ic_}get contentController(){return this.cc_}onItemClick_(){this.props.set("selected",!0)}}class Fl{constructor(r,l){this.controller_=r,this.rackApi_=l}get title(){var r;return(r=this.controller_.itemController.props.get("title"))!==null&&r!==void 0?r:""}set title(r){this.controller_.itemController.props.set("title",r)}get selected(){return this.controller_.props.get("selected")}set selected(r){this.controller_.props.set("selected",r)}get children(){return this.rackApi_.children}addButton(r){return this.rackApi_.addButton(r)}addFolder(r){return this.rackApi_.addFolder(r)}addSeparator(r){return this.rackApi_.addSeparator(r)}addTab(r){return this.rackApi_.addTab(r)}add(r,l){this.rackApi_.add(r,l)}remove(r){this.rackApi_.remove(r)}addInput(r,l,p){return this.rackApi_.addInput(r,l,p)}addMonitor(r,l,p){return this.rackApi_.addMonitor(r,l,p)}addBlade(r){return this.rackApi_.addBlade(r)}}class kl extends ie{constructor(r,l){super(r,new yi(r.rackController,l)),this.onPageAdd_=this.onPageAdd_.bind(this),this.onPageRemove_=this.onPageRemove_.bind(this),this.emitter_=new M,this.pageApiMap_=new Map,this.rackApi_.on("change",p=>{this.emitter_.emit("change",{event:p})}),this.rackApi_.on("update",p=>{this.emitter_.emit("update",{event:p})}),this.controller_.pageSet.emitter.on("add",this.onPageAdd_),this.controller_.pageSet.emitter.on("remove",this.onPageRemove_),this.controller_.pageSet.items.forEach(p=>{this.setUpPageApi_(p)})}get pages(){return this.controller_.pageSet.items.map(r=>{const l=this.pageApiMap_.get(r);if(!l)throw v.shouldNeverHappen();return l})}addPage(r){const l=this.controller_.view.element.ownerDocument,p=new fe(l,{itemProps:B.fromObject({selected:!1,title:r.title}),props:B.fromObject({selected:!1})});this.controller_.add(p,r.index);const w=this.pageApiMap_.get(p);if(!w)throw v.shouldNeverHappen();return w}removePage(r){this.controller_.remove(r)}on(r,l){const p=l.bind(this);return this.emitter_.on(r,w=>{p(w.event)}),this}setUpPageApi_(r){const l=this.rackApi_.apiSet_.find(w=>w.controller_===r.contentController);if(!l)throw v.shouldNeverHappen();const p=new Fl(r,l);this.pageApiMap_.set(r,p)}onPageAdd_(r){this.setUpPageApi_(r.item)}onPageRemove_(r){if(!this.pageApiMap_.get(r.item))throw v.shouldNeverHappen();this.pageApiMap_.delete(r.item)}}const us=_("tab");class cd{constructor(r,l){this.element=r.createElement("div"),this.element.classList.add(us(),Vt()),l.viewProps.bindClassModifiers(this.element),A(l.empty,z(this.element,us(void 0,"nop")));const p=r.createElement("div");p.classList.add(us("i")),this.element.appendChild(p),this.itemsElement=p;const w=l.contentsElement;w.classList.add(us("c")),this.element.appendChild(w),this.contentsElement=w}}class Bl extends wi{constructor(r,l){const p=new et(r,{blade:l.blade,viewProps:l.viewProps}),w=j(!0);super({blade:l.blade,rackController:p,view:new cd(r,{contentsElement:p.view.element,empty:w,viewProps:l.viewProps})}),this.onPageAdd_=this.onPageAdd_.bind(this),this.onPageRemove_=this.onPageRemove_.bind(this),this.onPageSelectedChange_=this.onPageSelectedChange_.bind(this),this.pageSet_=new Re(()=>null),this.pageSet_.emitter.on("add",this.onPageAdd_),this.pageSet_.emitter.on("remove",this.onPageRemove_),this.empty_=w,this.applyPages_()}get pageSet(){return this.pageSet_}add(r,l){this.pageSet_.add(r,l!=null?l:this.pageSet_.items.length)}remove(r){this.pageSet_.remove(this.pageSet_.items[r])}applyPages_(){this.keepSelection_(),this.empty_.rawValue=this.pageSet_.items.length===0}onPageAdd_(r){const l=r.item;Y(this.view.itemsElement,l.itemController.view.element,r.index),this.rackController.rack.add(l.contentController,r.index),l.props.value("selected").emitter.on("change",this.onPageSelectedChange_),this.applyPages_()}onPageRemove_(r){const l=r.item;Q(l.itemController.view.element),this.rackController.rack.remove(l.contentController),l.props.value("selected").emitter.off("change",this.onPageSelectedChange_),this.applyPages_()}keepSelection_(){if(this.pageSet_.items.length===0)return;const r=this.pageSet_.items.findIndex(l=>l.props.get("selected"));r<0?this.pageSet_.items.forEach((l,p)=>{l.props.set("selected",p===0)}):this.pageSet_.items.forEach((l,p)=>{l.props.set("selected",p===r)})}onPageSelectedChange_(r){if(r.rawValue){const l=this.pageSet_.items.findIndex(p=>p.props.value("selected")===r.sender);this.pageSet_.items.forEach((p,w)=>{p.props.set("selected",w===l)})}else this.keepSelection_()}}const Vl={id:"tab",type:"blade",accept(c){const r=vt,l=J(c,{pages:r.required.array(r.required.object({title:r.required.string})),view:r.required.constant("tab")});return!l||l.pages.length===0?null:{params:l}},controller(c){const r=new Bl(c.document,{blade:c.blade,viewProps:c.viewProps});return c.params.pages.forEach(l=>{const p=new fe(c.document,{itemProps:B.fromObject({selected:!1,title:l.title}),props:B.fromObject({selected:!1})});r.add(p)}),r},api(c){return c.controller instanceof Bl?new kl(c.controller,c.pool):null}};function hd(c,r){const l=c.accept(r.params);if(!l)return null;const p=vt.optional.boolean(r.params.disabled).value,w=vt.optional.boolean(r.params.hidden).value;return c.controller({blade:gt(),document:r.document,params:Object.assign(Object.assign({},l.params),{disabled:p,hidden:w}),viewProps:Ee.create({disabled:p,hidden:w})})}class ud{constructor(){this.disabled=!1,this.emitter=new M}dispose(){}tick(){this.disabled||this.emitter.emit("tick",{sender:this})}}class dd{constructor(r,l){this.disabled_=!1,this.timerId_=null,this.onTick_=this.onTick_.bind(this),this.doc_=r,this.emitter=new M,this.interval_=l,this.setTimer_()}get disabled(){return this.disabled_}set disabled(r){this.disabled_=r,this.disabled_?this.clearTimer_():this.setTimer_()}dispose(){this.clearTimer_()}clearTimer_(){if(this.timerId_===null)return;const r=this.doc_.defaultView;r&&r.clearInterval(this.timerId_),this.timerId_=null}setTimer_(){if(this.clearTimer_(),this.interval_<=0)return;const r=this.doc_.defaultView;r&&(this.timerId_=r.setInterval(this.onTick_,this.interval_))}onTick_(){this.disabled_||this.emitter.emit("tick",{sender:this})}}class si{constructor(r){this.constraints=r}constrain(r){return this.constraints.reduce((l,p)=>p.constrain(l),r)}}function mn(c,r){if(c instanceof r)return c;if(c instanceof si){const l=c.constraints.reduce((p,w)=>p||(w instanceof r?w:null),null);if(l)return l}return null}class Mr{constructor(r){this.options=r}constrain(r){const l=this.options;return l.length===0||l.filter(w=>w.value===r).length>0?r:l[0].value}}class We{constructor(r){this.maxValue=r.max,this.minValue=r.min}constrain(r){let l=r;return f(this.minValue)||(l=Math.max(l,this.minValue)),f(this.maxValue)||(l=Math.min(l,this.maxValue)),l}}class oi{constructor(r){this.step=r}constrain(r){return(r<0?-Math.round(-r/this.step):Math.round(r/this.step))*this.step}}const Do=_("lst");class pd{constructor(r,l){this.onValueChange_=this.onValueChange_.bind(this),this.props_=l.props,this.element=r.createElement("div"),this.element.classList.add(Do()),l.viewProps.bindClassModifiers(this.element);const p=r.createElement("select");p.classList.add(Do("s")),N(this.props_,"options",I=>{ht(p),I.forEach((O,ct)=>{const Dt=r.createElement("option");Dt.dataset.index=String(ct),Dt.textContent=O.text,Dt.value=String(O.value),p.appendChild(Dt)})}),l.viewProps.bindDisabled(p),this.element.appendChild(p),this.selectElement=p;const w=r.createElement("div");w.classList.add(Do("m")),w.appendChild(E(r,"dropdown")),this.element.appendChild(w),l.value.emitter.on("change",this.onValueChange_),this.value_=l.value,this.update_()}update_(){this.selectElement.value=String(this.value_.rawValue)}onValueChange_(){this.update_()}}class Sr{constructor(r,l){this.onSelectChange_=this.onSelectChange_.bind(this),this.props=l.props,this.value=l.value,this.viewProps=l.viewProps,this.view=new pd(r,{props:this.props,value:this.value,viewProps:this.viewProps}),this.view.selectElement.addEventListener("change",this.onSelectChange_)}onSelectChange_(r){const p=r.currentTarget.selectedOptions.item(0);if(!p)return;const w=Number(p.dataset.index);this.value.rawValue=this.props.get("options")[w].value}}const Ol=_("pop");class fd{constructor(r,l){this.element=r.createElement("div"),this.element.classList.add(Ol()),l.viewProps.bindClassModifiers(this.element),A(l.shows,z(this.element,Ol(void 0,"v")))}}class zl{constructor(r,l){this.shows=j(!1),this.viewProps=l.viewProps,this.view=new fd(r,{shows:this.shows,viewProps:this.viewProps})}}const Ul=_("txt");class md{constructor(r,l){this.onChange_=this.onChange_.bind(this),this.element=r.createElement("div"),this.element.classList.add(Ul()),l.viewProps.bindClassModifiers(this.element),this.props_=l.props,this.props_.emitter.on("change",this.onChange_);const p=r.createElement("input");p.classList.add(Ul("i")),p.type="text",l.viewProps.bindDisabled(p),this.element.appendChild(p),this.inputElement=p,l.value.emitter.on("change",this.onChange_),this.value_=l.value,this.refresh()}refresh(){const r=this.props_.get("formatter");this.inputElement.value=r(this.value_.rawValue)}onChange_(){this.refresh()}}class ds{constructor(r,l){this.onInputChange_=this.onInputChange_.bind(this),this.parser_=l.parser,this.props=l.props,this.value=l.value,this.viewProps=l.viewProps,this.view=new md(r,{props:l.props,value:this.value,viewProps:this.viewProps}),this.view.inputElement.addEventListener("change",this.onInputChange_)}onInputChange_(r){const p=r.currentTarget.value,w=this.parser_(p);f(w)||(this.value.rawValue=w),this.view.refresh()}}function gd(c){return String(c)}function Hl(c){return c==="false"?!1:!!c}function Gl(c){return gd(c)}class vd{constructor(r){this.text=r}evaluate(){return Number(this.text)}toString(){return this.text}}const _d={"**":(c,r)=>Math.pow(c,r),"*":(c,r)=>c*r,"/":(c,r)=>c/r,"%":(c,r)=>c%r,"+":(c,r)=>c+r,"-":(c,r)=>c-r,"<<":(c,r)=>c<<r,">>":(c,r)=>c>>r,">>>":(c,r)=>c>>>r,"&":(c,r)=>c&r,"^":(c,r)=>c^r,"|":(c,r)=>c|r};class xd{constructor(r,l,p){this.left=l,this.operator=r,this.right=p}evaluate(){const r=_d[this.operator];if(!r)throw new Error(`unexpected binary operator: '${this.operator}`);return r(this.left.evaluate(),this.right.evaluate())}toString(){return["b(",this.left.toString(),this.operator,this.right.toString(),")"].join(" ")}}const bd={"+":c=>c,"-":c=>-c,"~":c=>~c};class yd{constructor(r,l){this.operator=r,this.expression=l}evaluate(){const r=bd[this.operator];if(!r)throw new Error(`unexpected unary operator: '${this.operator}`);return r(this.expression.evaluate())}toString(){return["u(",this.operator,this.expression.toString(),")"].join(" ")}}function Io(c){return(r,l)=>{for(let p=0;p<c.length;p++){const w=c[p](r,l);if(w!=="")return w}return""}}function Er(c,r){var l;const p=c.substr(r).match(/^\s+/);return(l=p&&p[0])!==null&&l!==void 0?l:""}function wd(c,r){const l=c.substr(r,1);return l.match(/^[1-9]$/)?l:""}function Tr(c,r){var l;const p=c.substr(r).match(/^[0-9]+/);return(l=p&&p[0])!==null&&l!==void 0?l:""}function Md(c,r){const l=Tr(c,r);if(l!=="")return l;const p=c.substr(r,1);if(r+=1,p!=="-"&&p!=="+")return"";const w=Tr(c,r);return w===""?"":p+w}function No(c,r){const l=c.substr(r,1);if(r+=1,l.toLowerCase()!=="e")return"";const p=Md(c,r);return p===""?"":l+p}function Wl(c,r){const l=c.substr(r,1);if(l==="0")return l;const p=wd(c,r);return r+=p.length,p===""?"":p+Tr(c,r)}function Sd(c,r){const l=Wl(c,r);if(r+=l.length,l==="")return"";const p=c.substr(r,1);if(r+=p.length,p!==".")return"";const w=Tr(c,r);return r+=w.length,l+p+w+No(c,r)}function Ed(c,r){const l=c.substr(r,1);if(r+=l.length,l!==".")return"";const p=Tr(c,r);return r+=p.length,p===""?"":l+p+No(c,r)}function Td(c,r){const l=Wl(c,r);return r+=l.length,l===""?"":l+No(c,r)}const Cd=Io([Sd,Ed,Td]);function Ad(c,r){var l;const p=c.substr(r).match(/^[01]+/);return(l=p&&p[0])!==null&&l!==void 0?l:""}function Pd(c,r){const l=c.substr(r,2);if(r+=l.length,l.toLowerCase()!=="0b")return"";const p=Ad(c,r);return p===""?"":l+p}function Ld(c,r){var l;const p=c.substr(r).match(/^[0-7]+/);return(l=p&&p[0])!==null&&l!==void 0?l:""}function Rd(c,r){const l=c.substr(r,2);if(r+=l.length,l.toLowerCase()!=="0o")return"";const p=Ld(c,r);return p===""?"":l+p}function Dd(c,r){var l;const p=c.substr(r).match(/^[0-9a-f]+/i);return(l=p&&p[0])!==null&&l!==void 0?l:""}function Id(c,r){const l=c.substr(r,2);if(r+=l.length,l.toLowerCase()!=="0x")return"";const p=Dd(c,r);return p===""?"":l+p}const Nd=Io([Pd,Rd,Id]),Fd=Io([Nd,Cd]);function kd(c,r){const l=Fd(c,r);return r+=l.length,l===""?null:{evaluable:new vd(l),cursor:r}}function Bd(c,r){const l=c.substr(r,1);if(r+=l.length,l!=="(")return null;const p=jl(c,r);if(!p)return null;r=p.cursor,r+=Er(c,r).length;const w=c.substr(r,1);return r+=w.length,w!==")"?null:{evaluable:p.evaluable,cursor:r}}function Vd(c,r){return kd(c,r)||Bd(c,r)}function ql(c,r){const l=Vd(c,r);if(l)return l;const p=c.substr(r,1);if(r+=p.length,p!=="+"&&p!=="-"&&p!=="~")return null;const w=ql(c,r);return w?(r=w.cursor,{cursor:r,evaluable:new yd(p,w.evaluable)}):null}function Od(c,r,l){l+=Er(r,l).length;const p=c.filter(w=>r.startsWith(w,l))[0];return p?(l+=p.length,l+=Er(r,l).length,{cursor:l,operator:p}):null}function zd(c,r){return(l,p)=>{const w=c(l,p);if(!w)return null;p=w.cursor;let I=w.evaluable;for(;;){const O=Od(r,l,p);if(!O)break;p=O.cursor;const ct=c(l,p);if(!ct)return null;p=ct.cursor,I=new xd(O.operator,I,ct.evaluable)}return I?{cursor:p,evaluable:I}:null}}const Ud=[["**"],["*","/","%"],["+","-"],["<<",">>>",">>"],["&"],["^"],["|"]].reduce((c,r)=>zd(c,r),ql);function jl(c,r){return r+=Er(c,r).length,Ud(c,r)}function Hd(c){const r=jl(c,0);return!r||r.cursor+Er(c,r.cursor).length!==c.length?null:r.evaluable}function En(c){var r;const l=Hd(c);return(r=l==null?void 0:l.evaluate())!==null&&r!==void 0?r:null}function Xl(c){if(typeof c=="number")return c;if(typeof c=="string"){const r=En(c);if(!f(r))return r}return 0}function Gd(c){return String(c)}function Oe(c){return r=>r.toFixed(Math.max(Math.min(c,20),0))}const Wd=Oe(0);function ps(c){return Wd(c)+"%"}function Yl(c){return String(c)}function Fo(c){return c}function Zl(c,r){for(;c.length<r;)c.push(void 0)}function qd(c){const r=[];return Zl(r,c),j(r)}function jd(c){const r=c.indexOf(void 0);return r<0?c:c.slice(0,r)}function Xd(c,r){const l=[...jd(c),r];return l.length>c.length?l.splice(0,l.length-c.length):Zl(l,c.length),l}function Cr({primary:c,secondary:r,forward:l,backward:p}){let w=!1;function I(O){w||(w=!0,O(),w=!1)}c.emitter.on("change",O=>{I(()=>{r.setRawValue(l(c,r),O.options)})}),r.emitter.on("change",O=>{I(()=>{c.setRawValue(p(c,r),O.options)}),I(()=>{r.setRawValue(l(c,r),O.options)})}),I(()=>{r.setRawValue(l(c,r),{forceEmit:!1,last:!0})})}function ze(c,r){const l=c*(r.altKey?.1:1)*(r.shiftKey?10:1);return r.upKey?+l:r.downKey?-l:0}function Ar(c){return{altKey:c.altKey,downKey:c.key==="ArrowDown",shiftKey:c.shiftKey,upKey:c.key==="ArrowUp"}}function Tn(c){return{altKey:c.altKey,downKey:c.key==="ArrowLeft",shiftKey:c.shiftKey,upKey:c.key==="ArrowRight"}}function Yd(c){return c==="ArrowUp"||c==="ArrowDown"}function Kl(c){return Yd(c)||c==="ArrowLeft"||c==="ArrowRight"}function ko(c,r){const l=r.ownerDocument.defaultView,p=r.getBoundingClientRect();return{x:c.pageX-((l&&l.scrollX||0)+p.left),y:c.pageY-((l&&l.scrollY||0)+p.top)}}class ai{constructor(r){this.lastTouch_=null,this.onDocumentMouseMove_=this.onDocumentMouseMove_.bind(this),this.onDocumentMouseUp_=this.onDocumentMouseUp_.bind(this),this.onMouseDown_=this.onMouseDown_.bind(this),this.onTouchEnd_=this.onTouchEnd_.bind(this),this.onTouchMove_=this.onTouchMove_.bind(this),this.onTouchStart_=this.onTouchStart_.bind(this),this.elem_=r,this.emitter=new M,r.addEventListener("touchstart",this.onTouchStart_),r.addEventListener("touchmove",this.onTouchMove_),r.addEventListener("touchend",this.onTouchEnd_),r.addEventListener("mousedown",this.onMouseDown_)}computePosition_(r){const l=this.elem_.getBoundingClientRect();return{bounds:{width:l.width,height:l.height},point:r?{x:r.x,y:r.y}:null}}onMouseDown_(r){var l;r.preventDefault(),(l=r.currentTarget)===null||l===void 0||l.focus();const p=this.elem_.ownerDocument;p.addEventListener("mousemove",this.onDocumentMouseMove_),p.addEventListener("mouseup",this.onDocumentMouseUp_),this.emitter.emit("down",{altKey:r.altKey,data:this.computePosition_(ko(r,this.elem_)),sender:this,shiftKey:r.shiftKey})}onDocumentMouseMove_(r){this.emitter.emit("move",{altKey:r.altKey,data:this.computePosition_(ko(r,this.elem_)),sender:this,shiftKey:r.shiftKey})}onDocumentMouseUp_(r){const l=this.elem_.ownerDocument;l.removeEventListener("mousemove",this.onDocumentMouseMove_),l.removeEventListener("mouseup",this.onDocumentMouseUp_),this.emitter.emit("up",{altKey:r.altKey,data:this.computePosition_(ko(r,this.elem_)),sender:this,shiftKey:r.shiftKey})}onTouchStart_(r){r.preventDefault();const l=r.targetTouches.item(0),p=this.elem_.getBoundingClientRect();this.emitter.emit("down",{altKey:r.altKey,data:this.computePosition_(l?{x:l.clientX-p.left,y:l.clientY-p.top}:void 0),sender:this,shiftKey:r.shiftKey}),this.lastTouch_=l}onTouchMove_(r){const l=r.targetTouches.item(0),p=this.elem_.getBoundingClientRect();this.emitter.emit("move",{altKey:r.altKey,data:this.computePosition_(l?{x:l.clientX-p.left,y:l.clientY-p.top}:void 0),sender:this,shiftKey:r.shiftKey}),this.lastTouch_=l}onTouchEnd_(r){var l;const p=(l=r.targetTouches.item(0))!==null&&l!==void 0?l:this.lastTouch_,w=this.elem_.getBoundingClientRect();this.emitter.emit("up",{altKey:r.altKey,data:this.computePosition_(p?{x:p.clientX-w.left,y:p.clientY-w.top}:void 0),sender:this,shiftKey:r.shiftKey})}}function re(c,r,l,p,w){const I=(c-r)/(l-r);return p+I*(w-p)}function Jl(c){return String(c.toFixed(10)).split(".")[1].replace(/0+$/,"").length}function se(c,r,l){return Math.min(Math.max(c,r),l)}function Bo(c,r){return(c%r+r)%r}const $e=_("txt");class Zd{constructor(r,l){this.onChange_=this.onChange_.bind(this),this.props_=l.props,this.props_.emitter.on("change",this.onChange_),this.element=r.createElement("div"),this.element.classList.add($e(),$e(void 0,"num")),l.arrayPosition&&this.element.classList.add($e(void 0,l.arrayPosition)),l.viewProps.bindClassModifiers(this.element);const p=r.createElement("input");p.classList.add($e("i")),p.type="text",l.viewProps.bindDisabled(p),this.element.appendChild(p),this.inputElement=p,this.onDraggingChange_=this.onDraggingChange_.bind(this),this.dragging_=l.dragging,this.dragging_.emitter.on("change",this.onDraggingChange_),this.element.classList.add($e()),this.inputElement.classList.add($e("i"));const w=r.createElement("div");w.classList.add($e("k")),this.element.appendChild(w),this.knobElement=w;const I=r.createElementNS(dt,"svg");I.classList.add($e("g")),this.knobElement.appendChild(I);const O=r.createElementNS(dt,"path");O.classList.add($e("gb")),I.appendChild(O),this.guideBodyElem_=O;const ct=r.createElementNS(dt,"path");ct.classList.add($e("gh")),I.appendChild(ct),this.guideHeadElem_=ct;const Dt=r.createElement("div");Dt.classList.add(_("tt")()),this.knobElement.appendChild(Dt),this.tooltipElem_=Dt,l.value.emitter.on("change",this.onChange_),this.value=l.value,this.refresh()}onDraggingChange_(r){if(r.rawValue===null){this.element.classList.remove($e(void 0,"drg"));return}this.element.classList.add($e(void 0,"drg"));const l=r.rawValue/this.props_.get("draggingScale"),p=l+(l>0?-1:l<0?1:0),w=se(-p,-4,4);this.guideHeadElem_.setAttributeNS(null,"d",[`M ${p+w},0 L${p},4 L${p+w},8`,`M ${l},-1 L${l},9`].join(" ")),this.guideBodyElem_.setAttributeNS(null,"d",`M 0,4 L${l},4`);const I=this.props_.get("formatter");this.tooltipElem_.textContent=I(this.value.rawValue),this.tooltipElem_.style.left=`${l}px`}refresh(){const r=this.props_.get("formatter");this.inputElement.value=r(this.value.rawValue)}onChange_(){this.refresh()}}class Pr{constructor(r,l){this.originRawValue_=0,this.onInputChange_=this.onInputChange_.bind(this),this.onInputKeyDown_=this.onInputKeyDown_.bind(this),this.onInputKeyUp_=this.onInputKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.baseStep_=l.baseStep,this.parser_=l.parser,this.props=l.props,this.value=l.value,this.viewProps=l.viewProps,this.dragging_=j(null),this.view=new Zd(r,{arrayPosition:l.arrayPosition,dragging:this.dragging_,props:this.props,value:this.value,viewProps:this.viewProps}),this.view.inputElement.addEventListener("change",this.onInputChange_),this.view.inputElement.addEventListener("keydown",this.onInputKeyDown_),this.view.inputElement.addEventListener("keyup",this.onInputKeyUp_);const p=new ai(this.view.knobElement);p.emitter.on("down",this.onPointerDown_),p.emitter.on("move",this.onPointerMove_),p.emitter.on("up",this.onPointerUp_)}onInputChange_(r){const p=r.currentTarget.value,w=this.parser_(p);f(w)||(this.value.rawValue=w),this.view.refresh()}onInputKeyDown_(r){const l=ze(this.baseStep_,Ar(r));l!==0&&this.value.setRawValue(this.value.rawValue+l,{forceEmit:!1,last:!1})}onInputKeyUp_(r){ze(this.baseStep_,Ar(r))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}onPointerDown_(){this.originRawValue_=this.value.rawValue,this.dragging_.rawValue=0}computeDraggingValue_(r){if(!r.point)return null;const l=r.point.x-r.bounds.width/2;return this.originRawValue_+l*this.props.get("draggingScale")}onPointerMove_(r){const l=this.computeDraggingValue_(r.data);l!==null&&(this.value.setRawValue(l,{forceEmit:!1,last:!1}),this.dragging_.rawValue=this.value.rawValue-this.originRawValue_)}onPointerUp_(r){const l=this.computeDraggingValue_(r.data);l!==null&&(this.value.setRawValue(l,{forceEmit:!0,last:!0}),this.dragging_.rawValue=null)}}const Vo=_("sld");class Kd{constructor(r,l){this.onChange_=this.onChange_.bind(this),this.props_=l.props,this.props_.emitter.on("change",this.onChange_),this.element=r.createElement("div"),this.element.classList.add(Vo()),l.viewProps.bindClassModifiers(this.element);const p=r.createElement("div");p.classList.add(Vo("t")),l.viewProps.bindTabIndex(p),this.element.appendChild(p),this.trackElement=p;const w=r.createElement("div");w.classList.add(Vo("k")),this.trackElement.appendChild(w),this.knobElement=w,l.value.emitter.on("change",this.onChange_),this.value=l.value,this.update_()}update_(){const r=se(re(this.value.rawValue,this.props_.get("minValue"),this.props_.get("maxValue"),0,100),0,100);this.knobElement.style.width=`${r}%`}onChange_(){this.update_()}}class Jd{constructor(r,l){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDownOrMove_=this.onPointerDownOrMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.baseStep_=l.baseStep,this.value=l.value,this.viewProps=l.viewProps,this.props=l.props,this.view=new Kd(r,{props:this.props,value:this.value,viewProps:this.viewProps}),this.ptHandler_=new ai(this.view.trackElement),this.ptHandler_.emitter.on("down",this.onPointerDownOrMove_),this.ptHandler_.emitter.on("move",this.onPointerDownOrMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.trackElement.addEventListener("keydown",this.onKeyDown_),this.view.trackElement.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(r,l){!r.point||this.value.setRawValue(re(se(r.point.x,0,r.bounds.width),0,r.bounds.width,this.props.get("minValue"),this.props.get("maxValue")),l)}onPointerDownOrMove_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerUp_(r){this.handlePointerEvent_(r.data,{forceEmit:!0,last:!0})}onKeyDown_(r){const l=ze(this.baseStep_,Tn(r));l!==0&&this.value.setRawValue(this.value.rawValue+l,{forceEmit:!1,last:!1})}onKeyUp_(r){ze(this.baseStep_,Tn(r))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}const Oo=_("sldtxt");class $d{constructor(r,l){this.element=r.createElement("div"),this.element.classList.add(Oo());const p=r.createElement("div");p.classList.add(Oo("s")),this.sliderView_=l.sliderView,p.appendChild(this.sliderView_.element),this.element.appendChild(p);const w=r.createElement("div");w.classList.add(Oo("t")),this.textView_=l.textView,w.appendChild(this.textView_.element),this.element.appendChild(w)}}class zo{constructor(r,l){this.value=l.value,this.viewProps=l.viewProps,this.sliderC_=new Jd(r,{baseStep:l.baseStep,props:l.sliderProps,value:l.value,viewProps:this.viewProps}),this.textC_=new Pr(r,{baseStep:l.baseStep,parser:l.parser,props:l.textProps,value:l.value,viewProps:l.viewProps}),this.view=new $d(r,{sliderView:this.sliderC_.view,textView:this.textC_.view})}get sliderController(){return this.sliderC_}get textController(){return this.textC_}}function Lr(c,r){c.write(r)}function fs(c){const r=vt;if(Array.isArray(c))return r.required.array(r.required.object({text:r.required.string,value:r.required.raw}))(c).value;if(typeof c=="object")return r.required.raw(c).value}function $l(c){if(c==="inline"||c==="popup")return c}function Dn(c){const r=vt;return r.required.object({max:r.optional.number,min:r.optional.number,step:r.optional.number})(c).value}function Ql(c){if(Array.isArray(c))return c;const r=[];return Object.keys(c).forEach(l=>{r.push({text:l,value:c[l]})}),r}function Uo(c){return f(c)?null:new Mr(Ql(c))}function Ho(c){const r=c?mn(c,Mr):null;return r?r.options:null}function Qd(c){const r=c?mn(c,oi):null;return r?r.step:null}function ms(c,r){const l=c&&mn(c,oi);return l?Jl(l.step):Math.max(Jl(r),2)}function Mi(c){const r=Qd(c);return r!=null?r:1}function Si(c,r){var l;const p=c&&mn(c,oi),w=Math.abs((l=p==null?void 0:p.step)!==null&&l!==void 0?l:r);return w===0?.1:Math.pow(10,Math.floor(Math.log10(w))-1)}const gs=_("ckb");class tp{constructor(r,l){this.onValueChange_=this.onValueChange_.bind(this),this.element=r.createElement("div"),this.element.classList.add(gs()),l.viewProps.bindClassModifiers(this.element);const p=r.createElement("label");p.classList.add(gs("l")),this.element.appendChild(p);const w=r.createElement("input");w.classList.add(gs("i")),w.type="checkbox",p.appendChild(w),this.inputElement=w,l.viewProps.bindDisabled(this.inputElement);const I=r.createElement("div");I.classList.add(gs("w")),p.appendChild(I);const O=E(r,"check");I.appendChild(O),l.value.emitter.on("change",this.onValueChange_),this.value=l.value,this.update_()}update_(){this.inputElement.checked=this.value.rawValue}onValueChange_(){this.update_()}}class ep{constructor(r,l){this.onInputChange_=this.onInputChange_.bind(this),this.value=l.value,this.viewProps=l.viewProps,this.view=new tp(r,{value:this.value,viewProps:this.viewProps}),this.view.inputElement.addEventListener("change",this.onInputChange_)}onInputChange_(r){const l=r.currentTarget;this.value.rawValue=l.checked}}function np(c){const r=[],l=Uo(c.options);return l&&r.push(l),new si(r)}const ip={id:"input-bool",type:"input",accept:(c,r)=>{if(typeof c!="boolean")return null;const p=J(r,{options:vt.optional.custom(fs)});return p?{initialValue:c,params:p}:null},binding:{reader:c=>Hl,constraint:c=>np(c.params),writer:c=>Lr},controller:c=>{var r;const l=c.document,p=c.value,w=c.constraint;return w&&mn(w,Mr)?new Sr(l,{props:B.fromObject({options:(r=Ho(w))!==null&&r!==void 0?r:[]}),value:p,viewProps:c.viewProps}):new ep(l,{value:p,viewProps:c.viewProps})}},li=_("col");class rp{constructor(r,l){this.element=r.createElement("div"),this.element.classList.add(li()),l.foldable.bindExpandedClass(this.element,li(void 0,"expanded")),N(l.foldable,"completed",z(this.element,li(void 0,"cpl")));const p=r.createElement("div");p.classList.add(li("h")),this.element.appendChild(p);const w=r.createElement("div");w.classList.add(li("s")),p.appendChild(w),this.swatchElement=w;const I=r.createElement("div");if(I.classList.add(li("t")),p.appendChild(I),this.textElement=I,l.pickerLayout==="inline"){const O=r.createElement("div");O.classList.add(li("p")),this.element.appendChild(O),this.pickerElement=O}else this.pickerElement=null}}function sp(c,r,l){const p=se(c/255,0,1),w=se(r/255,0,1),I=se(l/255,0,1),O=Math.max(p,w,I),ct=Math.min(p,w,I),Dt=O-ct;let Bt=0,Xt=0;const Yt=(ct+O)/2;return Dt!==0&&(Xt=Dt/(1-Math.abs(O+ct-1)),p===O?Bt=(w-I)/Dt:w===O?Bt=2+(I-p)/Dt:Bt=4+(p-w)/Dt,Bt=Bt/6+(Bt<0?1:0)),[Bt*360,Xt*100,Yt*100]}function op(c,r,l){const p=(c%360+360)%360,w=se(r/100,0,1),I=se(l/100,0,1),O=(1-Math.abs(2*I-1))*w,ct=O*(1-Math.abs(p/60%2-1)),Dt=I-O/2;let Bt,Xt,Yt;return p>=0&&p<60?[Bt,Xt,Yt]=[O,ct,0]:p>=60&&p<120?[Bt,Xt,Yt]=[ct,O,0]:p>=120&&p<180?[Bt,Xt,Yt]=[0,O,ct]:p>=180&&p<240?[Bt,Xt,Yt]=[0,ct,O]:p>=240&&p<300?[Bt,Xt,Yt]=[ct,0,O]:[Bt,Xt,Yt]=[O,0,ct],[(Bt+Dt)*255,(Xt+Dt)*255,(Yt+Dt)*255]}function ap(c,r,l){const p=se(c/255,0,1),w=se(r/255,0,1),I=se(l/255,0,1),O=Math.max(p,w,I),ct=Math.min(p,w,I),Dt=O-ct;let Bt;Dt===0?Bt=0:O===p?Bt=60*(((w-I)/Dt%6+6)%6):O===w?Bt=60*((I-p)/Dt+2):Bt=60*((p-w)/Dt+4);const Xt=O===0?0:Dt/O,Yt=O;return[Bt,Xt*100,Yt*100]}function tc(c,r,l){const p=Bo(c,360),w=se(r/100,0,1),I=se(l/100,0,1),O=I*w,ct=O*(1-Math.abs(p/60%2-1)),Dt=I-O;let Bt,Xt,Yt;return p>=0&&p<60?[Bt,Xt,Yt]=[O,ct,0]:p>=60&&p<120?[Bt,Xt,Yt]=[ct,O,0]:p>=120&&p<180?[Bt,Xt,Yt]=[0,O,ct]:p>=180&&p<240?[Bt,Xt,Yt]=[0,ct,O]:p>=240&&p<300?[Bt,Xt,Yt]=[ct,0,O]:[Bt,Xt,Yt]=[O,0,ct],[(Bt+Dt)*255,(Xt+Dt)*255,(Yt+Dt)*255]}function lp(c,r,l){const p=l+r*(100-Math.abs(2*l-100))/200;return[c,p!==0?r*(100-Math.abs(2*l-100))/p:0,l+r*(100-Math.abs(2*l-100))/(2*100)]}function cp(c,r,l){const p=100-Math.abs(l*(200-r)/100-100);return[c,p!==0?r*l/p:0,l*(200-r)/(2*100)]}function Ei(c){return[c[0],c[1],c[2]]}function ec(c,r){return[c[0],c[1],c[2],r]}const hp={hsl:{hsl:(c,r,l)=>[c,r,l],hsv:lp,rgb:op},hsv:{hsl:cp,hsv:(c,r,l)=>[c,r,l],rgb:tc},rgb:{hsl:sp,hsv:ap,rgb:(c,r,l)=>[c,r,l]}};function up(c,r,l){return hp[r][l](...c)}const dp={hsl:c=>{var r;return[Bo(c[0],360),se(c[1],0,100),se(c[2],0,100),se((r=c[3])!==null&&r!==void 0?r:1,0,1)]},hsv:c=>{var r;return[Bo(c[0],360),se(c[1],0,100),se(c[2],0,100),se((r=c[3])!==null&&r!==void 0?r:1,0,1)]},rgb:c=>{var r;return[se(c[0],0,255),se(c[1],0,255),se(c[2],0,255),se((r=c[3])!==null&&r!==void 0?r:1,0,1)]}};function vs(c,r){return typeof c!="object"||f(c)?!1:r in c&&typeof c[r]=="number"}class qt{constructor(r,l){this.mode_=l,this.comps_=dp[l](r)}static black(){return new qt([0,0,0],"rgb")}static fromObject(r){const l="a"in r?[r.r,r.g,r.b,r.a]:[r.r,r.g,r.b];return new qt(l,"rgb")}static toRgbaObject(r){return r.toRgbaObject()}static isRgbColorObject(r){return vs(r,"r")&&vs(r,"g")&&vs(r,"b")}static isRgbaColorObject(r){return this.isRgbColorObject(r)&&vs(r,"a")}static isColorObject(r){return this.isRgbColorObject(r)}static equals(r,l){if(r.mode_!==l.mode_)return!1;const p=r.comps_,w=l.comps_;for(let I=0;I<p.length;I++)if(p[I]!==w[I])return!1;return!0}get mode(){return this.mode_}getComponents(r){return ec(up(Ei(this.comps_),this.mode_,r||this.mode_),this.comps_[3])}toRgbaObject(){const r=this.getComponents("rgb");return{r:r[0],g:r[1],b:r[2],a:r[3]}}}const In=_("colp");class pp{constructor(r,l){this.alphaViews_=null,this.element=r.createElement("div"),this.element.classList.add(In());const p=r.createElement("div");p.classList.add(In("hsv"));const w=r.createElement("div");w.classList.add(In("sv")),this.svPaletteView_=l.svPaletteView,w.appendChild(this.svPaletteView_.element),p.appendChild(w);const I=r.createElement("div");I.classList.add(In("h")),this.hPaletteView_=l.hPaletteView,I.appendChild(this.hPaletteView_.element),p.appendChild(I),this.element.appendChild(p);const O=r.createElement("div");if(O.classList.add(In("rgb")),this.textView_=l.textView,O.appendChild(this.textView_.element),this.element.appendChild(O),l.alphaViews){this.alphaViews_={palette:l.alphaViews.palette,text:l.alphaViews.text};const ct=r.createElement("div");ct.classList.add(In("a"));const Dt=r.createElement("div");Dt.classList.add(In("ap")),Dt.appendChild(this.alphaViews_.palette.element),ct.appendChild(Dt);const Bt=r.createElement("div");Bt.classList.add(In("at")),Bt.appendChild(this.alphaViews_.text.element),ct.appendChild(Bt),this.element.appendChild(ct)}}get allFocusableElements(){const r=[this.svPaletteView_.element,this.hPaletteView_.element,this.textView_.modeSelectElement,...this.textView_.textViews.map(l=>l.inputElement)];return this.alphaViews_&&r.push(this.alphaViews_.palette.element,this.alphaViews_.text.inputElement),r}}function Go(c){const r=vt;return J(c,{alpha:r.optional.boolean,expanded:r.optional.boolean,picker:r.optional.custom($l)})}function ci(c){return c?.1:1}function Qe(c,r){const l=c.match(/^(.+)%$/);return Math.min(l?parseFloat(l[1])*.01*r:parseFloat(c),r)}const fp={deg:c=>c,grad:c=>c*360/400,rad:c=>c*360/(2*Math.PI),turn:c=>c*360};function nc(c){const r=c.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);if(!r)return parseFloat(c);const l=parseFloat(r[1]),p=r[2];return fp[p](l)}const Wo={"func.rgb":c=>{const r=c.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!r)return null;const l=[Qe(r[1],255),Qe(r[2],255),Qe(r[3],255)];return isNaN(l[0])||isNaN(l[1])||isNaN(l[2])?null:new qt(l,"rgb")},"func.rgba":c=>{const r=c.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!r)return null;const l=[Qe(r[1],255),Qe(r[2],255),Qe(r[3],255),Qe(r[4],1)];return isNaN(l[0])||isNaN(l[1])||isNaN(l[2])||isNaN(l[3])?null:new qt(l,"rgb")},"func.hsl":c=>{const r=c.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!r)return null;const l=[nc(r[1]),Qe(r[2],100),Qe(r[3],100)];return isNaN(l[0])||isNaN(l[1])||isNaN(l[2])?null:new qt(l,"hsl")},"func.hsla":c=>{const r=c.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!r)return null;const l=[nc(r[1]),Qe(r[2],100),Qe(r[3],100),Qe(r[4],1)];return isNaN(l[0])||isNaN(l[1])||isNaN(l[2])||isNaN(l[3])?null:new qt(l,"hsl")},"hex.rgb":c=>{const r=c.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);if(r)return new qt([parseInt(r[1]+r[1],16),parseInt(r[2]+r[2],16),parseInt(r[3]+r[3],16)],"rgb");const l=c.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);return l?new qt([parseInt(l[1],16),parseInt(l[2],16),parseInt(l[3],16)],"rgb"):null},"hex.rgba":c=>{const r=c.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);if(r)return new qt([parseInt(r[1]+r[1],16),parseInt(r[2]+r[2],16),parseInt(r[3]+r[3],16),re(parseInt(r[4]+r[4],16),0,255,0,1)],"rgb");const l=c.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);return l?new qt([parseInt(l[1],16),parseInt(l[2],16),parseInt(l[3],16),re(parseInt(l[4],16),0,255,0,1)],"rgb"):null}};function _s(c){return Object.keys(Wo).reduce((l,p)=>{if(l)return l;const w=Wo[p];return w(c)?p:null},null)}const xs=c=>{const r=_s(c);return r?Wo[r](c):null};function mp(c){return c==="func.hsla"||c==="func.rgba"||c==="hex.rgba"}function gp(c){if(typeof c=="string"){const r=xs(c);if(r)return r}return qt.black()}function ic(c){const r=se(Math.floor(c),0,255).toString(16);return r.length===1?`0${r}`:r}function qo(c,r="#"){const l=Ei(c.getComponents("rgb")).map(ic).join("");return`${r}${l}`}function bs(c,r="#"){const l=c.getComponents("rgb"),p=[l[0],l[1],l[2],l[3]*255].map(ic).join("");return`${r}${p}`}function rc(c){const r=Oe(0);return`rgb(${Ei(c.getComponents("rgb")).map(p=>r(p)).join(", ")})`}function ys(c){const r=Oe(2),l=Oe(0);return`rgba(${c.getComponents("rgb").map((w,I)=>(I===3?r:l)(w)).join(", ")})`}function vp(c){const r=[Oe(0),ps,ps];return`hsl(${Ei(c.getComponents("hsl")).map((p,w)=>r[w](p)).join(", ")})`}function _p(c){const r=[Oe(0),ps,ps,Oe(2)];return`hsla(${c.getComponents("hsl").map((p,w)=>r[w](p)).join(", ")})`}const xp={"func.hsl":vp,"func.hsla":_p,"func.rgb":rc,"func.rgba":ys,"hex.rgb":qo,"hex.rgba":bs};function sc(c){return xp[c]}const Rr=_("apl");class bp{constructor(r,l){this.onValueChange_=this.onValueChange_.bind(this),this.value=l.value,this.value.emitter.on("change",this.onValueChange_),this.element=r.createElement("div"),this.element.classList.add(Rr()),l.viewProps.bindTabIndex(this.element);const p=r.createElement("div");p.classList.add(Rr("b")),this.element.appendChild(p);const w=r.createElement("div");w.classList.add(Rr("c")),p.appendChild(w),this.colorElem_=w;const I=r.createElement("div");I.classList.add(Rr("m")),this.element.appendChild(I),this.markerElem_=I;const O=r.createElement("div");O.classList.add(Rr("p")),this.markerElem_.appendChild(O),this.previewElem_=O,this.update_()}update_(){const r=this.value.rawValue,l=r.getComponents("rgb"),p=new qt([l[0],l[1],l[2],0],"rgb"),w=new qt([l[0],l[1],l[2],255],"rgb"),I=["to right",ys(p),ys(w)];this.colorElem_.style.background=`linear-gradient(${I.join(",")})`,this.previewElem_.style.backgroundColor=ys(r);const O=re(l[3],0,1,0,100);this.markerElem_.style.left=`${O}%`}onValueChange_(){this.update_()}}class yp{constructor(r,l){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=l.value,this.viewProps=l.viewProps,this.view=new bp(r,{value:this.value,viewProps:this.viewProps}),this.ptHandler_=new ai(this.view.element),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.element.addEventListener("keydown",this.onKeyDown_),this.view.element.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(r,l){if(!r.point)return;const p=r.point.x/r.bounds.width,w=this.value.rawValue,[I,O,ct]=w.getComponents("hsv");this.value.setRawValue(new qt([I,O,ct,p],"hsv"),l)}onPointerDown_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerMove_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerUp_(r){this.handlePointerEvent_(r.data,{forceEmit:!0,last:!0})}onKeyDown_(r){const l=ze(ci(!0),Tn(r));if(l===0)return;const p=this.value.rawValue,[w,I,O,ct]=p.getComponents("hsv");this.value.setRawValue(new qt([w,I,O,ct+l],"hsv"),{forceEmit:!1,last:!1})}onKeyUp_(r){ze(ci(!0),Tn(r))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}const Ti=_("coltxt");function wp(c){const r=c.createElement("select"),l=[{text:"RGB",value:"rgb"},{text:"HSL",value:"hsl"},{text:"HSV",value:"hsv"}];return r.appendChild(l.reduce((p,w)=>{const I=c.createElement("option");return I.textContent=w.text,I.value=w.value,p.appendChild(I),p},c.createDocumentFragment())),r}class Mp{constructor(r,l){this.element=r.createElement("div"),this.element.classList.add(Ti());const p=r.createElement("div");p.classList.add(Ti("m")),this.modeElem_=wp(r),this.modeElem_.classList.add(Ti("ms")),p.appendChild(this.modeSelectElement);const w=r.createElement("div");w.classList.add(Ti("mm")),w.appendChild(E(r,"dropdown")),p.appendChild(w),this.element.appendChild(p);const I=r.createElement("div");I.classList.add(Ti("w")),this.element.appendChild(I),this.textsElem_=I,this.textViews_=l.textViews,this.applyTextViews_(),A(l.colorMode,O=>{this.modeElem_.value=O})}get modeSelectElement(){return this.modeElem_}get textViews(){return this.textViews_}set textViews(r){this.textViews_=r,this.applyTextViews_()}applyTextViews_(){ht(this.textsElem_);const r=this.element.ownerDocument;this.textViews_.forEach(l=>{const p=r.createElement("div");p.classList.add(Ti("c")),p.appendChild(l.element),this.textsElem_.appendChild(p)})}}const Sp=Oe(0),Ep={rgb:()=>new We({min:0,max:255}),hsl:c=>c===0?new We({min:0,max:360}):new We({min:0,max:100}),hsv:c=>c===0?new We({min:0,max:360}):new We({min:0,max:100})};function jo(c,r,l){return new Pr(c,{arrayPosition:l===0?"fst":l===3-1?"lst":"mid",baseStep:ci(!1),parser:r.parser,props:B.fromObject({draggingScale:1,formatter:Sp}),value:j(0,{constraint:Ep[r.colorMode](l)}),viewProps:r.viewProps})}class Tp{constructor(r,l){this.onModeSelectChange_=this.onModeSelectChange_.bind(this),this.parser_=l.parser,this.value=l.value,this.viewProps=l.viewProps,this.colorMode=j(this.value.rawValue.mode),this.ccs_=this.createComponentControllers_(r),this.view=new Mp(r,{colorMode:this.colorMode,textViews:[this.ccs_[0].view,this.ccs_[1].view,this.ccs_[2].view]}),this.view.modeSelectElement.addEventListener("change",this.onModeSelectChange_)}createComponentControllers_(r){const l={colorMode:this.colorMode.rawValue,parser:this.parser_,viewProps:this.viewProps},p=[jo(r,l,0),jo(r,l,1),jo(r,l,2)];return p.forEach((w,I)=>{Cr({primary:this.value,secondary:w.value,forward:O=>O.rawValue.getComponents(this.colorMode.rawValue)[I],backward:(O,ct)=>{const Dt=this.colorMode.rawValue,Bt=O.rawValue.getComponents(Dt);return Bt[I]=ct.rawValue,new qt(ec(Ei(Bt),Bt[3]),Dt)}})}),p}onModeSelectChange_(r){const l=r.currentTarget;this.colorMode.rawValue=l.value,this.ccs_=this.createComponentControllers_(this.view.element.ownerDocument),this.view.textViews=[this.ccs_[0].view,this.ccs_[1].view,this.ccs_[2].view]}}const Xo=_("hpl");class Cp{constructor(r,l){this.onValueChange_=this.onValueChange_.bind(this),this.value=l.value,this.value.emitter.on("change",this.onValueChange_),this.element=r.createElement("div"),this.element.classList.add(Xo()),l.viewProps.bindTabIndex(this.element);const p=r.createElement("div");p.classList.add(Xo("c")),this.element.appendChild(p);const w=r.createElement("div");w.classList.add(Xo("m")),this.element.appendChild(w),this.markerElem_=w,this.update_()}update_(){const r=this.value.rawValue,[l]=r.getComponents("hsv");this.markerElem_.style.backgroundColor=rc(new qt([l,100,100],"hsv"));const p=re(l,0,360,0,100);this.markerElem_.style.left=`${p}%`}onValueChange_(){this.update_()}}class Ap{constructor(r,l){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=l.value,this.viewProps=l.viewProps,this.view=new Cp(r,{value:this.value,viewProps:this.viewProps}),this.ptHandler_=new ai(this.view.element),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.element.addEventListener("keydown",this.onKeyDown_),this.view.element.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(r,l){if(!r.point)return;const p=re(r.point.x,0,r.bounds.width,0,360),w=this.value.rawValue,[,I,O,ct]=w.getComponents("hsv");this.value.setRawValue(new qt([p,I,O,ct],"hsv"),l)}onPointerDown_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerMove_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerUp_(r){this.handlePointerEvent_(r.data,{forceEmit:!0,last:!0})}onKeyDown_(r){const l=ze(ci(!1),Tn(r));if(l===0)return;const p=this.value.rawValue,[w,I,O,ct]=p.getComponents("hsv");this.value.setRawValue(new qt([w+l,I,O,ct],"hsv"),{forceEmit:!1,last:!1})}onKeyUp_(r){ze(ci(!1),Tn(r))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}const Yo=_("svp"),oc=64;class Pp{constructor(r,l){this.onValueChange_=this.onValueChange_.bind(this),this.value=l.value,this.value.emitter.on("change",this.onValueChange_),this.element=r.createElement("div"),this.element.classList.add(Yo()),l.viewProps.bindTabIndex(this.element);const p=r.createElement("canvas");p.height=oc,p.width=oc,p.classList.add(Yo("c")),this.element.appendChild(p),this.canvasElement=p;const w=r.createElement("div");w.classList.add(Yo("m")),this.element.appendChild(w),this.markerElem_=w,this.update_()}update_(){const r=ut(this.canvasElement);if(!r)return;const p=this.value.rawValue.getComponents("hsv"),w=this.canvasElement.width,I=this.canvasElement.height,O=r.getImageData(0,0,w,I),ct=O.data;for(let Xt=0;Xt<I;Xt++)for(let Yt=0;Yt<w;Yt++){const hi=re(Yt,0,w,0,100),Ir=re(Xt,0,I,100,0),Nr=tc(p[0],hi,Ir),Li=(Xt*w+Yt)*4;ct[Li]=Nr[0],ct[Li+1]=Nr[1],ct[Li+2]=Nr[2],ct[Li+3]=255}r.putImageData(O,0,0);const Dt=re(p[1],0,100,0,100);this.markerElem_.style.left=`${Dt}%`;const Bt=re(p[2],0,100,100,0);this.markerElem_.style.top=`${Bt}%`}onValueChange_(){this.update_()}}class Lp{constructor(r,l){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=l.value,this.viewProps=l.viewProps,this.view=new Pp(r,{value:this.value,viewProps:this.viewProps}),this.ptHandler_=new ai(this.view.element),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.element.addEventListener("keydown",this.onKeyDown_),this.view.element.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(r,l){if(!r.point)return;const p=re(r.point.x,0,r.bounds.width,0,100),w=re(r.point.y,0,r.bounds.height,100,0),[I,,,O]=this.value.rawValue.getComponents("hsv");this.value.setRawValue(new qt([I,p,w,O],"hsv"),l)}onPointerDown_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerMove_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerUp_(r){this.handlePointerEvent_(r.data,{forceEmit:!0,last:!0})}onKeyDown_(r){Kl(r.key)&&r.preventDefault();const[l,p,w,I]=this.value.rawValue.getComponents("hsv"),O=ci(!1),ct=ze(O,Tn(r)),Dt=ze(O,Ar(r));ct===0&&Dt===0||this.value.setRawValue(new qt([l,p+ct,w+Dt,I],"hsv"),{forceEmit:!1,last:!1})}onKeyUp_(r){const l=ci(!1),p=ze(l,Tn(r)),w=ze(l,Ar(r));p===0&&w===0||this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}class Rp{constructor(r,l){this.value=l.value,this.viewProps=l.viewProps,this.hPaletteC_=new Ap(r,{value:this.value,viewProps:this.viewProps}),this.svPaletteC_=new Lp(r,{value:this.value,viewProps:this.viewProps}),this.alphaIcs_=l.supportsAlpha?{palette:new yp(r,{value:this.value,viewProps:this.viewProps}),text:new Pr(r,{parser:En,baseStep:.1,props:B.fromObject({draggingScale:.01,formatter:Oe(2)}),value:j(0,{constraint:new We({min:0,max:1})}),viewProps:this.viewProps})}:null,this.alphaIcs_&&Cr({primary:this.value,secondary:this.alphaIcs_.text.value,forward:p=>p.rawValue.getComponents()[3],backward:(p,w)=>{const I=p.rawValue.getComponents();return I[3]=w.rawValue,new qt(I,p.rawValue.mode)}}),this.textC_=new Tp(r,{parser:En,value:this.value,viewProps:this.viewProps}),this.view=new pp(r,{alphaViews:this.alphaIcs_?{palette:this.alphaIcs_.palette.view,text:this.alphaIcs_.text.view}:null,hPaletteView:this.hPaletteC_.view,supportsAlpha:l.supportsAlpha,svPaletteView:this.svPaletteC_.view,textView:this.textC_.view})}get textController(){return this.textC_}}const Zo=_("colsw");class Dp{constructor(r,l){this.onValueChange_=this.onValueChange_.bind(this),l.value.emitter.on("change",this.onValueChange_),this.value=l.value,this.element=r.createElement("div"),this.element.classList.add(Zo()),l.viewProps.bindClassModifiers(this.element);const p=r.createElement("div");p.classList.add(Zo("sw")),this.element.appendChild(p),this.swatchElem_=p;const w=r.createElement("button");w.classList.add(Zo("b")),l.viewProps.bindDisabled(w),this.element.appendChild(w),this.buttonElement=w,this.update_()}update_(){const r=this.value.rawValue;this.swatchElem_.style.backgroundColor=bs(r)}onValueChange_(){this.update_()}}class Ip{constructor(r,l){this.value=l.value,this.viewProps=l.viewProps,this.view=new Dp(r,{value:this.value,viewProps:this.viewProps})}}class Ko{constructor(r,l){this.onButtonBlur_=this.onButtonBlur_.bind(this),this.onButtonClick_=this.onButtonClick_.bind(this),this.onPopupChildBlur_=this.onPopupChildBlur_.bind(this),this.onPopupChildKeydown_=this.onPopupChildKeydown_.bind(this),this.value=l.value,this.viewProps=l.viewProps,this.foldable_=D.create(l.expanded),this.swatchC_=new Ip(r,{value:this.value,viewProps:this.viewProps});const p=this.swatchC_.view.buttonElement;p.addEventListener("blur",this.onButtonBlur_),p.addEventListener("click",this.onButtonClick_),this.textC_=new ds(r,{parser:l.parser,props:B.fromObject({formatter:l.formatter}),value:this.value,viewProps:this.viewProps}),this.view=new rp(r,{foldable:this.foldable_,pickerLayout:l.pickerLayout}),this.view.swatchElement.appendChild(this.swatchC_.view.element),this.view.textElement.appendChild(this.textC_.view.element),this.popC_=l.pickerLayout==="popup"?new zl(r,{viewProps:this.viewProps}):null;const w=new Rp(r,{supportsAlpha:l.supportsAlpha,value:this.value,viewProps:this.viewProps});w.view.allFocusableElements.forEach(I=>{I.addEventListener("blur",this.onPopupChildBlur_),I.addEventListener("keydown",this.onPopupChildKeydown_)}),this.pickerC_=w,this.popC_?(this.view.element.appendChild(this.popC_.view.element),this.popC_.view.element.appendChild(w.view.element),Cr({primary:this.foldable_.value("expanded"),secondary:this.popC_.shows,forward:I=>I.rawValue,backward:(I,O)=>O.rawValue})):this.view.pickerElement&&(this.view.pickerElement.appendChild(this.pickerC_.view.element),Ut(this.foldable_,this.view.pickerElement))}get textController(){return this.textC_}onButtonBlur_(r){if(!this.popC_)return;const l=this.view.element,p=r.relatedTarget;(!p||!l.contains(p))&&(this.popC_.shows.rawValue=!1)}onButtonClick_(){this.foldable_.set("expanded",!this.foldable_.get("expanded")),this.foldable_.get("expanded")&&this.pickerC_.view.allFocusableElements[0].focus()}onPopupChildBlur_(r){if(!this.popC_)return;const l=this.popC_.view.element,p=Lt(r);p&&l.contains(p)||p&&p===this.swatchC_.view.buttonElement&&!Z(l.ownerDocument)||(this.popC_.shows.rawValue=!1)}onPopupChildKeydown_(r){this.popC_?r.key==="Escape"&&(this.popC_.shows.rawValue=!1):this.view.pickerElement&&r.key==="Escape"&&this.swatchC_.view.buttonElement.focus()}}function Np(c){return qt.isColorObject(c)?qt.fromObject(c):qt.black()}function Fp(c){return Ei(c.getComponents("rgb")).reduce((r,l)=>r<<8|Math.floor(l)&255,0)}function kp(c){return c.getComponents("rgb").reduce((r,l,p)=>{const w=Math.floor(p===3?l*255:l)&255;return r<<8|w},0)>>>0}function Bp(c){return new qt([c>>16&255,c>>8&255,c&255],"rgb")}function Vp(c){return new qt([c>>24&255,c>>16&255,c>>8&255,re(c&255,0,255,0,1)],"rgb")}function Op(c){return typeof c!="number"?qt.black():Bp(c)}function zp(c){return typeof c!="number"?qt.black():Vp(c)}function Up(c){const r=sc(c);return(l,p)=>{Lr(l,r(p))}}function Hp(c){const r=c?kp:Fp;return(l,p)=>{Lr(l,r(p))}}function Gp(c,r){const l=r.toRgbaObject();c.writeProperty("r",l.r),c.writeProperty("g",l.g),c.writeProperty("b",l.b),c.writeProperty("a",l.a)}function Wp(c,r){const l=r.toRgbaObject();c.writeProperty("r",l.r),c.writeProperty("g",l.g),c.writeProperty("b",l.b)}function qp(c){return c?Gp:Wp}function Jo(c){return"alpha"in c&&c.alpha===!0}function jp(c){return c?r=>bs(r,"0x"):r=>qo(r,"0x")}const Xp={id:"input-color-number",type:"input",accept:(c,r)=>{if(typeof c!="number"||!("view"in r)||r.view!=="color")return null;const l=Go(r);return l?{initialValue:c,params:l}:null},binding:{reader:c=>Jo(c.params)?zp:Op,equals:qt.equals,writer:c=>Hp(Jo(c.params))},controller:c=>{const r=Jo(c.params),l="expanded"in c.params?c.params.expanded:void 0,p="picker"in c.params?c.params.picker:void 0;return new Ko(c.document,{expanded:l!=null?l:!1,formatter:jp(r),parser:xs,pickerLayout:p!=null?p:"popup",supportsAlpha:r,value:c.value,viewProps:c.viewProps})}};function Yp(c){return qt.isRgbaColorObject(c)}const Zp={id:"input-color-object",type:"input",accept:(c,r)=>{if(!qt.isColorObject(c))return null;const l=Go(r);return l?{initialValue:c,params:l}:null},binding:{reader:c=>Np,equals:qt.equals,writer:c=>qp(Yp(c.initialValue))},controller:c=>{const r=qt.isRgbaColorObject(c.initialValue),l="expanded"in c.params?c.params.expanded:void 0,p="picker"in c.params?c.params.picker:void 0,w=r?bs:qo;return new Ko(c.document,{expanded:l!=null?l:!1,formatter:w,parser:xs,pickerLayout:p!=null?p:"popup",supportsAlpha:r,value:c.value,viewProps:c.viewProps})}},Kp={id:"input-color-string",type:"input",accept:(c,r)=>{if(typeof c!="string"||"view"in r&&r.view==="text"||!_s(c))return null;const p=Go(r);return p?{initialValue:c,params:p}:null},binding:{reader:c=>gp,equals:qt.equals,writer:c=>{const r=_s(c.initialValue);if(!r)throw v.shouldNeverHappen();return Up(r)}},controller:c=>{const r=_s(c.initialValue);if(!r)throw v.shouldNeverHappen();const l=sc(r),p="expanded"in c.params?c.params.expanded:void 0,w="picker"in c.params?c.params.picker:void 0;return new Ko(c.document,{expanded:p!=null?p:!1,formatter:l,parser:xs,pickerLayout:w!=null?w:"popup",supportsAlpha:mp(r),value:c.value,viewProps:c.viewProps})}};class Nn{constructor(r){this.components=r.components,this.asm_=r.assembly}constrain(r){const l=this.asm_.toComponents(r).map((p,w)=>{var I,O;return(O=(I=this.components[w])===null||I===void 0?void 0:I.constrain(p))!==null&&O!==void 0?O:p});return this.asm_.fromComponents(l)}}const ac=_("pndtxt");class Jp{constructor(r,l){this.textViews=l.textViews,this.element=r.createElement("div"),this.element.classList.add(ac()),this.textViews.forEach(p=>{const w=r.createElement("div");w.classList.add(ac("a")),w.appendChild(p.element),this.element.appendChild(w)})}}function $p(c,r,l){return new Pr(c,{arrayPosition:l===0?"fst":l===r.axes.length-1?"lst":"mid",baseStep:r.axes[l].baseStep,parser:r.parser,props:r.axes[l].textProps,value:j(0,{constraint:r.axes[l].constraint}),viewProps:r.viewProps})}class $o{constructor(r,l){this.value=l.value,this.viewProps=l.viewProps,this.acs_=l.axes.map((p,w)=>$p(r,l,w)),this.acs_.forEach((p,w)=>{Cr({primary:this.value,secondary:p.value,forward:I=>l.assembly.toComponents(I.rawValue)[w],backward:(I,O)=>{const ct=l.assembly.toComponents(I.rawValue);return ct[w]=O.rawValue,l.assembly.fromComponents(ct)}})}),this.view=new Jp(r,{textViews:this.acs_.map(p=>p.view)})}}function Qp(c){return"step"in c&&!f(c.step)?new oi(c.step):null}function tf(c){return"max"in c&&!f(c.max)||"min"in c&&!f(c.min)?new We({max:c.max,min:c.min}):null}function ef(c){const r=[],l=Qp(c);l&&r.push(l);const p=tf(c);p&&r.push(p);const w=Uo(c.options);return w&&r.push(w),new si(r)}function nf(c){const r=c?mn(c,We):null;return r?[r.minValue,r.maxValue]:[void 0,void 0]}function rf(c){const[r,l]=nf(c);return[r!=null?r:0,l!=null?l:100]}const sf={id:"input-number",type:"input",accept:(c,r)=>{if(typeof c!="number")return null;const l=vt,p=J(r,{format:l.optional.function,max:l.optional.number,min:l.optional.number,options:l.optional.custom(fs),step:l.optional.number});return p?{initialValue:c,params:p}:null},binding:{reader:c=>Xl,constraint:c=>ef(c.params),writer:c=>Lr},controller:c=>{var r,l;const p=c.value,w=c.constraint;if(w&&mn(w,Mr))return new Sr(c.document,{props:B.fromObject({options:(r=Ho(w))!==null&&r!==void 0?r:[]}),value:p,viewProps:c.viewProps});const I=(l="format"in c.params?c.params.format:void 0)!==null&&l!==void 0?l:Oe(ms(w,p.rawValue));if(w&&mn(w,We)){const[O,ct]=rf(w);return new zo(c.document,{baseStep:Mi(w),parser:En,sliderProps:B.fromObject({maxValue:ct,minValue:O}),textProps:B.fromObject({draggingScale:Si(w,p.rawValue),formatter:I}),value:p,viewProps:c.viewProps})}return new Pr(c.document,{baseStep:Mi(w),parser:En,props:B.fromObject({draggingScale:Si(w,p.rawValue),formatter:I}),value:p,viewProps:c.viewProps})}};class Fn{constructor(r=0,l=0){this.x=r,this.y=l}getComponents(){return[this.x,this.y]}static isObject(r){if(f(r))return!1;const l=r.x,p=r.y;return!(typeof l!="number"||typeof p!="number")}static equals(r,l){return r.x===l.x&&r.y===l.y}toObject(){return{x:this.x,y:this.y}}}const lc={toComponents:c=>c.getComponents(),fromComponents:c=>new Fn(...c)},Ci=_("p2d");class of{constructor(r,l){this.element=r.createElement("div"),this.element.classList.add(Ci()),l.viewProps.bindClassModifiers(this.element),A(l.expanded,z(this.element,Ci(void 0,"expanded")));const p=r.createElement("div");p.classList.add(Ci("h")),this.element.appendChild(p);const w=r.createElement("button");w.classList.add(Ci("b")),w.appendChild(E(r,"p2dpad")),l.viewProps.bindDisabled(w),p.appendChild(w),this.buttonElement=w;const I=r.createElement("div");if(I.classList.add(Ci("t")),p.appendChild(I),this.textElement=I,l.pickerLayout==="inline"){const O=r.createElement("div");O.classList.add(Ci("p")),this.element.appendChild(O),this.pickerElement=O}else this.pickerElement=null}}const kn=_("p2dp");class af{constructor(r,l){this.onFoldableChange_=this.onFoldableChange_.bind(this),this.onValueChange_=this.onValueChange_.bind(this),this.invertsY_=l.invertsY,this.maxValue_=l.maxValue,this.element=r.createElement("div"),this.element.classList.add(kn()),l.layout==="popup"&&this.element.classList.add(kn(void 0,"p"));const p=r.createElement("div");p.classList.add(kn("p")),l.viewProps.bindTabIndex(p),this.element.appendChild(p),this.padElement=p;const w=r.createElementNS(dt,"svg");w.classList.add(kn("g")),this.padElement.appendChild(w),this.svgElem_=w;const I=r.createElementNS(dt,"line");I.classList.add(kn("ax")),I.setAttributeNS(null,"x1","0"),I.setAttributeNS(null,"y1","50%"),I.setAttributeNS(null,"x2","100%"),I.setAttributeNS(null,"y2","50%"),this.svgElem_.appendChild(I);const O=r.createElementNS(dt,"line");O.classList.add(kn("ax")),O.setAttributeNS(null,"x1","50%"),O.setAttributeNS(null,"y1","0"),O.setAttributeNS(null,"x2","50%"),O.setAttributeNS(null,"y2","100%"),this.svgElem_.appendChild(O);const ct=r.createElementNS(dt,"line");ct.classList.add(kn("l")),ct.setAttributeNS(null,"x1","50%"),ct.setAttributeNS(null,"y1","50%"),this.svgElem_.appendChild(ct),this.lineElem_=ct;const Dt=r.createElement("div");Dt.classList.add(kn("m")),this.padElement.appendChild(Dt),this.markerElem_=Dt,l.value.emitter.on("change",this.onValueChange_),this.value=l.value,this.update_()}get allFocusableElements(){return[this.padElement]}update_(){const[r,l]=this.value.rawValue.getComponents(),p=this.maxValue_,w=re(r,-p,+p,0,100),I=re(l,-p,+p,0,100),O=this.invertsY_?100-I:I;this.lineElem_.setAttributeNS(null,"x2",`${w}%`),this.lineElem_.setAttributeNS(null,"y2",`${O}%`),this.markerElem_.style.left=`${w}%`,this.markerElem_.style.top=`${O}%`}onValueChange_(){this.update_()}onFoldableChange_(){this.update_()}}function cc(c,r,l){return[ze(r[0],Tn(c)),ze(r[1],Ar(c))*(l?1:-1)]}class lf{constructor(r,l){this.onPadKeyDown_=this.onPadKeyDown_.bind(this),this.onPadKeyUp_=this.onPadKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=l.value,this.viewProps=l.viewProps,this.baseSteps_=l.baseSteps,this.maxValue_=l.maxValue,this.invertsY_=l.invertsY,this.view=new af(r,{invertsY:this.invertsY_,layout:l.layout,maxValue:this.maxValue_,value:this.value,viewProps:this.viewProps}),this.ptHandler_=new ai(this.view.padElement),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.padElement.addEventListener("keydown",this.onPadKeyDown_),this.view.padElement.addEventListener("keyup",this.onPadKeyUp_)}handlePointerEvent_(r,l){if(!r.point)return;const p=this.maxValue_,w=re(r.point.x,0,r.bounds.width,-p,+p),I=re(this.invertsY_?r.bounds.height-r.point.y:r.point.y,0,r.bounds.height,-p,+p);this.value.setRawValue(new Fn(w,I),l)}onPointerDown_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerMove_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerUp_(r){this.handlePointerEvent_(r.data,{forceEmit:!0,last:!0})}onPadKeyDown_(r){Kl(r.key)&&r.preventDefault();const[l,p]=cc(r,this.baseSteps_,this.invertsY_);l===0&&p===0||this.value.setRawValue(new Fn(this.value.rawValue.x+l,this.value.rawValue.y+p),{forceEmit:!1,last:!1})}onPadKeyUp_(r){const[l,p]=cc(r,this.baseSteps_,this.invertsY_);l===0&&p===0||this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}class cf{constructor(r,l){var p,w;this.onPopupChildBlur_=this.onPopupChildBlur_.bind(this),this.onPopupChildKeydown_=this.onPopupChildKeydown_.bind(this),this.onPadButtonBlur_=this.onPadButtonBlur_.bind(this),this.onPadButtonClick_=this.onPadButtonClick_.bind(this),this.value=l.value,this.viewProps=l.viewProps,this.foldable_=D.create(l.expanded),this.popC_=l.pickerLayout==="popup"?new zl(r,{viewProps:this.viewProps}):null;const I=new lf(r,{baseSteps:[l.axes[0].baseStep,l.axes[1].baseStep],invertsY:l.invertsY,layout:l.pickerLayout,maxValue:l.maxValue,value:this.value,viewProps:this.viewProps});I.view.allFocusableElements.forEach(O=>{O.addEventListener("blur",this.onPopupChildBlur_),O.addEventListener("keydown",this.onPopupChildKeydown_)}),this.pickerC_=I,this.textC_=new $o(r,{assembly:lc,axes:l.axes,parser:l.parser,value:this.value,viewProps:this.viewProps}),this.view=new of(r,{expanded:this.foldable_.value("expanded"),pickerLayout:l.pickerLayout,viewProps:this.viewProps}),this.view.textElement.appendChild(this.textC_.view.element),(p=this.view.buttonElement)===null||p===void 0||p.addEventListener("blur",this.onPadButtonBlur_),(w=this.view.buttonElement)===null||w===void 0||w.addEventListener("click",this.onPadButtonClick_),this.popC_?(this.view.element.appendChild(this.popC_.view.element),this.popC_.view.element.appendChild(this.pickerC_.view.element),Cr({primary:this.foldable_.value("expanded"),secondary:this.popC_.shows,forward:O=>O.rawValue,backward:(O,ct)=>ct.rawValue})):this.view.pickerElement&&(this.view.pickerElement.appendChild(this.pickerC_.view.element),Ut(this.foldable_,this.view.pickerElement))}onPadButtonBlur_(r){if(!this.popC_)return;const l=this.view.element,p=r.relatedTarget;(!p||!l.contains(p))&&(this.popC_.shows.rawValue=!1)}onPadButtonClick_(){this.foldable_.set("expanded",!this.foldable_.get("expanded")),this.foldable_.get("expanded")&&this.pickerC_.view.allFocusableElements[0].focus()}onPopupChildBlur_(r){if(!this.popC_)return;const l=this.popC_.view.element,p=Lt(r);p&&l.contains(p)||p&&p===this.view.buttonElement&&!Z(l.ownerDocument)||(this.popC_.shows.rawValue=!1)}onPopupChildKeydown_(r){this.popC_?r.key==="Escape"&&(this.popC_.shows.rawValue=!1):this.view.pickerElement&&r.key==="Escape"&&this.view.buttonElement.focus()}}function hf(c){return Fn.isObject(c)?new Fn(c.x,c.y):new Fn}function uf(c,r){c.writeProperty("x",r.x),c.writeProperty("y",r.y)}function hc(c){if(!c)return;const r=[];return f(c.step)||r.push(new oi(c.step)),(!f(c.max)||!f(c.min))&&r.push(new We({max:c.max,min:c.min})),new si(r)}function df(c){return new Nn({assembly:lc,components:[hc("x"in c?c.x:void 0),hc("y"in c?c.y:void 0)]})}function uc(c,r){const l=c&&mn(c,We);if(l)return Math.max(Math.abs(l.minValue||0),Math.abs(l.maxValue||0));const p=Mi(c);return Math.max(Math.abs(p)*10,Math.abs(r)*10)}function pf(c,r){const l=r instanceof Nn?r.components[0]:void 0,p=r instanceof Nn?r.components[1]:void 0,w=uc(l,c.x),I=uc(p,c.y);return Math.max(w,I)}function dc(c,r){return{baseStep:Mi(r),constraint:r,textProps:B.fromObject({draggingScale:Si(r,c),formatter:Oe(ms(r,c))})}}function ff(c){if(!("y"in c))return!1;const r=c.y;return r&&"inverted"in r?!!r.inverted:!1}const mf={id:"input-point2d",type:"input",accept:(c,r)=>{if(!Fn.isObject(c))return null;const l=vt,p=J(r,{expanded:l.optional.boolean,picker:l.optional.custom($l),x:l.optional.custom(Dn),y:l.optional.object({inverted:l.optional.boolean,max:l.optional.number,min:l.optional.number,step:l.optional.number})});return p?{initialValue:c,params:p}:null},binding:{reader:c=>hf,constraint:c=>df(c.params),equals:Fn.equals,writer:c=>uf},controller:c=>{const r=c.document,l=c.value,p=c.constraint;if(!(p instanceof Nn))throw v.shouldNeverHappen();const w="expanded"in c.params?c.params.expanded:void 0,I="picker"in c.params?c.params.picker:void 0;return new cf(r,{axes:[dc(l.rawValue.x,p.components[0]),dc(l.rawValue.y,p.components[1])],expanded:w!=null?w:!1,invertsY:ff(c.params),maxValue:pf(l.rawValue,p),parser:En,pickerLayout:I!=null?I:"popup",value:l,viewProps:c.viewProps})}};class Ai{constructor(r=0,l=0,p=0){this.x=r,this.y=l,this.z=p}getComponents(){return[this.x,this.y,this.z]}static isObject(r){if(f(r))return!1;const l=r.x,p=r.y,w=r.z;return!(typeof l!="number"||typeof p!="number"||typeof w!="number")}static equals(r,l){return r.x===l.x&&r.y===l.y&&r.z===l.z}toObject(){return{x:this.x,y:this.y,z:this.z}}}const pc={toComponents:c=>c.getComponents(),fromComponents:c=>new Ai(...c)};function gf(c){return Ai.isObject(c)?new Ai(c.x,c.y,c.z):new Ai}function vf(c,r){c.writeProperty("x",r.x),c.writeProperty("y",r.y),c.writeProperty("z",r.z)}function Qo(c){if(!c)return;const r=[];return f(c.step)||r.push(new oi(c.step)),(!f(c.max)||!f(c.min))&&r.push(new We({max:c.max,min:c.min})),new si(r)}function _f(c){return new Nn({assembly:pc,components:[Qo("x"in c?c.x:void 0),Qo("y"in c?c.y:void 0),Qo("z"in c?c.z:void 0)]})}function ta(c,r){return{baseStep:Mi(r),constraint:r,textProps:B.fromObject({draggingScale:Si(r,c),formatter:Oe(ms(r,c))})}}const xf={id:"input-point3d",type:"input",accept:(c,r)=>{if(!Ai.isObject(c))return null;const l=vt,p=J(r,{x:l.optional.custom(Dn),y:l.optional.custom(Dn),z:l.optional.custom(Dn)});return p?{initialValue:c,params:p}:null},binding:{reader:c=>gf,constraint:c=>_f(c.params),equals:Ai.equals,writer:c=>vf},controller:c=>{const r=c.value,l=c.constraint;if(!(l instanceof Nn))throw v.shouldNeverHappen();return new $o(c.document,{assembly:pc,axes:[ta(r.rawValue.x,l.components[0]),ta(r.rawValue.y,l.components[1]),ta(r.rawValue.z,l.components[2])],parser:En,value:r,viewProps:c.viewProps})}};class Pi{constructor(r=0,l=0,p=0,w=0){this.x=r,this.y=l,this.z=p,this.w=w}getComponents(){return[this.x,this.y,this.z,this.w]}static isObject(r){if(f(r))return!1;const l=r.x,p=r.y,w=r.z,I=r.w;return!(typeof l!="number"||typeof p!="number"||typeof w!="number"||typeof I!="number")}static equals(r,l){return r.x===l.x&&r.y===l.y&&r.z===l.z&&r.w===l.w}toObject(){return{x:this.x,y:this.y,z:this.z,w:this.w}}}const fc={toComponents:c=>c.getComponents(),fromComponents:c=>new Pi(...c)};function bf(c){return Pi.isObject(c)?new Pi(c.x,c.y,c.z,c.w):new Pi}function yf(c,r){c.writeProperty("x",r.x),c.writeProperty("y",r.y),c.writeProperty("z",r.z),c.writeProperty("w",r.w)}function ws(c){if(!c)return;const r=[];return f(c.step)||r.push(new oi(c.step)),(!f(c.max)||!f(c.min))&&r.push(new We({max:c.max,min:c.min})),new si(r)}function wf(c){return new Nn({assembly:fc,components:[ws("x"in c?c.x:void 0),ws("y"in c?c.y:void 0),ws("z"in c?c.z:void 0),ws("w"in c?c.w:void 0)]})}function Mf(c,r){return{baseStep:Mi(r),constraint:r,textProps:B.fromObject({draggingScale:Si(r,c),formatter:Oe(ms(r,c))})}}const Sf={id:"input-point4d",type:"input",accept:(c,r)=>{if(!Pi.isObject(c))return null;const l=vt,p=J(r,{x:l.optional.custom(Dn),y:l.optional.custom(Dn),z:l.optional.custom(Dn),w:l.optional.custom(Dn)});return p?{initialValue:c,params:p}:null},binding:{reader:c=>bf,constraint:c=>wf(c.params),equals:Pi.equals,writer:c=>yf},controller:c=>{const r=c.value,l=c.constraint;if(!(l instanceof Nn))throw v.shouldNeverHappen();return new $o(c.document,{assembly:fc,axes:r.rawValue.getComponents().map((p,w)=>Mf(p,l.components[w])),parser:En,value:r,viewProps:c.viewProps})}};function Ef(c){const r=[],l=Uo(c.options);return l&&r.push(l),new si(r)}const Tf={id:"input-string",type:"input",accept:(c,r)=>{if(typeof c!="string")return null;const p=J(r,{options:vt.optional.custom(fs)});return p?{initialValue:c,params:p}:null},binding:{reader:c=>Yl,constraint:c=>Ef(c.params),writer:c=>Lr},controller:c=>{var r;const l=c.document,p=c.value,w=c.constraint;return w&&mn(w,Mr)?new Sr(l,{props:B.fromObject({options:(r=Ho(w))!==null&&r!==void 0?r:[]}),value:p,viewProps:c.viewProps}):new ds(l,{parser:I=>I,props:B.fromObject({formatter:Fo}),value:p,viewProps:c.viewProps})}},Dr={monitor:{defaultInterval:200,defaultLineCount:3}},mc=_("mll");class Cf{constructor(r,l){this.onValueUpdate_=this.onValueUpdate_.bind(this),this.formatter_=l.formatter,this.element=r.createElement("div"),this.element.classList.add(mc()),l.viewProps.bindClassModifiers(this.element);const p=r.createElement("textarea");p.classList.add(mc("i")),p.style.height=`calc(var(--bld-us) * ${l.lineCount})`,p.readOnly=!0,l.viewProps.bindDisabled(p),this.element.appendChild(p),this.textareaElem_=p,l.value.emitter.on("change",this.onValueUpdate_),this.value=l.value,this.update_()}update_(){const r=this.textareaElem_,l=r.scrollTop===r.scrollHeight-r.clientHeight,p=[];this.value.rawValue.forEach(w=>{w!==void 0&&p.push(this.formatter_(w))}),r.textContent=p.join(`
`),l&&(r.scrollTop=r.scrollHeight)}onValueUpdate_(){this.update_()}}class ea{constructor(r,l){this.value=l.value,this.viewProps=l.viewProps,this.view=new Cf(r,{formatter:l.formatter,lineCount:l.lineCount,value:this.value,viewProps:this.viewProps})}}const gc=_("sgl");class Af{constructor(r,l){this.onValueUpdate_=this.onValueUpdate_.bind(this),this.formatter_=l.formatter,this.element=r.createElement("div"),this.element.classList.add(gc()),l.viewProps.bindClassModifiers(this.element);const p=r.createElement("input");p.classList.add(gc("i")),p.readOnly=!0,p.type="text",l.viewProps.bindDisabled(p),this.element.appendChild(p),this.inputElement=p,l.value.emitter.on("change",this.onValueUpdate_),this.value=l.value,this.update_()}update_(){const r=this.value.rawValue,l=r[r.length-1];this.inputElement.value=l!==void 0?this.formatter_(l):""}onValueUpdate_(){this.update_()}}class na{constructor(r,l){this.value=l.value,this.viewProps=l.viewProps,this.view=new Af(r,{formatter:l.formatter,value:this.value,viewProps:this.viewProps})}}const Pf={id:"monitor-bool",type:"monitor",accept:(c,r)=>{if(typeof c!="boolean")return null;const p=J(r,{lineCount:vt.optional.number});return p?{initialValue:c,params:p}:null},binding:{reader:c=>Hl},controller:c=>{var r;return c.value.rawValue.length===1?new na(c.document,{formatter:Gl,value:c.value,viewProps:c.viewProps}):new ea(c.document,{formatter:Gl,lineCount:(r=c.params.lineCount)!==null&&r!==void 0?r:Dr.monitor.defaultLineCount,value:c.value,viewProps:c.viewProps})}};class Lf{constructor(){this.emitter=new M,this.index_=-1}get index(){return this.index_}set index(r){this.index_!==r&&(this.index_=r,this.emitter.emit("change",{index:r,sender:this}))}}const Bn=_("grl");class Rf{constructor(r,l){this.onCursorChange_=this.onCursorChange_.bind(this),this.onValueUpdate_=this.onValueUpdate_.bind(this),this.element=r.createElement("div"),this.element.classList.add(Bn()),l.viewProps.bindClassModifiers(this.element),this.formatter_=l.formatter,this.minValue_=l.minValue,this.maxValue_=l.maxValue,this.cursor_=l.cursor,this.cursor_.emitter.on("change",this.onCursorChange_);const p=r.createElementNS(dt,"svg");p.classList.add(Bn("g")),p.style.height=`calc(var(--bld-us) * ${l.lineCount})`,this.element.appendChild(p),this.svgElem_=p;const w=r.createElementNS(dt,"polyline");this.svgElem_.appendChild(w),this.lineElem_=w;const I=r.createElement("div");I.classList.add(Bn("t"),_("tt")()),this.element.appendChild(I),this.tooltipElem_=I,l.value.emitter.on("change",this.onValueUpdate_),this.value=l.value,this.update_()}get graphElement(){return this.svgElem_}update_(){const r=this.svgElem_.getBoundingClientRect(),l=this.value.rawValue.length-1,p=this.minValue_,w=this.maxValue_,I=[];this.value.rawValue.forEach((Xt,Yt)=>{if(Xt===void 0)return;const hi=re(Yt,0,l,0,r.width),Ir=re(Xt,p,w,r.height,0);I.push([hi,Ir].join(","))}),this.lineElem_.setAttributeNS(null,"points",I.join(" "));const O=this.tooltipElem_,ct=this.value.rawValue[this.cursor_.index];if(ct===void 0){O.classList.remove(Bn("t","a"));return}const Dt=re(this.cursor_.index,0,l,0,r.width),Bt=re(ct,p,w,r.height,0);O.style.left=`${Dt}px`,O.style.top=`${Bt}px`,O.textContent=`${this.formatter_(ct)}`,O.classList.contains(Bn("t","a"))||(O.classList.add(Bn("t","a"),Bn("t","in")),xt(O),O.classList.remove(Bn("t","in")))}onValueUpdate_(){this.update_()}onCursorChange_(){this.update_()}}class Df{constructor(r,l){if(this.onGraphMouseMove_=this.onGraphMouseMove_.bind(this),this.onGraphMouseLeave_=this.onGraphMouseLeave_.bind(this),this.onGraphPointerDown_=this.onGraphPointerDown_.bind(this),this.onGraphPointerMove_=this.onGraphPointerMove_.bind(this),this.onGraphPointerUp_=this.onGraphPointerUp_.bind(this),this.value=l.value,this.viewProps=l.viewProps,this.cursor_=new Lf,this.view=new Rf(r,{cursor:this.cursor_,formatter:l.formatter,lineCount:l.lineCount,maxValue:l.maxValue,minValue:l.minValue,value:this.value,viewProps:this.viewProps}),!Z(r))this.view.element.addEventListener("mousemove",this.onGraphMouseMove_),this.view.element.addEventListener("mouseleave",this.onGraphMouseLeave_);else{const p=new ai(this.view.element);p.emitter.on("down",this.onGraphPointerDown_),p.emitter.on("move",this.onGraphPointerMove_),p.emitter.on("up",this.onGraphPointerUp_)}}onGraphMouseLeave_(){this.cursor_.index=-1}onGraphMouseMove_(r){const l=this.view.element.getBoundingClientRect();this.cursor_.index=Math.floor(re(r.offsetX,0,l.width,0,this.value.rawValue.length))}onGraphPointerDown_(r){this.onGraphPointerMove_(r)}onGraphPointerMove_(r){if(!r.data.point){this.cursor_.index=-1;return}this.cursor_.index=Math.floor(re(r.data.point.x,0,r.data.bounds.width,0,this.value.rawValue.length))}onGraphPointerUp_(){this.cursor_.index=-1}}function ia(c){return"format"in c&&!f(c.format)?c.format:Oe(2)}function If(c){var r;return c.value.rawValue.length===1?new na(c.document,{formatter:ia(c.params),value:c.value,viewProps:c.viewProps}):new ea(c.document,{formatter:ia(c.params),lineCount:(r=c.params.lineCount)!==null&&r!==void 0?r:Dr.monitor.defaultLineCount,value:c.value,viewProps:c.viewProps})}function Nf(c){var r,l,p;return new Df(c.document,{formatter:ia(c.params),lineCount:(r=c.params.lineCount)!==null&&r!==void 0?r:Dr.monitor.defaultLineCount,maxValue:(l="max"in c.params?c.params.max:null)!==null&&l!==void 0?l:100,minValue:(p="min"in c.params?c.params.min:null)!==null&&p!==void 0?p:0,value:c.value,viewProps:c.viewProps})}function vc(c){return"view"in c&&c.view==="graph"}const Ff={id:"monitor-number",type:"monitor",accept:(c,r)=>{if(typeof c!="number")return null;const l=vt,p=J(r,{format:l.optional.function,lineCount:l.optional.number,max:l.optional.number,min:l.optional.number,view:l.optional.string});return p?{initialValue:c,params:p}:null},binding:{defaultBufferSize:c=>vc(c)?64:1,reader:c=>Xl},controller:c=>vc(c.params)?Nf(c):If(c)},kf={id:"monitor-string",type:"monitor",accept:(c,r)=>{if(typeof c!="string")return null;const l=vt,p=J(r,{lineCount:l.optional.number,multiline:l.optional.boolean});return p?{initialValue:c,params:p}:null},binding:{reader:c=>Yl},controller:c=>{var r;const l=c.value;return l.rawValue.length>1||"multiline"in c.params&&c.params.multiline?new ea(c.document,{formatter:Fo,lineCount:(r=c.params.lineCount)!==null&&r!==void 0?r:Dr.monitor.defaultLineCount,value:l,viewProps:c.viewProps}):new na(c.document,{formatter:Fo,value:l,viewProps:c.viewProps})}};class Bf{constructor(r){this.onValueChange_=this.onValueChange_.bind(this),this.reader=r.reader,this.writer=r.writer,this.emitter=new M,this.value=r.value,this.value.emitter.on("change",this.onValueChange_),this.target=r.target,this.read()}read(){const r=this.target.read();r!==void 0&&(this.value.rawValue=this.reader(r))}write_(r){this.writer(this.target,r)}onValueChange_(r){this.write_(r.rawValue),this.emitter.emit("change",{options:r.options,rawValue:r.rawValue,sender:this})}}function Vf(c,r){const l=c.accept(r.target.read(),r.params);if(f(l))return null;const p=vt,w={target:r.target,initialValue:l.initialValue,params:l.params},I=c.binding.reader(w),O=c.binding.constraint?c.binding.constraint(w):void 0,ct=j(I(l.initialValue),{constraint:O,equals:c.binding.equals}),Dt=new Bf({reader:I,target:r.target,value:ct,writer:c.binding.writer(w)}),Bt=p.optional.boolean(r.params.disabled).value,Xt=p.optional.boolean(r.params.hidden).value,Yt=c.controller({constraint:O,document:r.document,initialValue:l.initialValue,params:l.params,value:Dt.value,viewProps:Ee.create({disabled:Bt,hidden:Xt})}),hi=p.optional.string(r.params.label).value;return new Ge(r.document,{binding:Dt,blade:gt(),props:B.fromObject({label:hi||r.target.key}),valueController:Yt})}class Of{constructor(r){this.onTick_=this.onTick_.bind(this),this.reader_=r.reader,this.target=r.target,this.emitter=new M,this.value=r.value,this.ticker=r.ticker,this.ticker.emitter.on("tick",this.onTick_),this.read()}dispose(){this.ticker.dispose()}read(){const r=this.target.read();if(r===void 0)return;const l=this.value.rawValue,p=this.reader_(r);this.value.rawValue=Xd(l,p),this.emitter.emit("update",{rawValue:p,sender:this})}onTick_(r){this.read()}}function zf(c,r){return r===0?new ud:new dd(c,r!=null?r:Dr.monitor.defaultInterval)}function Uf(c,r){var l,p,w;const I=vt,O=c.accept(r.target.read(),r.params);if(f(O))return null;const ct={target:r.target,initialValue:O.initialValue,params:O.params},Dt=c.binding.reader(ct),Bt=(p=(l=I.optional.number(r.params.bufferSize).value)!==null&&l!==void 0?l:c.binding.defaultBufferSize&&c.binding.defaultBufferSize(O.params))!==null&&p!==void 0?p:1,Xt=I.optional.number(r.params.interval).value,Yt=new Of({reader:Dt,target:r.target,ticker:zf(r.document,Xt),value:qd(Bt)}),hi=I.optional.boolean(r.params.disabled).value,Ir=I.optional.boolean(r.params.hidden).value,Nr=c.controller({document:r.document,params:O.params,value:Yt.value,viewProps:Ee.create({disabled:hi,hidden:Ir})}),Li=(w=I.optional.string(r.params.label).value)!==null&&w!==void 0?w:r.target.key;return new sn(r.document,{binding:Yt,blade:gt(),props:B.fromObject({label:Li}),valueController:Nr})}class Hf{constructor(){this.pluginsMap_={blades:[],inputs:[],monitors:[]}}getAll(){return[...this.pluginsMap_.blades,...this.pluginsMap_.inputs,...this.pluginsMap_.monitors]}register(r){r.type==="blade"?this.pluginsMap_.blades.unshift(r):r.type==="input"?this.pluginsMap_.inputs.unshift(r):r.type==="monitor"&&this.pluginsMap_.monitors.unshift(r)}createInput(r,l,p){const w=l.read();if(f(w))throw new v({context:{key:l.key},type:"nomatchingcontroller"});const I=this.pluginsMap_.inputs.reduce((O,ct)=>O||Vf(ct,{document:r,target:l,params:p}),null);if(I)return I;throw new v({context:{key:l.key},type:"nomatchingcontroller"})}createMonitor(r,l,p){const w=this.pluginsMap_.monitors.reduce((I,O)=>I||Uf(O,{document:r,params:p,target:l}),null);if(w)return w;throw new v({context:{key:l.key},type:"nomatchingcontroller"})}createBlade(r,l){const p=this.pluginsMap_.blades.reduce((w,I)=>w||hd(I,{document:r,params:l}),null);if(!p)throw new v({type:"nomatchingview",context:{params:l}});return p}createBladeApi(r){if(r instanceof Ge)return new bi(r);if(r instanceof sn)return new rn(r);if(r instanceof et)return new yi(r,this);const l=this.pluginsMap_.blades.reduce((p,w)=>p||w.api({controller:r,pool:this}),null);if(!l)throw v.shouldNeverHappen();return l}}function Gf(){const c=new Hf;return[mf,xf,Sf,Tf,sf,Kp,Zp,Xp,ip,Pf,kf,Ff,pt,Ot,le,Vl].forEach(r=>{c.register(r)}),c}class _c extends i{constructor(r){super(r),this.emitter_=new M,this.controller_.valueController.value.emitter.on("change",l=>{this.emitter_.emit("change",{event:new a(this,l.rawValue)})})}get label(){return this.controller_.props.get("label")}set label(r){this.controller_.props.set("label",r)}get options(){return this.controller_.valueController.props.get("options")}set options(r){this.controller_.valueController.props.set("options",r)}get value(){return this.controller_.valueController.value.rawValue}set value(r){this.controller_.valueController.value.rawValue=r}on(r,l){const p=l.bind(this);return this.emitter_.on(r,w=>{p(w.event)}),this}}class xc extends i{constructor(r){super(r),this.emitter_=new M,this.controller_.valueController.value.emitter.on("change",l=>{this.emitter_.emit("change",{event:new a(this,l.rawValue)})})}get label(){return this.controller_.props.get("label")}set label(r){this.controller_.props.set("label",r)}get maxValue(){return this.controller_.valueController.sliderController.props.get("maxValue")}set maxValue(r){this.controller_.valueController.sliderController.props.set("maxValue",r)}get minValue(){return this.controller_.valueController.sliderController.props.get("minValue")}set minValue(r){this.controller_.valueController.sliderController.props.set("minValue",r)}get value(){return this.controller_.valueController.value.rawValue}set value(r){this.controller_.valueController.value.rawValue=r}on(r,l){const p=l.bind(this);return this.emitter_.on(r,w=>{p(w.event)}),this}}class bc extends i{constructor(r){super(r),this.emitter_=new M,this.controller_.valueController.value.emitter.on("change",l=>{this.emitter_.emit("change",{event:new a(this,l.rawValue)})})}get label(){return this.controller_.props.get("label")}set label(r){this.controller_.props.set("label",r)}get formatter(){return this.controller_.valueController.props.get("formatter")}set formatter(r){this.controller_.valueController.props.set("formatter",r)}get value(){return this.controller_.valueController.value.rawValue}set value(r){this.controller_.valueController.value.rawValue=r}on(r,l){const p=l.bind(this);return this.emitter_.on(r,w=>{p(w.event)}),this}}const Wf=function(){return{id:"list",type:"blade",accept(c){const r=vt,l=J(c,{options:r.required.custom(fs),value:r.required.raw,view:r.required.constant("list"),label:r.optional.string});return l?{params:l}:null},controller(c){const r=new Sr(c.document,{props:B.fromObject({options:Ql(c.params.options)}),value:j(c.params.value),viewProps:c.viewProps});return new Wt(c.document,{blade:c.blade,props:B.fromObject({label:c.params.label}),valueController:r})},api(c){return!(c.controller instanceof Wt)||!(c.controller.valueController instanceof Sr)?null:new _c(c.controller)}}}();function qf(c){return c.reduce((r,l)=>Object.assign(r,{[l.presetKey]:l.read()}),{})}function jf(c,r){c.forEach(l=>{const p=r[l.presetKey];p!==void 0&&l.write(p)})}class Xf extends ri{constructor(r,l){super(r,l)}get element(){return this.controller_.view.element}importPreset(r){const l=this.controller_.rackController.rack.find(Ge).map(p=>p.binding.target);jf(l,r),this.refresh()}exportPreset(){const r=this.controller_.rackController.rack.find(Ge).map(l=>l.binding.target);return qf(r)}refresh(){this.controller_.rackController.rack.find(Ge).forEach(r=>{r.binding.read()}),this.controller_.rackController.rack.find(sn).forEach(r=>{r.binding.read()})}}class Yf extends Pt{constructor(r,l){super(r,{expanded:l.expanded,blade:l.blade,props:l.props,root:!0,viewProps:l.viewProps})}}const Zf={id:"slider",type:"blade",accept(c){const r=vt,l=J(c,{max:r.required.number,min:r.required.number,view:r.required.constant("slider"),format:r.optional.function,label:r.optional.string,value:r.optional.number});return l?{params:l}:null},controller(c){var r,l;const p=(r=c.params.value)!==null&&r!==void 0?r:0,w=new zo(c.document,{baseStep:1,parser:En,sliderProps:B.fromObject({maxValue:c.params.max,minValue:c.params.min}),textProps:B.fromObject({draggingScale:Si(void 0,p),formatter:(l=c.params.format)!==null&&l!==void 0?l:Gd}),value:j(p),viewProps:c.viewProps});return new Wt(c.document,{blade:c.blade,props:B.fromObject({label:c.params.label}),valueController:w})},api(c){return!(c.controller instanceof Wt)||!(c.controller.valueController instanceof zo)?null:new xc(c.controller)}},Kf=function(){return{id:"text",type:"blade",accept(c){const r=vt,l=J(c,{parse:r.required.function,value:r.required.raw,view:r.required.constant("text"),format:r.optional.function,label:r.optional.string});return l?{params:l}:null},controller(c){var r;const l=new ds(c.document,{parser:c.params.parse,props:B.fromObject({formatter:(r=c.params.format)!==null&&r!==void 0?r:p=>String(p)}),value:j(c.params.value),viewProps:c.viewProps});return new Wt(c.document,{blade:c.blade,props:B.fromObject({label:c.params.label}),valueController:l})},api(c){return!(c.controller instanceof Wt)||!(c.controller.valueController instanceof ds)?null:new bc(c.controller)}}}();function Jf(c){const r=c.createElement("div");return r.classList.add(_("dfw")()),c.body&&c.body.appendChild(r),r}function yc(c,r,l){if(c.querySelector(`style[data-tp-style=${r}]`))return;const p=c.createElement("style");p.dataset.tpStyle=r,p.textContent=l,c.head.appendChild(p)}class $f extends Xf{constructor(r){var l;const p=r||{},w=(l=p.document)!==null&&l!==void 0?l:lt(),I=Gf(),O=new Yf(w,{expanded:p.expanded,blade:gt(),props:B.fromObject({title:p.title}),viewProps:Ee.create()});super(O,I),this.pool_=I,this.containerElem_=p.container||Jf(w),this.containerElem_.appendChild(this.element),this.doc_=w,this.usesDefaultWrapper_=!p.container,this.setUpDefaultPlugins_()}get document(){if(!this.doc_)throw v.alreadyDisposed();return this.doc_}dispose(){const r=this.containerElem_;if(!r)throw v.alreadyDisposed();if(this.usesDefaultWrapper_){const l=r.parentElement;l&&l.removeChild(r)}this.containerElem_=null,this.doc_=null,super.dispose()}registerPlugin(r){("plugin"in r?[r.plugin]:"plugins"in r?r.plugins:[]).forEach(p=>{this.pool_.register(p),this.embedPluginStyle_(p)})}embedPluginStyle_(r){r.css&&yc(this.document,`plugin-${r.id}`,r.css)}setUpDefaultPlugins_(){yc(this.document,"default",".tp-lstv_s,.tp-btnv_b,.tp-p2dv_b,.tp-colswv_sw,.tp-p2dpv_p,.tp-txtv_i,.tp-grlv_g,.tp-sglv_i,.tp-mllv_i,.tp-fldv_b,.tp-rotv_b,.tp-ckbv_i,.tp-coltxtv_ms,.tp-tbiv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-lstv_s,.tp-btnv_b,.tp-p2dv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-lstv_s:hover,.tp-btnv_b:hover,.tp-p2dv_b:hover{background-color:var(--btn-bg-h)}.tp-lstv_s:focus,.tp-btnv_b:focus,.tp-p2dv_b:focus{background-color:var(--btn-bg-f)}.tp-lstv_s:active,.tp-btnv_b:active,.tp-p2dv_b:active{background-color:var(--btn-bg-a)}.tp-lstv_s:disabled,.tp-btnv_b:disabled,.tp-p2dv_b:disabled{opacity:0.5}.tp-colswv_sw,.tp-p2dpv_p,.tp-txtv_i{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-colswv_sw:hover,.tp-p2dpv_p:hover,.tp-txtv_i:hover{background-color:var(--in-bg-h)}.tp-colswv_sw:focus,.tp-p2dpv_p:focus,.tp-txtv_i:focus{background-color:var(--in-bg-f)}.tp-colswv_sw:active,.tp-p2dpv_p:active,.tp-txtv_i:active{background-color:var(--in-bg-a)}.tp-colswv_sw:disabled,.tp-p2dpv_p:disabled,.tp-txtv_i:disabled{opacity:0.5}.tp-grlv_g,.tp-sglv_i,.tp-mllv_i{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);width:100%}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono,Source Code Pro,Menlo,Courier,monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #2f3137);--bs-sh: var(--tp-base-shadow-color, rgba(0,0,0,0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #2f3137);--cnt-bg: var(--tp-container-background-color, rgba(187,188,196,0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187,188,196,0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187,188,196,0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187,188,196,0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(0,0,0,0.2));--in-bg-a: var(--tp-input-background-color-active, rgba(0,0,0,0.35));--in-bg-f: var(--tp-input-background-color-focus, rgba(0,0,0,0.3));--in-bg-h: var(--tp-input-background-color-hover, rgba(0,0,0,0.25));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187,188,196,0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0,0,0,0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187,188,196,0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(0,0,0,0.2))}.tp-fldv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-rotv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1 * var(--cnt-v-p))}.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-fldv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-rotv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-fldv_c>.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv{margin-left:4px}.tp-fldv_c>.tp-fldv>.tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-fldv_c .tp-fldv>.tp-fldv_c,.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-fldv_c>.tp-tabv>.tp-tabv_i,.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-fldv_c .tp-tabv>.tp-tabv_c,.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-fldv_b,.tp-rotv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:calc(var(--cnt-h-p) + 8px);padding-right:calc(2px * 2 + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-fldv_b:hover,.tp-rotv_b:hover{background-color:var(--cnt-bg-h)}.tp-fldv_b:focus,.tp-rotv_b:focus{background-color:var(--cnt-bg-f)}.tp-fldv_b:active,.tp-rotv_b:active{background-color:var(--cnt-bg-a)}.tp-fldv_b:disabled,.tp-rotv_b:disabled{opacity:0.5}.tp-fldv_m,.tp-rotv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:'';display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px) / 2 - 2px);margin:auto;opacity:0.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m,.tp-rotv.tp-rotv-expanded .tp-rotv_m{transform:none}.tp-fldv_c,.tp-rotv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c,.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c{display:none}.tp-fldv.tp-fldv-expanded>.tp-fldv_c,.tp-rotv.tp-rotv-expanded .tp-rotv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-coltxtv_m,.tp-lstv{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-coltxtv_mm,.tp-lstv_m{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-coltxtv_mm svg,.tp-lstv_m svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-coltxtv_mm svg path,.tp-lstv_m svg path{fill:currentColor}.tp-coltxtv_w,.tp-pndtxtv{display:flex}.tp-coltxtv_c,.tp-pndtxtv_a{width:100%}.tp-coltxtv_c+.tp-coltxtv_c,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-pndtxtv_a{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:0.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1 * var(--cnt-h-p));right:calc(-1 * var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:'';height:2px;left:calc(-1 * var(--cnt-h-p));position:absolute;right:calc(-1 * var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us) * 4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,0.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0,0,0,0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,0.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,0.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,0.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,0.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br)}.tp-colswv.tp-v-disabled{opacity:0.5}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,0.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:'';display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us) * 3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left 0.05s, top 0.05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:0.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:0.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:0.5}.tp-mllv_i{display:block;height:calc(var(--bld-us) * 3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:0.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1 * var(--cnt-h-p));right:calc(-1 * var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:0.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:0.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:0.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:'';display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:'';display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:'';display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:0.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:'';height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:'';height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:0.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:0.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:0.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:'';height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:0.1;position:absolute;top:0;transition:border-radius 0.1s, height 0.1s, transform 0.1s, width 0.1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:'';font-size:0.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(2px * 2 + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1 * var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1 * var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}"),this.pool_.getAll().forEach(r=>{this.embedPluginStyle_(r)}),this.registerPlugin({plugins:[Zf,Wf,Vl,Kf]})}}const Qf=new n("3.0.5");e.BladeApi=i,e.ButtonApi=y,e.FolderApi=ri,e.InputBindingApi=bi,e.ListApi=_c,e.MonitorBindingApi=rn,e.Pane=$f,e.SeparatorApi=Ht,e.SliderApi=xc,e.TabApi=kl,e.TabPageApi=Fl,e.TextApi=bc,e.TpChangeEvent=a,e.VERSION=Qf,Object.defineProperty(e,"__esModule",{value:!0})})})(ul,ul.exports);const Ke=new ul.exports.Pane({container:document.getElementById("controlPanel")}),dn={model_name:"",showData:!1,nodeScale:1,nodeColor:"#ffffff",nodeOpacity:.7,beamScale:1,beamColor:"#ffffff",beamOpacity:.7,shellDisplay:!0,shellColor:"#ffffff",shellOpacity:.7,rotation_y:0,color:"#0f0"};Ke.addInput(dn,"model_name");Ke.addInput(dn,"showData");var Iw=Ke.addInput(dn,"nodeScale",{min:.001,max:2}),Nw=Ke.addInput(dn,"nodeOpacity",{min:0,max:1}),Fw=Ke.addInput(dn,"nodeColor",{}),kw=Ke.addInput(dn,"beamScale",{min:.001,max:2}),Bw=Ke.addInput(dn,"beamOpacity",{min:0,max:1}),Vw=Ke.addInput(dn,"beamColor",{}),Ow=Ke.addButton({title:"RandomBeamColor"}),zw=Ke.addInput(dn,"shellDisplay",{title:"DisplayShellElements"}),Uw=Ke.addInput(dn,"shellOpacity",{min:0,max:1}),Hw=Ke.addInput(dn,"shellColor",{}),Gw=Ke.addButton({title:"RandomShellColor"});Iw.on("change",o=>{bw(o.value)});Nw.on("change",o=>{yw(o.value)});Fw.on("change",o=>{ww(o.value)});kw.on("change",o=>{Mw(o.value)});Bw.on("change",o=>{Sw(o.value)});Vw.on("change",o=>{Ew(o.value)});Ow.on("click",()=>{Tw()});zw.on("change",o=>{console.log(o.value),Pw(o.value)});Uw.on("change",o=>{Cw(o.value)});Hw.on("change",o=>{Aw(o.value)});Gw.on("click",()=>{Lw()});const Ka=document.getElementById("file-selector");Ka.addEventListener("change",o=>{const t=o.target.files,e=new FileReader;e.onload=function(n){return function(){for(var i=n.result,s=i.split(`
`),[a,h,u]=rm(s),d="<p id='tcl_txt_p'>",f=9;f<s.length;f++)d+=s[f]+"<br>";document.getElementById("tcl_txt").innerHTML=d,pw(a),fw(h,a),mw(u,a),Ka.value="",Ka.title=""}}(e),e.readAsText(t[0])});window.onload=window.resize=function(){document.getElementById("content").style.height=window.innerHeight+"px",document.getElementById("tcl_txt").style.height=document.getElementById("buildingVisualization").clientHeight-document.getElementById("controlPanel").clientHeight-document.getElementById("tcl_input").clientHeight+"px",console.log(window.innerHeight),console.log(document.getElementById("controlPanel").clientHeight),console.log(document.getElementById("tcl_input").clientHeight)};
